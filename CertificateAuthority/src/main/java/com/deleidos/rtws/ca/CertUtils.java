/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.ca;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.security.KeyStore.Entry;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.tika.io.IOUtils;

import com.deleidos.rtws.ca.bo.CSR;
import com.deleidos.rtws.ca.bo.CSRResult;
import com.deleidos.rtws.ca.bo.SubjectAltName;
import com.deleidos.rtws.ca.properties.CAProperties;
import com.deleidos.rtws.ca.properties.CAProperties.CERT_TYPE;
import com.deleidos.rtws.ca.properties.CAProperties.SIGN_TYPE;
import com.deleidos.rtws.ca.util.CertificateConversion;
import com.deleidos.rtws.ca.util.CommonResource;
import com.deleidos.rtws.ca.util.KeystoreUtil;
import com.deleidos.rtws.ca.util.ParseDBFile;
import com.deleidos.rtws.ca.util.ParseDBFile.DB_TYPE;
import com.deleidos.rtws.ca.util.StorageUtilsException;
import com.deleidos.rtws.commons.config.UserDataProperties;
import com.deleidos.rtws.commons.process.log.ProcessStream;

public class CertUtils {
	private Runtime rt=null;
	private static final Logger log = LogManager.getLogger(CertUtils.class);
	
	public enum TYPE {equal, not_equal};
	
	private final String rootCAFileName = "myca.crt";
	public enum Action {
		csr, sign, sign_ica, revoke, cert_pem2der, key_pem2der, key_decrypt2pkcs8, key_pem2der_passwd, print_cert, delete_cert
	}
	
	private File internalCAConfigFile=new File(String.format("%s/CA/sign.cnf", CAProperties.getRootCADir()));
	private File externalCAConfigFile=new File(String.format("%s/CA/external_sign.cnf", CAProperties.getRootCADir()));
	
	public CertUtils(boolean testCase) throws IOException{
		rt = Runtime.getRuntime();
		
		if(testCase == false){
			File rootdir = new File(CAProperties.getRootCADir());
			if(!rootdir.isDirectory())
				throw new IOException("Could not configure environment");
		}
	}
	
	public CertUtils() throws IOException{
		rt = Runtime.getRuntime();
		
		File rootdir = new File(CAProperties.getRootCADir());
		if(!rootdir.isDirectory())
			throw new IOException("Could not configure environment");

	}

	public String createRequest(String DN, String email, String keyFileName, List<SubjectAltName> subjAltName){
		File cfgloc=null;
		File tmpCsr=null;
		BufferedReader rdr=null;
		try{
			cfgloc = createConfig(DN,email, subjAltName);
			tmpCsr = File.createTempFile("req", ".csr");
			tmpCsr.deleteOnExit();
			rt = Runtime.getRuntime();
			
			String request = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s %s %s", Action.csr.toString(), 
					cfgloc.getCanonicalPath(), CAProperties.getTmpKeyLocation(keyFileName), tmpCsr.getCanonicalPath());
			
			Process proc = rt.exec(request);
			new ProcessStream(proc, log, Level.DEBUG, Level.DEBUG);
			proc.waitFor();
			StringBuilder bld = new StringBuilder();
			rdr = new BufferedReader(new FileReader(tmpCsr));
			String ln = rdr.readLine();
			String newline = System.getProperty("line.separator");
			while(ln!=null){
				bld.append(ln);
				bld.append(newline);
				ln = rdr.readLine();
			}
			String b64EncodedRequest = Base64.encodeBase64String(bld.toString().getBytes("UTF8"));
			
			return b64EncodedRequest;
		}catch(IOException e){
			log.error("Could not create request.",e);
			return null;
		} catch (InterruptedException e) {
			log.error("could not wait for process to finish.",e);
			return null;
		}finally{
			if(rdr!=null)
				try {
					rdr.close();
				} catch (IOException e) {
					log.error("unable to close file reader for temporary sign request file.",e);
				}
			if(cfgloc!=null && cfgloc.exists()){
				cfgloc.delete();
			}
			if(tmpCsr!=null && tmpCsr.exists())
				tmpCsr.delete();
		}
	}

	public File createConfig(String dn, String email, List<SubjectAltName> subjAltName){
		try{
		File tmpCfgFil = File.createTempFile("cfg_csr", ".cnf");
		tmpCfgFil.deleteOnExit();
		return createConfig(dn,email,tmpCfgFil, subjAltName);
		} catch(Exception e){
			log.error("unable to create temporary config file.",e);
			return null;
		}
	}
	
	public File createConfig(String dn, String email, File outConfig, List<SubjectAltName> subjAltName){
		InputStream is=null;
		BufferedWriter wt=null;
		try{
			if(subjAltName.size() > 0){
				is = this.getClass().getResourceAsStream("/openssl.my.cnf");
			}
			else{
				is = this.getClass().getResourceAsStream("/external.openssl.my.cnf");
			}
			wt = new BufferedWriter(new FileWriter(outConfig));
			byte[] buf = new byte[512];
			int read = is.read(buf);
			while(read >= 0){
				String s = new String(buf,0,read);
				wt.write(s);
				read = is.read(buf);
			}
			
			wt.write("C = US");
			wt.newLine();
			wt.write("ST = Maryland");
			wt.newLine();
			wt.write("L = Columbia");
			wt.newLine();
			wt.write("O = RTSAIC");
			wt.newLine();
			wt.write("CN = "+dn);
			wt.newLine();
			wt.write("emailAddress = "+email);
			wt.newLine();
			wt.write("name = "+UserDataProperties.getInstance().getString(UserDataProperties.RTWS_TENANT_ID));
			//if a subj alternate name is present add to csr request
			if(subjAltName.size() > 0){
				wt.newLine();
				wt.write("[alt_names]");
				for(int i = 0; i < subjAltName.size(); i++){
					wt.newLine();
					if(subjAltName.get(i).getSubjectAltNameType() == SubjectAltName.TYPE.IP){
						wt.write(String.format("IP.%s = %s", i+1, subjAltName.get(i).getSubjAltName()));
					}
					else{
						wt.write(String.format("DNS.%s = %s", i+1, subjAltName.get(i).getSubjAltName()));
					}
				}
			}
			wt.flush();

		}catch(IOException e){
			log.error("Error while creating config file",e);
			return null;
		}finally{
			try{
				if(is!=null)
					is.close();
				if(wt!=null)
					wt.close();
			}catch(IOException ioe){
				log.error("Could not close streams in finally clause.",ioe);
				return null;
			}
		}


		return outConfig;
	}

	public String signRequest(String request, String certFileName, CERT_TYPE certType, String cn, SIGN_TYPE signType){
		try{
			if(!internalCAConfigFile.exists() && !externalCAConfigFile.exists()){
				throw new Exception("Must Set up Signing config file before signing a request.");
			}
			
			//revoke cert before sign, redo later
			String certLoc = String.format("%s/%s.crt", CAProperties.getNewCertsDir(), certFileName);
			File outCert = new File(certLoc);
			
			String configPath = null;
			DB_TYPE dbFile = null;
			if(CERT_TYPE.internal ==  certType){
				configPath = internalCAConfigFile.getAbsolutePath();
				dbFile = DB_TYPE.internal;
			}
			else if(CERT_TYPE.external == certType){
				configPath = externalCAConfigFile.getAbsolutePath();
				dbFile = DB_TYPE.external;
				CommonResource.getInstance().createTemporaryPublicKeypair();
			}
			else{
				log.error("Unrecognized Certificate type throwing error");
				return null;
			}
			
			String serialNumber = runPrintCertCommand(certLoc);
			revokeCertificate(configPath, null, serialNumber);
			
			serialNumber = ParseDBFile.findSerialNumByCommonName(dbFile, cn);
			revokeCertificate(configPath, certLoc, serialNumber);
			
			byte[] decoded = Base64.decodeBase64(request);
			File tmp = File.createTempFile("signRequest", ".csr");
			tmp.deleteOnExit();
			FileOutputStream os = new FileOutputStream(tmp);
			os.write(decoded);
			os.flush();
			os.close();
			
			String build = null;
			
			if(signType.compareTo(SIGN_TYPE.cert) == 0){
				build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s %s %s %s", Action.sign.toString(), 
						configPath, CAProperties.getDefaultPasswordFile(), outCert.getAbsolutePath(),
						tmp.getAbsolutePath());
			}
			else if(signType.compareTo(SIGN_TYPE.ca) == 0){
				build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s %s %s %s", Action.sign_ica.toString(), 
						configPath, CAProperties.getDefaultPasswordFile(), outCert.getAbsolutePath(),
						tmp.getAbsolutePath());
			}
				
			log.debug(build);
			
			Process proc = rt.exec(build.toString());
			new ProcessStream(proc, log, Level.DEBUG, Level.DEBUG);
			int ret = proc.waitFor();
			if(ret!=0){
				log.error("There was an error signing certificate.  Call returned "+ret+".  See log for details.");
				return null;
			}
			
			StringBuilder bld = new StringBuilder();
			BufferedReader rdr = new BufferedReader(new FileReader(outCert));
			String ln = rdr.readLine();
			String newline = System.getProperty("line.separator");
			while(ln!=null){
				bld.append(ln);
				bld.append(newline);
				ln = rdr.readLine();
			}
			String b64EncodedCert = Base64.encodeBase64String(bld.toString().getBytes("UTF8"));
			
			//openssl ca -config openssl.my.cnf -policy policy_anything -batch -passin pass:foobar -out certs/tms-server.crt -infiles tms-server.csr
	
			return b64EncodedCert;
		} catch (Exception e){
			log.error("error signing request",e);
			return null;
		}
		finally{
			CommonResource.getInstance().cleanupTemporaryKeypair();
		}
	}

	public void revokePublic(String keyStoreFile) throws Exception{
		if(!externalCAConfigFile.exists()){
			throw new Exception("Must Set up Signing config file before signing a request.");
		}
		
		//get cert from keystore
		KeyStore ks = KeyStore.getInstance("JKS", "SUN");
		
		ks.load(new FileInputStream(keyStoreFile), CAProperties.getInternalKeyPassword().toCharArray());
		
		Enumeration<String> aliases = ks.aliases();
		while(aliases.hasMoreElements()){
			String currentAlias = aliases.nextElement();
			File tmpCert = File.createTempFile("tmp_cert", ".cert");
			Certificate cert = null;
			//trusted cert
			if(ks.isCertificateEntry(currentAlias)){
				cert = ks.getCertificate(currentAlias);
				IOUtils.write(cert.getEncoded(), new FileOutputStream(tmpCert));
			}
			//key entry
			else{
				Entry entry = ks.getEntry(currentAlias, new KeyStore.PasswordProtection(CAProperties.getInternalKeyPassword().toCharArray()));
				cert = ((PrivateKeyEntry) entry).getCertificate();
				
				FileOutputStream fos = null;
				try{
					fos = new FileOutputStream(tmpCert);
					IOUtils.write(cert.getEncoded(), fos);
				}finally{
					fos.close();
				}
				
			}
			
			//get crt name from keystore name
			String tmpName = keyStoreFile.substring(keyStoreFile.lastIndexOf('/')+1);
			tmpName= tmpName.replace(String.format("%s.jks", CAProperties.getKeystorePublicSuffix()), String.format("%s.crt", CAProperties.getCertPublicSuffix()));
			String pubCert = String.format("%s/%s", CAProperties.getNewCertsDir(), tmpName);
			
			synchronized(CommonResource.getInstance().getCertFile()){
				try{
					CommonResource.getInstance().createTemporaryPublicKeypair();
					revokeCertificate(externalCAConfigFile.getAbsolutePath(), pubCert, getSerialNumber(cert));
				}catch(Exception e){
					log.error(e.toString(),e );	
				}finally{
					CommonResource.getInstance().cleanupTemporaryKeypair();
				}
			}
			tmpCert.delete();
		}
		
		//delete keystore
		new File(keyStoreFile).delete();
	}
	
	public void revokeCertificate(String caConfigFile, String certFilePath, String serialNumber){
		try{
			String pemFile = null;
			
			if(serialNumber != null){
				pemFile = String.format("%s/%s.pem", CAProperties.getNewCertsDir(), serialNumber);
			}
			else{
				log.debug("Serial number for certificate is null.");
			}
			
			//check if certificate exists
			if(StringUtils.isNotBlank(certFilePath) == true  && new File(certFilePath).exists()){
				String build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s %s %s", Action.revoke.toString(), 
						caConfigFile, certFilePath, CAProperties.getDefaultPasswordFile());
				
				Process proc = rt.exec(build);
				new ProcessStream(proc, log, Level.DEBUG, Level.DEBUG);
				int ret = proc.waitFor();
				if(ret!=0){
					log.error(String.format("There was an error revoking the %s certificate.", certFilePath));
				}
				else{
					//delete cert file after revoked
					runCertDeleteCommand(certFilePath);
					if(StringUtils.isNotBlank(pemFile) == true && new File(pemFile).exists()){
						runCertDeleteCommand(pemFile);
					}
				}
			}
			else{
				//check if certificate exists
				if(StringUtils.isNotBlank(pemFile) == true  && new File(pemFile).exists()){
					String build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s %s %s", Action.revoke.toString(), 
							caConfigFile, pemFile, CAProperties.getDefaultPasswordFile());
					
					Process proc = rt.exec(build);
					new ProcessStream(proc, log, Level.DEBUG, Level.DEBUG);
					int ret = proc.waitFor();
					if(ret!=0){
						log.error(String.format("There was an error revoking the %s certificate.", pemFile));
					}
					else{
						runCertDeleteCommand(pemFile);
					}
				}
				else{
					log.debug("Certificate does not exist, can not revoke certificate.");
				}
			}
		} catch(Exception e){
			log.error(e.toString(), e);
		}
	}
	
	public void copyCertBetweenKeystore(String keyStore1, String keyPass1, String keyStore2, String keyPass2, String alias, TYPE type, boolean initialize){
		try{
			//initialize keystore
			KeyStore ksNew = KeyStore.getInstance("JKS", "SUN");
		
			if(initialize == true){
				//initialize/clear keystore
				ksNew.load(null, keyPass2.toCharArray());
				ksNew.store(new FileOutputStream(new File(keyStore2)), keyPass2.toCharArray());
				log.debug(String.format("Initializing keystore-file:  %s", new File(keyStore2).getCanonicalPath()));
			}
			else{
				ksNew.load(new FileInputStream(new File(keyStore2)), keyPass2.toCharArray());
			}
			
			//load trustore to copy certs from
			KeyStore ksOrig = KeyStore.getInstance("JKS", "SUN");
			ksOrig.load(new FileInputStream(new File(keyStore1)), keyPass1.toCharArray());
			
			Enumeration<String> aliases = ksOrig.aliases();
			
			switch(type){
				case equal:
					while(aliases.hasMoreElements()){
						String currentAlias = aliases.nextElement();
						if(currentAlias.equals(alias)){
							//trusted cert
							if(ksOrig.isCertificateEntry(currentAlias)){
								ksNew.setCertificateEntry(currentAlias, ksOrig.getCertificate(currentAlias));
							}
							//key entry
							else{
								Entry entry = ksOrig.getEntry(currentAlias, new KeyStore.PasswordProtection(keyPass1.toCharArray()));
								
								ksNew.setEntry(currentAlias, entry, new KeyStore.PasswordProtection(keyPass2.toCharArray()));
							}
							
							
						}
					}
					break;
				case not_equal:
					while(aliases.hasMoreElements()){
						String currentAlias = aliases.nextElement();
						if(! currentAlias.equals(alias)){
							//trusted cert
							if(ksOrig.isCertificateEntry(currentAlias)){
								ksNew.setCertificateEntry(currentAlias, ksOrig.getCertificate(currentAlias));
							}
							//key entry
							else{
								Entry entry = ksOrig.getEntry(currentAlias, new KeyStore.PasswordProtection(keyPass1.toCharArray()));
								
								ksNew.setEntry(currentAlias, entry, new KeyStore.PasswordProtection(keyPass2.toCharArray()));
							}
						}
					}
					break;
				default:
					log.info("Unrecognized option in copy certificates between keystores");
					break;
			}
			
			ksNew.store(new FileOutputStream(new File(keyStore2)), keyPass2.toCharArray());
			
		}catch(Exception e){
			log.error(e.toString(), e);
		}
	}
	
	/**
	 * Get the default keystore for the current JAVA_HOME.
	 * @return
	 */
	public String getDefaultKeystore(){
		String javaHome = System.getProperty("java.home");
		String keyStore = String.format("%s/lib/security/cacerts", javaHome);
		
		log.debug(String.format("Default keystore:  %s", keyStore));
		
		return keyStore;
		
	}
	
	public static void verifyKeystorePassword(InputStream is, String keyStorePassword) throws StorageUtilsException{
		try{
			//load trustore to copy certs from
			KeyStore tks = KeyStore.getInstance("JKS", "SUN");
			tks.load(is, keyStorePassword.toCharArray());
			
			is.close();
		} catch(Exception e){
			log.error(e.toString(), e);
			throw new StorageUtilsException("Keystore password is incorrect or a certificate in the trust store is not readable.", e);
		}
	}
	
	public void createEmptyJKS(String keyPass, String keyStoreFile){
		try{
			KeyStore ks = KeyStore.getInstance("JKS", "SUN");
			
			//initialize/clear keystore
			ks.load(null, keyPass.toCharArray());
			ks.store(new FileOutputStream(keyStoreFile), keyPass.toCharArray());
			log.debug(String.format("Initializing keystore-file:  %s", keyStoreFile));
		} catch(Exception e){
			log.error(e.toString(), e);
		}
	}

	public File getSigningCertificate() {
		return new File(String.format("%s/CA/certs/%s", CAProperties.getRootCADir(), rootCAFileName));
	}
	
	public FileInputStream signPublicCert(String domain, String certFileName, CERT_TYPE certType, String keyStore, String cn, SIGN_TYPE signType) throws FileNotFoundException{
		synchronized(CommonResource.getInstance().getCertFile()){
			File publicKeystore = null;
			try{
				String keyStoreFile = String.format("%s/%s.jks", CAProperties.getPublicDir(), keyStore);
				
				if(new File(keyStoreFile).exists()){
					publicKeystore = new File(keyStoreFile);
				}
				else{
					String request = createRequest(domain, CAProperties.getSigningEmail(), CAProperties.getTmpPublicDomainKeyName(), new ArrayList<SubjectAltName>(0));
					String encodedCert = signRequest(request, certFileName, certType, cn, signType);
					byte [] certificate = Base64.decodeBase64(encodedCert);
				
					//create keystore with keypair
					//add cert to keystore
					CertificateConversion.convertPEMToDER(certificate, CAProperties.getTmpKeyLocation(CAProperties.getTmpPublicDomainKeyName()));
					
					KeystoreUtil.addKeyAndCertToKeyStore(CAProperties.getInternalKeyPassword(), CAProperties.getPublicAlias(), 
							keyStoreFile, CAProperties.getTmpKeyDer(), CAProperties.getTmpCertDer(), true);
					
					publicKeystore = new File(keyStoreFile);
				}
			}catch(Exception e){
				log.error(e.toString(), e);
			}
			return new FileInputStream(publicKeystore);
		}
	}
	
	public String getSerialNumber(Certificate certificate){
		String serialNumber = null;
		try{
			CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
			X509Certificate cert = (X509Certificate) (certFactory.generateCertificate(new ByteArrayInputStream(certificate.getEncoded())));
			serialNumber = Hex.encodeHexString(cert.getSerialNumber().toByteArray());
			serialNumber = serialNumber.toUpperCase();  //change hex letters to upper from lower
		}catch(Exception e){
			log.error(e.toString(), e);
		}
		
		return serialNumber;
	}
	
	public void revokeExternalCertByDomain(String domain){
		File externalDir = new File(CAProperties.getPublicDir());
		String [] files = externalDir.list();
		String pattern = String.format("[.\\d\\D\\s\\S\\w\\W]*\\.%s%s.jks", domain, CAProperties.getKeystorePublicSuffix());
		
		for(String file : files){
			if(file.matches(pattern)){
				try{
					//try to delete as many certificates as possible log error and continue on
					revokePublic(String.format("%s/%s", CAProperties.getPublicDir(), file));
				}catch(Exception e){
					log.error(e.toString(), e);
				}
			}
		}
	}
	
	public void revokeInternalCertByDomain(String domain){
		File internalDir = new File(CAProperties.getNewCertsDir());
		String [] files = internalDir.list();
		String pattern = String.format("[.\\d\\D\\s\\S\\w\\W]*\\.%s[.\\d\\D\\s\\S\\w\\W]*\\.crt", domain);
		
		for(String file : files){
			if(file.matches(pattern)){
				try{
					//try to delete as many certificates as possible log error and continue on
					String absolutePath = String.format("%s/%s", CAProperties.getNewCertsDir(), file);
					String serialNumber = runPrintCertCommand(absolutePath);
					revokeCertificate(internalCAConfigFile.getAbsolutePath(), absolutePath, serialNumber);
				}catch(Exception e){
					log.error(e.toString(), e);
				}
			}
		}
	}
	
	public String runPrintCertCommand(String file){
		String serialNumber = null;
		try{
			String build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s", Action.print_cert.toString(), file);
			
			log.debug(build);
			
			Process proc = rt.exec(build.toString());
			//new ProcessStream(proc, log);
			int ret = proc.waitFor();
			if(ret!=0){
				log.error("There was an error signing certificate.  Call returned "+ret+".  See log for details.");
				return null;
			}
			
			//parse serial number
			//log std out
			InputStream is = proc.getInputStream();
			if(is != null){
				BufferedReader br = new BufferedReader(new InputStreamReader(is));
				String line = null;
				
				while((line = br.readLine()) != null){
					if(line.contains("serial=")){
						serialNumber = line.substring(line.indexOf('=')+1).trim();
						break;
					}
				}
				
				//cleanup
				is.close();
				br.close();
			}
		}catch(Exception e){
			log.error(e.toString(), e);
		}
		
		return serialNumber;
	}
	
	public void runCertDeleteCommand(String file){
		try{
			String build = String.format("/usr/local/rtws/cert-auth/bin/runCertCmd.sh %s %s", Action.delete_cert.toString(), file);
			
			log.debug(build);
			
			Process proc = rt.exec(build.toString());
			new ProcessStream(proc, log, Level.DEBUG, Level.DEBUG);
			int ret = proc.waitFor();
			if(ret!=0){
				log.error("There was an error signing certificate.  Call returned "+ret+".  See log for details.");
			}
		}catch(Exception e){
			log.error(e.toString(), e);
		}
	}
	
	public CSRResult processCsrRequests(CSR csr, SIGN_TYPE signType){
		CSRResult csrResult = new CSRResult();
		
		try{
			//sign internal cert for private domain with a subjAltName of private IP
			String uniqueFilename = getUniqueFilename(csr.getUniquePrivateDomainCn(), CAProperties.getPrivateDomainAlias());
			String certificate = signRequest(csr.getPrivateDomainCsr(), uniqueFilename, CERT_TYPE.internal, csr.getUniquePrivateDomainCn(), signType);
			csrResult.setPrivateDomainCertificate(certificate);
			csrResult.setSignType(signType);
			
			//generate hash key for pub cert
		
		}catch(Exception e){
			log.error(e.toString(), e);
			csrResult = new CSRResult();
		}
		
		return csrResult;
	}
	
	/*
  	openssl req -config openssl.my.cnf -new -x509 -extensions v3_ca -keyout private/myca.key -out certs/myca.crt -days 1825 -passout pass:foobar
	openssl req -config openssl.my.cnf -new -nodes -keyout private/tms-server.key -out tms-server.csr -days 365
	openssl ca -config openssl.my.cnf -policy policy_anything -batch -passin pass:foobar -out certs/tms-server.crt -infiles tms-server.csr
	 */
	
	private String getUniqueFilename(String prefix, String suffix){
		return String.format("%s_%s", prefix, suffix);
	}
	
	@SuppressWarnings("unused")
	private String getUniquePublicKeystoreName(String prefix){
		return String.format("%s%s", prefix, CAProperties.getKeystorePublicSuffix());
	}
}
