/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.core.framework.parser;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PushbackInputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;
import org.exolab.castor.xml.MarshalException;
import org.exolab.castor.xml.Unmarshaller;
import org.exolab.castor.xml.ValidationException;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.deleidos.rtws.core.framework.UserConfigured;

/**
 * Abstract base class for parsers that need to interpret data as xml. This
 * class assumes that the xml will be formatted as a sequence of records. The
 * constructor takes the tag name that encloses the record content. All tags
 * outside the record's xml block are ignored. Records cannot be nested within
 * one another. 
 * 
 * A practical limit has been established for the size of XML records to insure
 * that no one process over uses the available memory resources. The limit is
 * currently set at 512K and will dynamically grow up to 10M if needed. Because
 * parsing is handled on record at a time, this limit is applied to the size of
 * a single record, not an entire document. No limit is applied to document size.
 * 
 * If a data source provides XML records that exceed this limit, it is a likely
 * indicator that the data format is wastefully large. In which case the network
 * bandwidth required to move the input is probably a greater risk.
 * 
 */
public abstract class AbstractXMLParser extends AbstractBufferingParser {

    private static final Logger log = Logger.getLogger(AbstractXMLParser.class);
    
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    private static final int PUSHBACK_SIZE = 64;
    private static final int INITIAL_BUFFER_SIZE = 524288;
    private static final int MAX_DLQ_MSG_SIZE = 1024;

    /** Utility used to convert xml to DOM objects. */
    private DocumentBuilder xmlBuilder;

    private SAXBuilder jdomBuilder;

    /** The stream from which to read data. */
    private Reader stream;

    /** The number of valid characters in the buffer, i.e. how full it is. */
    private int limit = 0;

    /** A buffer used to split input into records. */
    private char[] buffer = new char[INITIAL_BUFFER_SIZE];

    /** The string that starts an xml block representing a single record. */
    private char[] START_TAG;

    /** The string that terminates an xml block representing a record. */
    private char[] END_TAG;

    /** The string that starts an xml block representing a header. */
    private char[] HEADER_START_TAG;

    /** The string that terminates an xml block representing a header. */
    private char[] HEADER_END_TAG;
    
    /** The input XML File. */
    private File xmlFile;
    
    /** The tag used to identify a record xml block */
    private String recordTag;
    
    /** The tag used to identify a header xml block */
    private String headerTag;
    
    /** Keep track of when we encounter ParserPipelineException for malformed XML */
    private boolean malformedXML = false;

	/**
     * Unmarshaller to be used when parsing into a bean. If not specified, the
     * static unmarshall method will be used.
     */
    private Unmarshaller unmarshaller = null;

    /**
     * Constructor.
     */
    public AbstractXMLParser() {
        super();
    }
    
    /**
     * Instantiates the XML and JDOM builders.
     * @throws ValidationException 
     */
	private void initialize() throws ValidationException {
		// only want this to happen once, check xmlBuilder and jdomBuilder for null
		if (xmlBuilder == null || jdomBuilder == null) {
			
			try {
				createRecordTag(this.recordTag);
				createHeaderTag(this.headerTag);
				xmlBuilder = DocumentBuilderFactory.newInstance()
						.newDocumentBuilder();
				jdomBuilder = new SAXBuilder();
			} catch (ParserConfigurationException e) {
				log.fatal("Unable to configure xml parser.");
			} 
		}
	}
    
    /**
     * Constructor. It will parse the input file and find the XML root tag and record tag.
     * 
     * @param xmlFile The name of the input XML file.
     * 
     */
    public AbstractXMLParser(File xmlFile) {
    	this.xmlFile = xmlFile;
    	parseHeaders();
    	try {
            xmlBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
            jdomBuilder = new SAXBuilder();
        } catch (ParserConfigurationException e) {
            log.fatal("Unable to configure xml parser.");
        }
    }
    
    /**
     * Creates the start and end tags for a record in the XML file.
     * 
     * @param recordTag The name of the record tag.
     * @throws ValidationException 
     */
    
    private void createRecordTag(String recordTag) throws ValidationException
    {
    	if (!recordTag.contentEquals("")) {
    		START_TAG = ("<" + recordTag).toCharArray();
    		END_TAG = ("</" + recordTag + ">").toCharArray();
    	}
    	else {
    		throw new ValidationException("Record tag in data model is empty");
    	}
    }

    /**
     * Creates the start and end tags for a roor in the XML file.
     * 
     * @param headerTag The name of the header tag.
     */
    
    private void createHeaderTag(String headerTag)
    {
    	HEADER_START_TAG = ("<" + headerTag).toCharArray();
        HEADER_END_TAG = ("</" + headerTag + ">").toCharArray();
    }
    
    /**
     * Sets this parser's data source.
     * 
     * @param stream
     * 			the InputStream that feeds the parser
     */
    public void setInputStream(InputStream stream) {
        try {
            if (!(stream instanceof PushbackInputStream)) {
                stream = new PushbackInputStream(stream, PUSHBACK_SIZE);
            }
            
            this.stream = reader((PushbackInputStream) stream);
        } catch (Exception e) {
            log.error("Unable to extract encoding from xml input stream.", e);
            this.stream = new StringReader("");
        }
    }
    
    /**
     * Sets the input XML file.
     * 
     * @param xmlFile
     *                Represents the input XML File.
     */
    
    public void setXMLFile(File xmlFile)
    {
    	this.xmlFile = xmlFile;
    }
    
    /**
     * @return The tag used to identify a record xml block
     */
    public String getRecordTag() {
		return recordTag;
	}

    /**
     * 
     * @param recordTag The tag used to identify a record xml block
     */
    @UserConfigured(value = "", description = "The tag used to identify a record xml block", 
    		flexValidator = { "StringValidator minLength=1 maxLength=65" })
	public void setRecordTag(String recordTag) {
		this.recordTag = recordTag;
	}

	/**
	 * @return The tag used to identify a header xml block
	 */
	public String getHeaderTag() {
		return headerTag;
	}

	/**
	 * 
	 * @param headerTag The tag used to identify a header xml block
	 */
	@UserConfigured(value = "", description = "The tag used to identify a header xml block", 
    		flexValidator = { "StringValidator minLength=1 maxLength=65" })
	public void setHeaderTag(String headerTag) {
		this.headerTag = headerTag;
	}

    
    /**
     * Set the Unmarshaller to be used when parsing into a bean.
     * 
     * @param unm
     * 			the Unmarshaller to be used when parsing into a bean
     */
    public final void setUnmarshaller(Unmarshaller unm) {
        this.unmarshaller = unm;
    }

    /**
     * Gets the Unmarshaller that is used when parsing into a bean.
     * 
     * @return the Unmarshaller that is used when parsing into a bean
     */
    public final Unmarshaller getUnmarshaller() {
        return this.unmarshaller;
    }

    /**
     * Reads the next xml block of input that contains a full logical record.
     * New reads on the input stream are done only if the buffer is empty or
     * contains an incomplete record. The buffer size is fixed and is expected
     * hold at least one record. If the buffer fills and a complete record
     * cannot be found, an error is logged and the buffer is doubled in size
     * once. If it happens again, the assumption is made that the caller
     * specified and invalid tag which may not exist in the input data.
     * 
     * @param startTag
     * 			start tag to look for
     * @param endTag
     * 			end tag to look for
     * 
     * @return the data between the given start tag and end tag inclusive.
     */
    private String nextTagSegment(char[] startTag, char[] endTag) throws ParsePipelineException {

        try {
            String record = null;
            if (malformedXML == true) {
            	// the previous call caused a PipelineExcption, return null to tell the pipeline to 
            	// move on to the next stream
            	malformedXML = false;
            	if (buffer.length != INITIAL_BUFFER_SIZE) {
                	buffer = new char[INITIAL_BUFFER_SIZE];
                }
            	return null;
            }
            boolean partialRecordFound = false;
            // With the INITIAL_BUFFER_SIZE set at 512K, 20 extensions gets us to a max buffer size of 10MB
            // (each extension adds an additional 512K to the buffer)
            int maxBufferExtensions = 20;
            int bufferExtendedCount = 0;
            int start = 0;
            do {
                if (limit == 0 || partialRecordFound) {
                    if (limit >= buffer.length) {
                        // Buffer is full and a complete record has not been found.
                        if (bufferExtendedCount < maxBufferExtensions) {
                        	bufferExtendedCount++;
                        	log.info("Buffer is too small for record; extending buffer. Times extended:" + bufferExtendedCount);
                            char[] newBuf = new char[buffer.length + INITIAL_BUFFER_SIZE];
                            System.arraycopy(buffer, 0, newBuf, 0, buffer.length);
                            buffer = newBuf;
                        // Buffer has need extended and a complete record is still not
                        // found. The xml is probably malformed.
                        } else {
                        	if (limit > MAX_DLQ_MSG_SIZE)
                				limit = MAX_DLQ_MSG_SIZE;
                        	currentRecord = new String(buffer, start, limit) + "...";
                    		limit = 0;
                            buffer = new char[INITIAL_BUFFER_SIZE];
                            malformedXML = true;
                            throw new ParsePipelineException("Malformed XML; missing closing record tag: " + new String(endTag));
                        }
                    }
                    int count = stream.read(buffer, limit, buffer.length - limit);
                    if (count == -1) {
                    	if (limit > 0) {
                    		// we have data in the buffer, but have reached the end of the stream
                    		if (start == -1) {
                    			// no start tag found, could just be the ending header tag
                    			// no great way to check for this (header tag can be left null) 
                    			// single line assume ending header tag, otherwise throw exception
                    			if (limit > MAX_DLQ_MSG_SIZE)
                    				limit = MAX_DLQ_MSG_SIZE;
                    			currentRecord = new String(buffer, 0, limit) + "...";
                    			int lines = currentRecord.split(LINE_SEPARATOR).length - 1;
                    			if (lines > 1) {
                    				malformedXML = true;
                    				throw new ParsePipelineException("Malformed XML; missing starting record tag: " + new String(startTag));
                    			}
                    		} else {
                    			// start tag was found but no end tag found by the end of the stream
                    			if (limit > MAX_DLQ_MSG_SIZE)
                    				limit = MAX_DLQ_MSG_SIZE;
                    			currentRecord = new String(buffer, start, limit) + "...";
                    			malformedXML = true;
                    			throw new ParsePipelineException("Malformed XML; missing closing record tag: " + new String(endTag));
                    		}
                    	}
                    	limit = 0;
                    	if (buffer.length != INITIAL_BUFFER_SIZE) {
                        	buffer = new char[INITIAL_BUFFER_SIZE];
                        }
                        return null;
                    }
                    limit += count;
                    partialRecordFound = false;
                }

                start = find(buffer, 0, limit, startTag);
                if (start == -1) {
                	partialRecordFound = true;
                    continue;
                }
                int end = find(buffer, start, limit, endTag);
                if (end == -1) {
                    partialRecordFound = true;
                    continue;
                }
                end = end + endTag.length;
                record = new String(buffer, start, end - start);
                limit = compact(buffer, end, limit);

            } while (partialRecordFound);
            
            log.debug(record);
            if (buffer.length != INITIAL_BUFFER_SIZE) {
            	buffer = new char[INITIAL_BUFFER_SIZE];
            }
            return record;
            
        } catch (IOException e) {
            limit = 0;
            if (buffer.length != INITIAL_BUFFER_SIZE) {
            	buffer = new char[INITIAL_BUFFER_SIZE];
            }
            return null;
        }
    }

    /**
     * Returns the next record.
     * 
     * @return the next record
     */
    protected final String nextRecord() throws ParsePipelineException {
        String record = nextTagSegment(START_TAG, END_TAG);
        if (record != null)
        	currentRecord = record;
    	return record;
    }

    /**
     * Returns the next header.
     * 
     * @return the next header
     */
    protected final String nextHeader() throws ParsePipelineException {
        return nextTagSegment(HEADER_START_TAG, HEADER_END_TAG);
    }

    /**
     * Reads the next record from the input source and converts it to the given
     * bean type.
     * 
     * @param type
     * 			the type of bean to convert the record into
     * 
     * @return the next record converted into the given bean type
     */
    @SuppressWarnings("unchecked")
    protected final <T> T nextRecordAsBean(Class<T> type) throws ParsePipelineException {
        try {
        	String record = nextRecord();
        	if (record == null) return null;
            if (unmarshaller != null) {
                unmarshaller.setClass(type);
                return (T) unmarshaller.unmarshal(new StringReader(record));
            } else {
                return (T) Unmarshaller.unmarshal(type, new StringReader(record));
            }
        } catch (MarshalException e) {
            log.error("Unable to unmarshall record from xml: " + e.getMessage());
            return null;
        } catch (ValidationException e) {
            log.error("Unable to unmarshall record from xml: " + e.getMessage());
            return null;
        }
    }

    /**
     * Reads the next header from the input source and converts it to the given
     * bean type.
     * 
     * @param type
     * 			the type of bean to convert the header into
     * 
     * @return the next header converted into the given bean type
     */
    @SuppressWarnings("unchecked")
    protected final <T> T nextHeaderAsBean(Class<T> type) throws ParsePipelineException {
        try {
        	String header = nextHeader();
        	if (header == null) return null;
            if (unmarshaller != null) {
                unmarshaller.setClass(type);
                return (T) unmarshaller.unmarshal(new StringReader(header));
            } else {
                return (T) Unmarshaller.unmarshal(type, new StringReader(header));
            }
        } catch (MarshalException e) {
            log.error("Unable to unmarshall header from xml: " + e.getMessage());
            return null;
        } catch (ValidationException e) {
            log.error("Unable to unmarshall header from xml: " + e.getMessage());
            return null;
        }
    }

    /**
     * Reads the next record from the input source and converts it to an XML DOM
     * object.
     * 
     * @return the next record as a Document
     */
    public final Document nextRecordAsDocument() throws SAXException, ParsePipelineException {
        try {
        	initialize();
        	String record = nextRecord();
    		if (record == null) return null;
        	byte[] bytes = record.getBytes("UTF-8");
            ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
            return xmlBuilder.parse(stream);
        } catch (IOException e) {
            log.error("Error reading data from source.", e);
            return null;
        } catch (ValidationException e) {
        	log.error(e.getMessage(),e);
        	return null;
		}
    }

    /**
     * Reads the next header from the input source and converts it to an XML DOM
     * object.
     * 
     * @return the next header as a Document
     */
    protected final Document nextHeaderAsDocument() throws SAXException, ParsePipelineException {
        try {
        	initialize();
        	String header = nextHeader();
    		if (header == null) return null;
        	byte[] bytes = header.getBytes("UTF-8");
            ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
            return xmlBuilder.parse(stream);
        } catch (IOException e) {
            log.error("Error reading header data from source.", e);
            return null;
        } catch (ValidationException e) {
        	log.error(e.getMessage(),e);
        	return null;
		}
    }

    /**
     * Reads the next record from the input source and converts it to an XML JDOM object.
     * @return JDOM document
     * @throws EndOfDataCondition the input source could not be read
     * @throws JDOMException JDOM could not parse the record
     */
    protected final org.jdom.Document nextRecordAsJdomDocument() throws JDOMException, ParsePipelineException
    {
    	try
    	{
    		initialize();
    		String record = nextRecord();
    		if (record == null) return null;
    		byte[] bytes = record.getBytes("UTF-8");
    		ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
    		return jdomBuilder.build(stream);
    	}
    	catch(IOException e)
    	{
            log.error("Error reading data from source.", e);
    		return null;
    	} catch (ValidationException e) {
        	log.error(e.getMessage(),e);
        	return null;
		}
    }
    
    
    /**
     * Reads the next header from the input source and converts it to an XML JDOM object.
     * @return JDOM document
     * @throws EndOfDataCondition the input source could not be read
     * @throws JDOMException JDOM could not parse the record
     */
    protected final org.jdom.Document nextHeaderAsJdomDocument() throws JDOMException, ParsePipelineException
    {
    	try
    	{
    		initialize();
    		String header = nextHeader();
    		if (header == null) return null;
    		byte[] bytes = header.getBytes("UTF-8");
    		ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
    		return jdomBuilder.build(stream);
    	}
    	catch(IOException e)
    	{
            log.error("Error reading header data from source.", e);
    		return null;
    	} catch (ValidationException e) {
        	log.error(e.getMessage(),e);
        	return null;
		}
    }
    
    /**
     * Reads the next record from the input source and creates a map of tag/value pairs.
     * 
     * @return a map of tag/value pairs for the next record
     */
    protected final Map<String, String> nextRecordAsMap() throws SAXException, ParsePipelineException {
        Document xml = nextRecordAsDocument();
        if (xml == null) return null;
        Map<String, String> map = new LinkedHashMap<String, String>();
        map(xml.getFirstChild(), "/", map);
        return map;
    }

    /**
     * Reads the next header from the input source and creates a map of
     * tag/value pairs.
     * 
     * @return a map of tag/values pairs for the next header
     */
    protected final Map<String, String> nextHeaderAsMap() throws SAXException, ParsePipelineException {
        Document xml = nextHeaderAsDocument();
        if (xml == null) return null;
        Map<String, String> map = new LinkedHashMap<String, String>();
        map(xml.getFirstChild(), "/", map);
        return map;
    }

    /**
     * Determines the position of the first occurrence of the given character
     * pattern.
     * 
     * @param buffer The buffer to search.
     * @param limit The position to start searching from.
     * @param pattern The character pattern to look for.
     * 
     * @return The index of the first occurrence.
     */
    private static int find(char[] buffer, int start, int limit, char[] pattern) {

        // Determine if tag is an end tag.
        final boolean endTag = ((pattern[0] == '<') && (pattern[1] == '/'));

        // Adjust the limit to prevent comparisons from overrunning buffer.
        limit = limit - pattern.length + 1;

        // Scan the buffer, from start to end.
        for (int i = start; i < limit; i++) {
            // Compare contents at current position to search pattern.
            for (int j = 0; j < pattern.length; j++) {
                // If this character matches...
                if (buffer[i + j] == pattern[j]) {
                    // And this is the end of the pattern...
                    if (j == pattern.length - 1) {
                        /*
                         * Then the whole pattern matches.
                         * 
                         * return index if pattern is an end tag. Or if pattern
                         * is a start tag and a whitespace or a '>' follows the
                         * start tag.
                         */
                        final char c = buffer[i + j + 1];
                        if (endTag || (Character.isWhitespace(c) || (c == '>'))) {
                            return i;
                        }

                        i += j;
                        break;
                        // Otherwise, continue comparing the pattern.
                    } else {
                        continue;
                    }
                    // If this character does not match, keep searching.
                } else {
                    break;
                }
            }
        }

        // No match was found.
        return -1;

    }

    /**
     * This function will parse the input XML file and search for the root XML tag and the record XML tag.  The first XML element will 
     * be the root tag and the second element tag will be the record tag.  There should be only one root tag and as many record tags
     * as needed. The root tag will be placed in the HEADER_START_TAG and the HEADER_END_TAG.  The record tag will be placed in the 
     * START_TAG and the END_TAG. This method will be called from the AbstractXMLParser(File file) constructor, but it can be called
     * independently if the XML File variable is set.
     * 
     * This will only do something useful if we are actually parsing a file and the record tag has not already been set.
     */
    public void parseHeaders() {
		try {
			if (xmlFile != null && START_TAG == null) {
				DocumentBuilder headerReader = DocumentBuilderFactory.newInstance().newDocumentBuilder();
				StringReader inputReader = new StringReader(FileUtils.readFileToString(xmlFile));
				InputSource is = new InputSource(inputReader);
				Document doc = headerReader.parse(is);
				Element e = doc.getDocumentElement();
				String rootHeader = e.getNodeName();
				createHeaderTag(rootHeader);

				NodeList nl= e.getChildNodes();
				Node node = null;
				for(int i=0; i < nl.getLength(); i++)
				{
					Node n = nl.item(i);
					if (n.getNodeType() == Node.ELEMENT_NODE)
					{
						node = n;
						break;
					}
				}

				String recordHeader = node.getNodeName();
				createRecordTag(recordHeader);
			}
		 } catch(IOException ioe) {
			 log.error("Input Output Error: " + ioe.getMessage());
		 } catch (Exception ex) {
			log.error("Error: " + ex.getMessage());
		 }
	}
    
    /**
     * Moves the contents of the given buffer, up the the beginning of the
     * buffer.
     * 
     * @param buffer The buffer to compact.
     * @param start The starting position from which to move characters.
     * @param limit The ending position from which to move characters.
     * 
     * @return The new end of the buffer's logical contents.
     */
    private static int compact(char[] buffer, int start, int limit) {
        int count = limit - start;
        System.arraycopy(buffer, start, buffer, 0, count);
        Arrays.fill(buffer, count, buffer.length, '\0');
        return count;
    }

    /**
     * Converts an xml dom tree into a map of tag/value pairs. Each tag is a
     * fully qualified path string composed of the xml element tags from the
     * document root to each cdata or text element. In each path, elements are
     * seperated by slahes, attributes are delimited by an point, and sequences
     * are suffixed by their index in brackets.
     * 
     * @param node The starting point of the recursive traversal.
     * @param path The path up to this element's parent.
     * @param map The map to add new tag/values too.
     */
    private static void map(Node node, String path, Map<String, String> map) {

        short type = node.getNodeType();
        String name = node.getNodeName();
        String value = node.getNodeValue();

        // If this element is an internal node (i.e. contains other tags), recurse.
        if (type == Node.ELEMENT_NODE || type == Node.ATTRIBUTE_NODE) {

            // Build it's path string..
            int index = index(node);
            if (index == -1) {
                path = path + name;
            } else if (index == 0) {
                map.put(path + name + "#", String.valueOf(count(node)));
                path = path + name + "[0]";
            } else {
                path = path + name + "[" + index + "]";
            }

            // Iterate over any attributes.
            if (node.hasAttributes()) {
                NamedNodeMap list = node.getAttributes();
                for (int i = 0; i < list.getLength(); i++) {
                    map(list.item(i), path + "@", map);
                }
            }

            // Iterate over any children.
            if (node.hasChildNodes()) {
                Node child = node.getFirstChild();
                while (child != null) {
                    map(child, path + "/", map);
                    child = child.getNextSibling();
                }
            }

            // If this is a leaf node (i.e. contains a value), add it to the map.
        } else if (type == Node.TEXT_NODE || type == Node.CDATA_SECTION_NODE) {

            map.put(path.substring(0, path.length() - 1), value.trim());

        }

    }

    /**
     * Determine the sequence index of this element. If this element is not a
     * memeber of a sequence, returns -1; otherwise, returns the ordinal index.
     * 
     * @param node
     * 			the element for which we want the sequence index
     * @return the sequence index of the element
     */
    protected static int index(Node node) {

        // Make sure this is a named xml element.
        String name = node.getNodeName();
        if (name == null) {
            return -1;
        }

        // Count the number of left siblings with the same name.
        int index = 0;
        Node left = node.getPreviousSibling();
        while (left != null) {
            if (name.equals(left.getNodeName())) {
                index++;
            }
            left = left.getPreviousSibling();
        }

        // If there are any, then this element is a sequence, return it's index;
        if (index > 0) {
            return index;
        }

        // Otherwise, check if this is the first element in a sequence.
        Node right = node.getNextSibling();
        while (right != null) {
            if (name.equals(right.getNodeName())) {
                return 0;
            }
            right = right.getNextSibling();
        }

        // If this element is not a sequence, it has no index.
        return -1;

    }

    /**
     * Determines the number of elements in a sequence starting with the given
     * node.
     * 
     * @param node
     * 			the node used to compare with the start of a sequence
     * 
     * @return the number of elements in a sequence starting with the given node
     */
    private static int count(Node node) {
        int count = 0;
        String name = node.getNodeName();
        while (node != null) {
            if (name.equals(node.getNodeName())) {
                count++;
            }
            node = node.getNextSibling();
        }
        return count;
    }
    
    /**
     * Attempt to determine the stream encoding and open an appropriate reader.
     * 
     * @param stream
     * 			the stream to determine the encoding of
     * 
     * @return an appropriate reader for the stream based on its encoding
     */
    private static Reader reader(PushbackInputStream stream) throws IOException {

        String encoding = "UTF-8";
        byte[] buffer = new byte[PUSHBACK_SIZE];
        int count = stream.read(buffer);

        if (count > 0) {
            // If the stream contains an xml encoding tag...
            if (buffer.length > 2 && buffer[0] == '<' && buffer[1] == '?' && buffer[2] == 'x') {

                // Scan the buffer for the closing bracket.
                for (int i = 0; i < count; i++) {

                    if (buffer[i] == '>') {

                        // Go one past the closing bracket.
                        i++;

                        // Extract the encoding attribute.
                        String declaration = new String(buffer, 0, i);

                        // Push back any extra bytes.
                        stream.unread(buffer, i, count - i);

                        // Get the encoding.
                        Pattern pattern = Pattern.compile("encoding=['\"]([-\\w]+)['\"]");
                        Matcher matcher = pattern.matcher(declaration);
                        if (matcher.find()) {
                            encoding = matcher.group(1);
                        }

                        // Stop scanning for the end tag.
                        break;

                    }
                }

            } else {
                // Through everything back up because it does not contain a
                // valid XML Header - put back in the buffer.
                stream.unread(buffer, 0, count);
            }
        }

        // Return the appropriate reader.
        try {
            return new InputStreamReader(stream, encoding);
        } catch (UnsupportedEncodingException e) {
            throw new IOException(e.getMessage());
        }

    }
}
