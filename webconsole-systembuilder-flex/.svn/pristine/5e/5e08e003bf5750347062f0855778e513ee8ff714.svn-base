/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.systemcfg.models
{
	import com.deleidos.rtws.commons.model.auth.IUser;
	import com.deleidos.rtws.commons.model.status.StatusMessage;
	import com.deleidos.rtws.commons.model.status.StatusType;
	import com.deleidos.rtws.commons.util.StringUtils;
	import com.deleidos.rtws.systemcfg.dao.DatasinkConfig;
	import com.deleidos.rtws.systemcfg.dao.ProcessGroupConfig;
	import com.deleidos.rtws.systemcfg.dao.SystemSizing;
	import com.deleidos.rtws.systemcfg.dao.WebappConfig;
	import com.deleidos.rtws.systemcfg.events.PopupEvent;
	
	import mx.collections.ArrayCollection;
	import mx.collections.Sort;
	import mx.collections.SortField;
	
	import org.robotlegs.mvcs.Actor;

	public class ProcessGroupModel extends Actor
	{
		[Inject] public var processGroupConfigTable:ProcessGroupConfig;
		[Inject] public var systemSizingTable:SystemSizing;
		[Inject] public var datasinkConfig:DatasinkConfig;
		[Inject] public var webappConfig:WebappConfig;
		[Inject] public var userModel:IUser;
		
		public static const PG_JMS_EXTERNAL :String = "jms.external";
		public static const PG_JMS_INTERNAL :String = "jms.internal";
		public static const WEBAPPS_DEFAULT :String = "webapps.main";
		public static const INGEST_ALL      :String = "ingest.all";
		public static const TRANSPORT       :String = "transport";
		
		private var _processGroups:ArrayCollection;
		
		public function ProcessGroupModel()
		{
			_processGroups = new ArrayCollection();
			var sort:Sort = new Sort();
			sort.compareFunction = compareProcessGroups;
			_processGroups.sort = sort;
		}

		/** Adjust the name so the process groups are ordered properly */
		private function adjustName(pg:ProcessGroup):String {
			var result:String = pg.processGroupName;
			
			if (pg.processGroupName == PG_JMS_EXTERNAL) {
				result = "A" + result;
			}
			else if (pg.processGroupName == PG_JMS_INTERNAL) {
				result = "B" + result;
			}
			else if (pg.processGroupType == ProcessGroupTypes.WEBAPPS) {
				result = "D" + result;
			}
			else if (pg.processGroupType == ProcessGroupTypes.INGEST) {
				result = "X" + result;			
			}
			else if (pg.processGroupType == ProcessGroupTypes.CUSTOM) {
				result = "Y" + result;
			}
			else if (pg.processGroupType == ProcessGroupTypes.TRANSPORT) {
				result = "Z" + result;				
			}
			else if (pg.processGroupType == ProcessGroupTypes.DATASINK) {
				result = "C" + pg.indexString + result;
			}
			else {
				result = "E" + result;
			}
			
			return result;
		}
		/*
		-1, if the Object a should appear before the Object b in the sorted sequence
		0, if the Object a equals the Object b
		1, if the Object a should appear after the Object b in the sorted sequence
		*/

		private function compareProcessGroups(a:Object, b:Object, fields:Array = null):int
		{
			var pgA:ProcessGroup = a as ProcessGroup;
			var pgB:ProcessGroup = b as ProcessGroup;
			var result:int = 0;

			var pgAname:String = adjustName(pgA);
			var pgBname:String = adjustName(pgB);

			result = pgAname.localeCompare(pgBname);
			result = Math.max(result, -1);
			result = Math.min(result, 1);
			
			// trace("a=" + pgAname + ", b=" + pgBname + ", result=" + result);
			
			return result;
			
		}		
		
		public function get processGroups():ArrayCollection {
			return _processGroups;
		}
		
		public function clear():void {
			_processGroups.removeAll();
		}
		
		public function findProcessGroup(processGroupName:String):ProcessGroup {
			for each (var pg:ProcessGroup in _processGroups) {
				if (processGroupName == pg.processGroupName) {
					return (pg);
				}
			}
			return (null);
		}
		
		public function findProcessGroupsWithPersistentIP():Array {
			var result:Array = new Array();
			for each (var pg:ProcessGroup in _processGroups) {
				if (pg.persistentIPAddress != ProcessGroup.NO_PUBLIC_IP) {
					result.push(pg);
				}
			}			
			return result;
		}
		
		public function processGroupExists(processGroupName:String):Boolean {
			return (findProcessGroup(processGroupName) != null);
		}
		
		private function ensureMultiple(value:int, multiple:int):int {
			return (Math.floor((value-1)/multiple)+1)*multiple;
		}
		
		private function computeScalingParameters(pg:ProcessGroup, systemSize:String, autoScale:Boolean):void {
			var sizingData:Object = systemSizingTable.lookupBySystemSize(systemSize);
			if (pg.processGroupType == ProcessGroupTypes.JMS) {
				// JMS Instances have  fixed sizes based on the selected size and no autoscaling 
				pg.minCount = sizingData[SystemSizing.JMS_INSTANCE_COUNT];
				pg.maxCount = sizingData[SystemSizing.JMS_INSTANCE_COUNT];
				pg.instanceSize = sizingData[SystemSizing.JMS_INSTANCE_TYPE];
				pg.allocationLimit = 0;
				pg.deallocationLimit = 0;			
			}
			else if (pg.scaling) {
				var dsConfig:Object = datasinkConfig.lookupByProcessGroupname(pg.processGroupName);
				var base_min:int = parseInt(sizingData[SystemSizing.BASE_MIN]);
				base_min = Math.max(base_min, pg.defaultNumInstances);
				var jms_count:int = parseInt(sizingData[SystemSizing.JMS_INSTANCE_COUNT]);
				pg.minCount = ensureMultiple(base_min, jms_count); // Min count needs to be a multiple of the jms count
				pg.deallocationLimit = parseInt(sizingData[SystemSizing.BASE_DEALLOC]);
				if (pg.processGroupType == ProcessGroupTypes.DATASINK) {
					// Datasinks that store data using local block storage cannot be deallocated
					if ((dsConfig != null) && (dsConfig[DatasinkConfig.USES_BLOCK_STORAGE].toLowerCase() == "y")) {
						pg.deallocationLimit = 0;
					}
				}
				
				pg.maxCount = parseInt(sizingData[SystemSizing.BASE_MAX]);
				pg.maxCount = Math.max(pg.maxCount, pg.defaultNumInstances);
				var allocLimit:int = parseInt(sizingData[SystemSizing.BASE_ALLOC]);
				pg.allocationLimit = ensureMultiple(allocLimit, jms_count); // Needs to be a multiple of the jms count
				if ((dsConfig != null) && (pg.processGroupType == ProcessGroupTypes.DATASINK)) {
					// Incorporate the scale up factor for data sinks for max and allocation values
					var scaleUpFactor:Number = parseFloat(dsConfig[DatasinkConfig.SCALE_UP_FACTOR]);  
					pg.maxCount = Math.max(1, (pg.maxCount * scaleUpFactor));
					allocLimit = Math.max(1, (pg.allocationLimit * scaleUpFactor));
					pg.allocationLimit = ensureMultiple(allocLimit, jms_count); // Needs to be a multiple of the jms count
				}
			} 
			else if (pg.linearScale) { // check for linear scale of with system size after autoscale
				var base_min:int = parseInt(sizingData[SystemSizing.BASE_MIN]);
				// quick and dirty fix , will need to change this when adding more than just zoo keeper
				// zoo keeper is only suposed to be odd
				if ((base_min == 6) && pg.odd) {
					base_min = 5;
				}
				
				base_min = Math.max(base_min, pg.defaultNumInstances);
				pg.minCount = base_min;
				pg.maxCount = base_min;
			}
			else {
				pg.minCount = pg.defaultNumInstances;
				pg.maxCount = pg.defaultNumInstances;
				pg.allocationLimit = 0;
				pg.deallocationLimit = 0;
			}
		}
		
		private function isOdd(value:int):Boolean {
			if ((value % 2) == 1) {
				return true;
			}
			return false;
		}
		
		public function validate():Boolean {
			var errMsg:String = "";

			for each (var pg:ProcessGroup in _processGroups) {
				
				// check if either the min or max value is not odd and the odd flag is on
				if (pg.odd && (!isOdd(pg.maxCount) || !isOdd(pg.minCount))) {
					if(errMsg.length > 0) {
						errMsg += "\n"
					}
					errMsg += "Min and Max values must be odd for process group: " + pg.processGroupName;
				}
				
				// validate minCount <= maxCount
				if (pg.minCount > pg.maxCount)
				{
					if(errMsg.length > 0) {
						errMsg += "\n"
					}
					errMsg += "Min value must be less than Max value for process group: " + pg.processGroupName;
				}
				
				// validate volumeSize depending on volumeCount
				if(pg.volumeCount > 0)
				{
					// there are volumes, enforce a minimum volume size of 5
					if(pg.volumeSize < 5)
					{
						if(errMsg.length > 0) {
							errMsg += "\n"
						}
						errMsg += "Volumes are configured, volume size must be at least 5 for process group: " + pg.processGroupName;
					}
				}
				else
				{
					// there are no volumes, enforce a volume size of 0
					if(pg.volumeSize != 0)
					{
						if(errMsg.length > 0) {
							errMsg += "\n"
						}
						errMsg += "No volumes are configured, volume size must be 0 for process group: " + pg.processGroupName;
					}
				}
			}
			
			if(errMsg.length > 0)
			{
				var msg:StatusMessage = new StatusMessage(StatusType.ERROR,errMsg);
				dispatch(new PopupEvent(PopupEvent.MESSAGE_BEGIN, msg, null));
				return false;
			}
			
			return true;
		}
		
		private function computeLinearScalingParameters(pg:ProcessGroup, systemSize:String):void {
			var sizingData:Object = systemSizingTable.lookupBySystemSize(systemSize);

			// currently only zoo keeper will have this flag. Add to other process groups in the future
			if ((pg.linearScale) && (!pg.scaling)) {
				var base_min:int = parseInt(sizingData[SystemSizing.BASE_MIN]);
				// quick and dirty fix , will need to change this when adding more than just zoo keeper
				// zoo keeper is only suposed to be odd
				if ((base_min == 6) && pg.odd) {
					base_min = 5;
				}
				
				base_min = Math.max(base_min, pg.defaultNumInstances);
				// Use this as example for linear Databases later..
				//var jms_count:int = parseInt(sizingData[SystemSizing.JMS_INSTANCE_COUNT]);
				//pg.minCount = ensureMultiple(base_min, jms_count); // Min count needs to be a multiple of the jms count
				//pg.maxCount = ensureMultiple(base_min, jms_count); // set Max count equal to min for default
				
				pg.minCount = base_min;
				pg.maxCount = base_min;
			}
		}
		
		public function warnUserAboutSize(systemSize:String, autoScale:Boolean, dataSinkExists:Boolean):void {
			if (!autoScale && 
				dataSinkExists &&
				(systemSize == "large" || systemSize == "xlarge" || systemSize == "xxlarge")) 
			{
				var msg:StatusMessage =
					new StatusMessage(
						StatusType.WARN,
						"Autoscaling is not in use. Make sure to increase the Ingest, Transport and " +
						"DataSink instance count to get max throughput");
				
				dispatch(new PopupEvent(PopupEvent.MESSAGE_BEGIN, msg, null));	
				
				// TODO add a call to highlight the min / max values in yellow for process groups
			}
			
		}
		
		public function setupJMS(systemSize:String, alwaysAdd:Boolean):void {
			var systemSizingData:Object = systemSizingTable.lookupBySystemSize(systemSize);
			
			var jmsExtPresent:Boolean = processGroupExists(PG_JMS_EXTERNAL);
			removeProcessGroup(PG_JMS_EXTERNAL);				
			removeProcessGroup(PG_JMS_INTERNAL);
			
			if (jmsExtPresent || alwaysAdd) {
				addProcessGroup(PG_JMS_EXTERNAL, ProcessGroupTypes.JMS, systemSize, false);
				if (systemSizingData[SystemSizing.COMBINE_INT_EXT_JMS_FLAG] != "Y") {
					addProcessGroup(PG_JMS_INTERNAL, ProcessGroupTypes.JMS, systemSize, false);				
				}
			}
		}
		
		public function adjustSystemSize(systemSize:String, autoScale:Boolean):void {
			var systemSizingData:Object = systemSizingTable.lookupBySystemSize(systemSize);
			if (systemSizingData == null) {
				throw new Error("ProcessGroupModel.adjustSystemSize: '" + systemSize + "' is not a valid size.");
			}

			setupJMS(systemSize, false);
			
			/*
			removeProcessGroup(PG_JMS_EXTERNAL);				
			removeProcessGroup(PG_JMS_INTERNAL);

			addProcessGroup(PG_JMS_EXTERNAL, ProcessGroupTypes.JMS, systemSize, false);
			if (systemSizingData[SystemSizing.COMBINE_INT_EXT_JMS_FLAG] != "Y") {
				addProcessGroup(PG_JMS_INTERNAL, ProcessGroupTypes.JMS, systemSize, false);				
			}
			*/
			
			var dataSinkExists:Boolean = false;
						
			for each (var pg:ProcessGroup in _processGroups) {
				computeScalingParameters(pg, systemSize, autoScale);

				if (pg.processGroupType != ProcessGroupTypes.JMS) {
					var config:Object = processGroupConfigTable.lookupByProcessGroupName(pg.processGroupName);
					pg.instanceSize = getSystemSize(pg.processGroupType, systemSize, config);
					
					// if autoscale is off, still scale linearly with system size
					if (!autoScale) {
						computeLinearScalingParameters(pg, systemSize);
					}
				}
				
				if (pg.processGroupType == ProcessGroupTypes.DATASINK) {
					dataSinkExists = true;
				}
			}
			
			warnUserAboutSize(systemSize, autoScale, dataSinkExists);
		}
		
		public function addProcessGroupWithErrorPopup(processGroupName:String, processGroupType:String, systemSize:String, scaling:Boolean, index:int=1):void {
			var pg:ProcessGroup = addProcessGroup(processGroupName, processGroupType, systemSize, scaling, index);
			if (pg == null) {
				var msg:StatusMessage =
					new StatusMessage(
						StatusType.ERROR, "Cannot add process group. There is no configuration data for process group '" +
						processGroupName + "'");
				
				dispatch(new PopupEvent(PopupEvent.MESSAGE_BEGIN, msg, null));				
			}
		}
		
		// If the size matches the pattern x+small, make the instance the same size as the jms node (which is
		// expected to be m3.medium)
		private function getSystemSize(processGroupType:String, systemSize:String, config:Object):String {
			if ((processGroupType != ProcessGroupTypes.DATASINK) && (systemSize.match(/^x+small$/))) {
				var sizingData:Object = systemSizingTable.lookupBySystemSize(systemSize);
				return (sizingData[SystemSizing.JMS_INSTANCE_TYPE]);
			}
			else {
				return config[ProcessGroupConfig.DEFAULT_INSTANCE_TYPE];
			}
		}
		
		public function addProcessGroup(processGroupName:String, processGroupType:String, systemSize:String, scaling:Boolean, index:int=1):ProcessGroup {
			var config:Object = processGroupConfigTable.lookupByProcessGroupName(processGroupName);
			var pg:ProcessGroup = null;
			if (config != null) {
				var permissions:Object = config[ProcessGroupConfig.CONFIG_PERMISSIONS];
				pg = new ProcessGroup();
				pg.setConfigurationPermissions(permissions);
				pg.processGroupName = processGroupName;
				pg.processGroupType = processGroupType;
				pg.volumeCount = permissions[ProcessGroupConfig.DEFAULT_NUM_VOLUMES];
				pg.volumeSize  = permissions[ProcessGroupConfig.DEFAULT_VOLUME_SIZE];
				pg.persistentIPAddress = ProcessGroup.NO_PUBLIC_IP;
				pg.instanceSize = getSystemSize(processGroupType, systemSize, config); // config[ProcessGroupConfig.DEFAULT_INSTANCE_TYPE];				
				pg.scaling = scaling && permissions[ProcessGroupConfig.CONFIG_SCALING];
				pg.isTenantOwned = (config[ProcessGroupConfig.OWNER] == userModel.tenantId);
				pg.index = index;
				
				computeScalingParameters(pg, systemSize, scaling);
				
				// if autoscale is off, still scale linearly with system size
				if (!scaling) {
					computeLinearScalingParameters(pg, systemSize);
				}
				
				if (pg.processGroupName == "jms.external")
					pg.jmsPersistence = true;
				else
					pg.jmsPersistence = false;
				
				if (!processGroupExists(pg.processGroupName)) {
					_processGroups.addItem(pg);
					_processGroups.refresh();
				}
			}
			return (pg);
		}
		
		public function removeProcessGroup(processGroupName:String):void {
			var pg:ProcessGroup = findProcessGroup(processGroupName);
			if (pg != null) {
				var index:int =_processGroups.getItemIndex(pg);
				_processGroups.removeItemAt(index);				
				_processGroups.refresh();
			}
		}
		
		public function get transferObject():Array {
			var result:Array = new Array();
			for (var i:int=0; i<_processGroups.length; i++) {
				var pg:ProcessGroup = _processGroups.getItemAt(i) as ProcessGroup;
				var o:Object = new Object();
				// Copy the exact fields so the JSON is exact
				o.processGroupName = pg.processGroupName;
				o.volumeCount = pg.volumeCount;
				o.volumeSize  = pg.volumeSize;
				o.persistentIPAddress = pg.persistentIPAddress;
				o.instanceSize = pg.instanceSize;
				o.maxCount = pg.maxCount;
				o.minCount = pg.minCount;
				o.allocationLimit = pg.allocationLimit;
				o.deallocationLimit = pg.deallocationLimit;
				o.scaling = pg.scaling;
				o.jmsPersistence = pg.jmsPersistence;
				result.push(o);
			}
			return result;
		}
		
		private function computeProcessGroupType(processGroupName:String, config:Object):String {
			if (processGroupName == ProcessGroupTypes.MASTER)
				return ProcessGroupTypes.MASTER;
			else if (processGroupName == ProcessGroupTypes.TRANSPORT)
				return ProcessGroupTypes.TRANSPORT;
			else if (StringUtils.beginsWith(processGroupName,"jms"))
				return ProcessGroupTypes.JMS;
			else if ((StringUtils.beginsWith(processGroupName,"custom")) ||
					 (StringUtils.beginsWith(processGroupName,"arbitrary")))
				return ProcessGroupTypes.CUSTOM;
			else {
				var securityGroup:String = config[ProcessGroupConfig.SECURITY_GROUP];
				if (webappConfig.lookupByFqn(Webapp.FQN_PROCESS_GROUP_PREFIX + ":" + processGroupName) != null)
					return ProcessGroupTypes.CUSTOM;
				else if (StringUtils.beginsWith(securityGroup,"datasink"))
					return ProcessGroupTypes.DATASINK;
				else if (StringUtils.beginsWith(securityGroup,"webapp"))
					return ProcessGroupTypes.WEBAPPS;
				else {
					return ProcessGroupTypes.INGEST;
				}
			}
		}
		
		public function load(transferObject:Array):String {
			var errMsg:String = "";
			clear();
			for each (var o:Object in transferObject) {
				var processGroupName:String = o.processGroupName;
				var config:Object = processGroupConfigTable.lookupByProcessGroupName(processGroupName);
				if (config == null) {
					errMsg += "No information found for process group " + processGroupName + ". "  + "\n";					
				}
				else {
					var permissions:Object = config[ProcessGroupConfig.CONFIG_PERMISSIONS];
					var pg:ProcessGroup = new ProcessGroup();
					pg.setConfigurationPermissions(permissions);
					pg.processGroupName = processGroupName;
					pg.processGroupType = computeProcessGroupType(processGroupName, config);
					pg.volumeCount = o.volumeCount;
					pg.volumeSize = o.volumeSize;
					pg.persistentIPAddress = o.persistentIPAddress;
					pg.instanceSize = o.instanceSize;
					pg.maxCount = o.maxCount;
					pg.minCount = o.minCount;
					pg.allocationLimit = o.allocationLimit;
					pg.deallocationLimit = o.deallocationLimit;
					pg.scaling = o.scaling;
					pg.jmsPersistence = o.jmsPersistence;
					pg.isTenantOwned = (config[ProcessGroupConfig.OWNER] == userModel.tenantId);
					
					if (o.odd != null) {
						pg.odd = o.odd;
					}
					if (o.linearScale != null) {
						pg.linearScale = o.linearScale;
					}
					if (!processGroupExists(pg.processGroupName)) {
						_processGroups.addItem(pg);
					}
				}
			}
			_processGroups.refresh();
			return errMsg;
		}
		
		public function setAutoscaleAll(on:Boolean, systemSize:String, autoScale:Boolean):void {
			var totalDatasinks:int = 0;
			var totalDatasinksScaled:int = 0;

			for each (var pg:ProcessGroup in _processGroups) {
				if (pg.processGroupType == ProcessGroupTypes.DATASINK) {
					totalDatasinks++;					
				}
				if (pg.scalingConfigurable) {
					pg.scaling = on;
					if (pg.processGroupType == ProcessGroupTypes.DATASINK) {
						totalDatasinksScaled++;
					}					
				}
				computeScalingParameters(pg, systemSize, autoScale); 
			}
			
			_processGroups.refresh();
			
			if (on && (totalDatasinks != totalDatasinksScaled)) {
				var msg:StatusMessage =
					new StatusMessage(
						StatusType.WARN,
						"Not all configured data sinks are capable of auto-scaling. This may cause performance problems during runtime.");
				
				dispatch(new PopupEvent(PopupEvent.MESSAGE_BEGIN, msg, null));				
			}
		}
	}
}
