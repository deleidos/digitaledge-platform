/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.leidos.de.DTUgui;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.jms.TextMessage;


import javax.swing.JDialog;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Toolkit;
import org.apache.log4j.Logger;

import javax.jms.JMSException;
import javax.swing.JFrame;
import javax.swing.JTabbedPane;
import java.awt.BorderLayout;

import javax.swing.BorderFactory;
import javax.swing.DefaultCellEditor;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JButton;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.SpringLayout;
import javax.swing.SwingUtilities;

import java.sql.Date;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Vector;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.UIManager;
import javax.swing.JSeparator;
import javax.swing.JTable;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.URL;

import javax.swing.JTextField;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JProgressBar;
import javax.swing.JLabel;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableModel;
import javax.swing.text.html.HTMLDocument.Iterator;
import javax.swing.JScrollBar;
import javax.swing.JTextPane;
import javax.swing.JTextArea;
import javax.swing.border.BevelBorder;
import javax.swing.border.Border;
import javax.swing.border.SoftBevelBorder;
import javax.swing.border.TitledBorder;
import javax.swing.border.LineBorder;
import javax.swing.JList;

import com.deleidos.rtws.splitter.SplitterFactory;
import com.leidos.de.DTU.JMSUploader;
import com.leidos.de.DTU.UploadStatus;

import java.io.IOException;
import org.apache.log4j.Appender;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.w3c.dom.Document;

public class DTUelements {

    private static String[] types = SplitterFactory.getSplitterTypes();
    private static JTextField textField_1;
    private static JTextField textField_7;
    private static JTextField textField_8;
    private static JTextField textProgress;
    private static JTextField textProgressB;
    // private static JTextField textField_9;
    final static JPopupMenu popupMenu = new JPopupMenu();
    private static JTable tableDataFiles;
    private static JTable tableTargetHosts;
    private static Integer dataValuesSizeDataFiles = 0;
    private static Integer dataValuesSizeTargets = 0;
    private static Integer SystemCounter = null;
    private static String dataValues5[][];
    private static ArrayList<String> dataArrayList = new ArrayList<String>();
    private static HashMap<String, String> stateHM = new HashMap<String, String>();
    private static JTable tableB = new JTable();
    // private final JComboBox cBoxKeystore = new JComboBox();
    // private static JTextArea logArea = null;
    private static JTextPane logArea = null;
    private static JTextPane logAreaDLQ = null;
    static boolean workingTab = false;
    static boolean workingTabLastState = false;
    static JTabbedPane tabbedPaneLocalRef = null;
    static ImageIcon spinIcon = null;
    // public static final Logger log = Logger.getLogger(DTUelements.class);
    public static HashMap<String, Object> uploadProcs = new HashMap<String, Object>();
    public static String DTUSessionID = new String();
    public static String SessionTabID = new String();
    public static Integer SessionNumber = new Integer(0);
    public static org.apache.log4j.Logger logger;
    public static boolean restore = false;
    public static String keyStoreLocation = null;
    public static String trustStoreLocation = null;
    public static Boolean stopProcessing = false;
    public volatile Boolean stopProcessingB = false;
    public volatile UploadProc ulp = null;
    public  JButton btnUpload = null;
    public  JButton btnTest = null;

    //DTUelements dtueRef = new DTUelements();
    //	DTUmain dtuMainRef = new DTUmain();
    static DTUmain dtuMainRef = null; 
    //static DTUelements dtueRef = this; 
    public static HashMap<String,Boolean> stopProcessingHM = new HashMap<String,Boolean>();
    public static Vector<Boolean> stopProcessingV = new Vector<Boolean>();



    public void DTUelements() {

	ulp.addDTURef(this);
	//dtueRef = this;

	//stopProcessingHM.put(DTUSessionID,false);
	//stopProcessingHM.put(SessionNumber.toString(),false);
	System.out.println(System.getProperty("os.name")); 
	dtuMainRef.updateDLQ("test");

    }

    public void addDTUmainRef(DTUmain dtuMainRefIN) {

	dtuMainRef = dtuMainRefIN;	
    }

    public static void addTabRef(JTabbedPane tabbedPaneC, boolean restoreIN) {
	tabbedPaneLocalRef = tabbedPaneC;
	restore = restoreIN;
    }

    public void disableButtons() {
	btnUpload.setEnabled(false);
	btnUpload.setOpaque(true);
	System.out.println("disable buttons");
	//btnTest.setEnabled(false);
	//btnTest.setOpaque(true);
	btnTest.setEnabled(true);
	btnTest.setOpaque(false);
	btnUpload.revalidate();
    }

    public static void addSessionID(String DTUSessionIDIN, Integer SessionNumberIN) {
	DTUSessionID = new String(DTUSessionIDIN);
	SessionNumber = SessionNumberIN;
	stopProcessingHM.put(DTUSessionIDIN,false);
	stopProcessingHM.put(SessionNumberIN.toString(),false);
	System.out.println("DTUSessionIDI"+DTUSessionIDIN);
    }

    public void setLogAreaDLQ(String messagesDLQ) {

	logAreaDLQ.setText(messagesDLQ);
    }

    public void setStopProcessing(Boolean stopProcessingIN) {
	stopProcessing = stopProcessingIN;
	stopProcessingB = stopProcessingIN;
    }	

    public void setStopProcessingHM(String DTUSessionIDIN, Boolean stopProcessingIN) {
	//	stopProcessing = stopProcessingIN;
	//	stopProcessingB = stopProcessingIN;
	System.out.println("setStopProcessingHM");
	stopProcessingHM.put(DTUSessionIDIN,false);
	//stopProcessingHM.put((SessionNumber--).toString(),false);
	System.out.println("setStopProcessingHM");

    }	


    // public void addLogArea(JTextArea logAreaIN) {
    public void addLogArea(JTextPane logAreaIN) {
	logArea = logAreaIN;
    }
    public void addLogAreaDLQ(JTextPane logAreaDLQIN) {
	logAreaDLQ = logAreaDLQIN;
	//		logAreaDLQ.setText("DLQinDE");
    }

    public boolean getTabProgress() {
	return workingTab;
    }

    public static JPanel getPanel() {
	// log.info("create Panel");

	final JButton btnUpload = new JButton("Upload");
	final JButton btnTest = new JButton("Test");


	Logger logger = null;
	DTULogger tlg;
	try {
	    logger = DTULogger.getAppLogger("DTU.log");
	} catch (IOException e1) {
	    // TODO Auto-generated catch block
	    e1.printStackTrace();
	}

	final JTabbedPane tabbedPaneB = new JTabbedPane(JTabbedPane.TOP);

	// panelRootDE is top Panel of new tab
	final JPanel panelRootDE = new JPanel();
	// JPanel panel = new JPanel(new GridLayout(0, 1));
	// panelRootDE.setLayout(new BorderLayout());
	// panelRooCtDE.setLayout(new SpringLayout());
	panelRootDE.setLayout(null);

	String columnNames1[] = { "Datafiles" };
	String columnNames2[] = { "Parameter", "Setting" };

	// params
	String dataValuesTargetHosts[][] = null;
	//new String[20][20];
	// datafiles
	//String dataValuesDatafiles[][] = new String[20][20];
	String dataValuesDatafiles[][] = null;
	//new String[][];
	// targets
	String dataValuesParam[][] = new String[20][20];
	String columnNames40[] = { "Target Hosts" };

	// HashMap stateHM = new HashMap();

	// restore saved state
	// @@currently populating from SAVED STATE
	// stateHM = getState();
	StoreObjectConfig restoredOCfgB = new StoreObjectConfig();
	// restoredOCfgB = (StoreObjectConfig) getState();
	restoredOCfgB = (StoreObjectConfig) getState(restore);

	if (restore) {
	    dataValuesParam = restoredOCfgB.getParam("Session");
	    dataValuesDatafiles = restoredOCfgB.getDatafiles("Session");
	    dataValuesTargetHosts = restoredOCfgB.getTargets("Session");
	} else {
	    /*
	     * dataValuesParam = restoredOCfgB.getParam(DTUSessionID);
	     * dataValuesDatafiles = restoredOCfgB.getDatafiles(DTUSessionID);
	     * dataValuesTargetHosts = restoredOCfgB.getTargets(DTUSessionID);
	     */
	    dataValuesParam = restoredOCfgB.getParam("Session");
	    dataValuesDatafiles = restoredOCfgB.getDatafiles("Session");
	    dataValuesTargetHosts = restoredOCfgB.getTargets("Session");
	}

	/*
	 * dataValuesTargetHosts = restoredOCfgB.getParam("Session");
	 * dataValuesDatafiles = restoredOCfgB.getDatafiles("Session");
	 * dataValuesParam = restoredOCfgB.getTargets("Session");
	 */
	String[][] dataValuesLocalParam = { { "", "" } };
	String[][] dataValuesLocalDatafiles = { { "", "" } };
	String[][] dataValuesLocalTargetHosts = { { "", "" } };
	if (restore) {
	    dataValuesLocalParam = restoredOCfgB.getParam("Session");
	    dataValuesLocalDatafiles = restoredOCfgB.getDatafiles("Session");
	    dataValuesLocalTargetHosts = restoredOCfgB.getTargets("Session");
	} else {
	    /*
	     * dataValuesLocalParam = restoredOCfgB.getParam(DTUSessionID);
	     * dataValuesLocalDatafiles =
	     * restoredOCfgB.getDatafiles(DTUSessionID);
	     * dataValuesLocalTargetHosts =
	     * restoredOCfgB.getTargets(DTUSessionID);
	     */
	    dataValuesLocalParam = restoredOCfgB.getParam("Session");
	    dataValuesLocalDatafiles = restoredOCfgB.getDatafiles("Session");
	    dataValuesLocalTargetHosts = restoredOCfgB.getTargets("Session");
	}

	// System.out.println("dataValuesLocalParam.length");
	// System.out.println("dataValuesLocalParam.length");

	StoreObjectConfig copyStoreObjectConfigB = new StoreObjectConfig();
	/*
	 * copyStoreObjectConfigB.addParam(DTUSessionID, dataValuesLocalParam);
	 * copyStoreObjectConfigB.addDatafiles(DTUSessionID,
	 * dataValuesLocalDatafiles);
	 * copyStoreObjectConfigB.addTargets(DTUSessionID,
	 * dataValuesLocalTargetHosts);
	 */
	copyStoreObjectConfigB.addParam("Session", dataValuesLocalParam);
	copyStoreObjectConfigB
	    .addDatafiles("Session", dataValuesLocalDatafiles);
	copyStoreObjectConfigB
	    .addTargets("Session", dataValuesLocalTargetHosts);

	final StoreObjectConfig copyStoreObjectConfig = copyStoreObjectConfigB;

	// String[][] dataValuesLocalTargetHoststest =
	// copyStoreObjectConfigB.getTargets("Session");

	System.out.println(DTUSessionID);


        tableTargetHosts = new JTable(dataValuesTargetHosts, columnNames40 );

        final DefaultTableModel tableTargetHostsModel = new DefaultTableModel(dataValuesTargetHosts, columnNames40);
        tableTargetHosts.setModel(tableTargetHostsModel);

	//		tableTargetHosts = new JTable(dataValuesTargetHosts, columnNames40);
	tableTargetHosts.setBounds(1, 12, 200, 604);
	tableTargetHosts.setPreferredScrollableViewportSize(new Dimension(12, 18));
	tableTargetHosts.setFillsViewportHeight(true);

	final JScrollPane scrollPaneTargetHostsDE = new JScrollPane( tableTargetHosts);
	// scrollPaneTargetHostsDE.setViewportBorder((Border) new
	// SoftBevelBorder( BevelBorder.LOWERED, null, null, null, null));
	scrollPaneTargetHostsDE.setViewportBorder(new SoftBevelBorder(
								      BevelBorder.LOWERED, null, null, null, null));
	scrollPaneTargetHostsDE.setVisible(true);
	scrollPaneTargetHostsDE.setBounds(0, 0, 278, 167);

	JPanel panel_Q1DE = new JPanel();
	panel_Q1DE.add(scrollPaneTargetHostsDE);

	panel_Q1DE.setBounds(310, 7, 310, 171);
	// panel_Q1DE.setLocation(312, 5);
	panelRootDE.add(panel_Q1DE);
	panel_Q1DE.setLayout(null);
	// //
	JPanel panel_Q4 = new JPanel();
	panel_Q4.setBounds(0, 0, 306, 157);

	// Border border = BorderFactory.createMatteBorder(1, 1, 1, 1,
	// Color.gray);
	// Border border = BorderFactory.createMatteBorder(1, 1, 1, 1,
	// Color.decode("#dbedfa"));
	Border border = BorderFactory.createBevelBorder(0, Color.LIGHT_GRAY, Color.gray);
	panel_Q4.setBorder(border);

	panelRootDE.add(panel_Q4);
	panel_Q4.setLayout(null);
	panel_Q4.setBounds(310, 175, 279, 169);
	// ///

	final JProgressBar progressBar = new JProgressBar();
	// progressBar.setUI(new javax.swing.plaf.metal.MetalProgressBarUI());
	progressBar.setForeground(Color.decode("#7fa8ce"));
	progressBar.setUI(new javax.swing.plaf.metal.MetalProgressBarUI() {
		protected Color getSelectionBackground() {
		    //				return Color.decode("#7fa8ce");
		    //progressBar.setString("Upload Startup");
		    return Color.decode("#595454");
		}

		// protected Color getSelectionForeground() { return
		// Color.decode("#7fa8ce"); }
		protected Color getSelectionForeground() {
		    return Color.black;
		}
	    });

	// progressBar.setBounds(320, 215, 248, 30);
	progressBar.setBounds(320, 215, 240, 20);

	// progressBar.setLocation(23, 257);
	// panel_Q1DE.add(progressBar);
	panelRootDE.add(progressBar);
	progressBar.setValue(0);

	final JProgressBar progressBarB = new JProgressBar();

	// progressBarB.setUI(new javax.swing.plaf.metal.MetalProgressBarUI());

	progressBarB.setUI(new javax.swing.plaf.metal.MetalProgressBarUI() {
		// protected Color getSelectionBackground() { return
		// Color.decode("#1ga8ce"); }
		protected Color getSelectionBackground() {
		    //				return Color.decode("#7fa8ce");
		    return Color.decode("#595454");
		}

		// protected Color getSelectionBackground() { return
		// Color.decode("#7fa8ce"); }
		// protected Color getSelectionForeground() { return
		// Color.decode("#7fa8ce"); }
		protected Color getSelectionForeground() {
		    //				return Color.white;
		    return Color.black;
		}
	    });
	progressBarB.setForeground(Color.decode("#7fa8ce"));

	progressBarB.setBounds(320, 255, 240, 20);

	// progressBar.setBounds(320, 215, 248, 30);
	// progressBarB.setBounds(310, 250, 248, 30);
	// progressBarB.setBounds(320, 255, 248, 30);
	panelRootDE.add(progressBarB);
	// panel_Q1DE.add(progressBarB);
	//@@ 
	progressBarB.setValue(0);

	/*
	 * JTextField progressText = new JTextField(); progressText.setBounds(8,
	 * 255, 248, 30); progressText.setOpaque(false);
	 * progressText.setBackground(new Color(0, 0, 0, 0));
	 * progressText.setBorder(null); // panel_Q1DE.add(progressText);
	 */
	final JTextField textProgress = new JTextField();
	textProgress.setBounds(350, 235, 248, 30);
	textProgress.setEditable(false);
	// textProgress.setBorder(null);
	// textProgress.setBorder(BorderFactory.createLineBorder((Color.decode("#EDDFFB"))));
	textProgress.setBorder(BorderFactory.createEmptyBorder());
	// f8f8f8
	// textProgress.setBackground(Color.decode("#F9EEFF"));
	textProgress.setBackground(Color.decode("#F8F8F8"));
	// textProgress.setBackground(Color.decode("#F9EEFF"));
	textProgress.setForeground(Color.decode("#5184D5"));
	// panel_Q1DE.add(textProgress);


	//@@ disable textprogressTOP
	//panelRootDE.add(textProgress);

	final JTextField textProgressB = new JTextField();
	// textProgressB.setBounds(8, 285, 248, 10);
	// textProgressB.setBounds(320, 315, 248, 30);
	// textProgressB.setBounds(320, 315, 248, 30);
	//		textProgressB.setBounds(320, 255, 248, 30);
	textProgressB.setBounds(320, 270, 248, 30);
	// textProgressB.setBounds(350, 315, 248, 30);
	textProgressB.setEditable(false);
	textProgressB.setBorder(BorderFactory.createEmptyBorder());
	textProgressB.setBackground(Color.decode("#F8F8F8"));
	textProgressB.setForeground(Color.decode("#E51111"));
	// panel_Q1DE.add(textProgressB);


	//@@ disable textprogressB
	//panelRootDE.add(textProgressB);

	// textProgress.setText("progress of upload");
	// textProgressB.setText("notifications, warning and errors");
	textProgressB.revalidate();

	JPanel panel_Q2DE = new JPanel();
	panel_Q2DE.setBounds(10, 7, 302, 360);
	panelRootDE.add(panel_Q2DE);
	panel_Q2DE.setLayout(null);



	tableDataFiles = new JTable(dataValuesDatafiles, columnNames1);
        final DefaultTableModel table_DatafilesModel = new DefaultTableModel(dataValuesDatafiles, columnNames1);
        tableDataFiles.setModel(table_DatafilesModel);



	//	tableDataFiles = new JTable(dataValuesDatafiles, columnNames1);
	tableDataFiles.setBounds(1, 12, 200, 604);
	tableDataFiles.setPreferredScrollableViewportSize(new Dimension(12, 18));
	tableDataFiles.setFillsViewportHeight(true);

	final JScrollPane scrollPaneDatafilesDE = new JScrollPane(
								  tableDataFiles);
	scrollPaneDatafilesDE.setVisible(true);
	// scrollPaneDatafilesDE.setViewportBorder((Border) new SoftBevelBorder(
	// BevelBorder.LOWERED, null, null, null, null));
	scrollPaneDatafilesDE.setViewportBorder(new SoftBevelBorder(
								    BevelBorder.LOWERED, null, null, null, null));
	scrollPaneDatafilesDE.setBounds(0, 0, 278, 167);



	class PopupListener extends MouseAdapter {
	    JTable table;
	    String dataVal[][];
	    String dataValTMP[][];

	    public void addDataValues(String dataValB[][]) {
		//dataVal = dataValB;
		dataValTMP = dataValB;
	    }

	    public void mousePressed(MouseEvent e) {
		//if(SwingUtilities.isLeftMouseButton(e) ) {
                if(SwingUtilities.isRightMouseButton(e) ) {
                    //if ((e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 1) && (e.getButton() == MouseEvent.BUTTON2 && e.getClickCount()==1 )) { 
                    System.out.println("left mouse button");
                    int row = tableDataFiles.rowAtPoint( e.getPoint() );
                    int column = tableDataFiles.columnAtPoint( e.getPoint() );
		    // JOptionPane.showMessageDialog(null,"Key store not found", "Configuration Error", JOptionPane.ERROR_MESSAGE);

		    String[] options = new String[] {"Delete Row", "Add Row", "Cancel"};

		    //JOptionPane jop = new JOptionPane();
		    //int selection = JOptionPane.showOptionDialog(null, "", "Add/Delete Datafile Source", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
		    int selection = JOptionPane.showOptionDialog(null, "Add/Delete datafile location", "Add/Delete", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);

		    System.out.println(selection+"=selection");
		    if(selection==1) {
			////@@@ showPopup(e);
			System.out.println(selection+"=ssselection");

			popupMenu.show(e.getComponent(), e.getX(), e.getY());
			UIManager.put("FileChooser.readOnly", Boolean.TRUE);
			JDialog.setDefaultLookAndFeelDecorated(true);
			JFileChooser chooser = new JFileChooser();
			chooser.setCurrentDirectory(new File(new String(System.getProperty("user.dir"))));
			chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
			FileNameExtensionFilter filter = new FileNameExtensionFilter( "logs,csv,db,json", "log", "csv", "db", "json");
			chooser.setFileFilter(filter);
			int returnVal = chooser.showOpenDialog(textField_1);

			if (returnVal == JFileChooser.APPROVE_OPTION) {
			    System.out.println(chooser.getSelectedFile().getName());

			    String valueAdded = (String) chooser.getSelectedFile().getAbsolutePath();

			    int numRows = 0;
			    numRows = ((DefaultTableModel)tableDataFiles.getModel()).getRowCount();
			    ((DefaultTableModel)tableDataFiles.getModel()).insertRow(numRows, new Object[]{valueAdded});
			    //  ((DefaultTableModel)table_Datafiles.getModel()).insertRow(0, new Object[]{valueAdded});
			    tableDataFiles.revalidate();
			}
		    }
		    if(selection==0) {
			((DefaultTableModel)tableDataFiles.getModel()).removeRow(row);
		    }

                    tableDataFiles.revalidate();
                }

		//	showPopup(e);
	    }

	    public void mouseReleased(MouseEvent e) {
		//	showPopup(e);
	    }

	    private void showPopup(MouseEvent e) {
		/*
		  if (e.isPopupTrigger()) {
		  popupMenu.show(e.getComponent(), e.getX(), e.getY());
		  UIManager.put("FileChooser.readOnly", Boolean.TRUE);  

		  JFileChooser chooser = new JFileChooser();
		  chooser.setCurrentDirectory(new File(new String(System.getProperty("user.dir"))));
		  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
		  FileNameExtensionFilter filter = new FileNameExtensionFilter( "logs,csv,db", "log", "csv", "db");
		  chooser.setFileFilter(filter);
		  int returnVal = chooser.showOpenDialog(textField_1);



		  if (returnVal == JFileChooser.APPROVE_OPTION) {
		  //  System.out.println(chooser.getSelectedFile().getName());
		  dataValTMP[dataValuesSizeDataFiles][0] = (String) chooser.getSelectedFile().getAbsolutePath();
		  dataValuesSizeDataFiles++;
		  tableDataFiles.revalidate();


		  ////
		  int row = tableDataFiles.rowAtPoint( e.getPoint() );
		  int column = tableDataFiles.columnAtPoint( e.getPoint() );

		  String valueAdded = (String) chooser.getSelectedFile().getAbsolutePath();
		  ((DefaultTableModel)tableDataFiles.getModel()).insertRow(0, new Object[]{valueAdded});
		  tableDataFiles.revalidate();
		  }



		  }
		*/
	    }

	}// end popup class



	class PopupListenerB extends MouseAdapter {
	    JTable table;
	    String dataVal[][];
	    int datacounter = 0;

	    public void addDataValues(String dataValB[][]) {
		dataVal = dataValB;
	    }

	    public void mousePressed(MouseEvent e) {
		//		showPopup(e);

		if(SwingUtilities.isRightMouseButton(e) ) {
                    System.out.println("left mouse button");
                    int row = tableTargetHosts.rowAtPoint( e.getPoint() );
                    int column = tableTargetHosts.columnAtPoint( e.getPoint() );

		    String[] options = new String[] {"Delete Row", "Add Row", "Cancel"};

		    //@@int selection = JOptionPane.showOptionDialog(null, "Add/Delete datafile location", "Add/Delete", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
		    int selection = JOptionPane.showOptionDialog(null, "Add/Delete Target IP or Hostname", "Add/Delete", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);

		    System.out.println(selection+"=selection");
		    if(selection==1) {
			//@@@ showPopup(e);
			displayPopUp();

		    }
		    if(selection==0) {
			((DefaultTableModel)tableTargetHosts.getModel()).removeRow(row);
		    }

                    tableTargetHosts.revalidate();
                }

	    }

	    public void mouseReleased(MouseEvent e) {
		//@@		showPopup(e);
	    }

	    private void showPopup(MouseEvent e) {
		if (e.isPopupTrigger()) {
                    dataValuesSizeTargets++;
                    tableTargetHosts.revalidate();


		    String[] options = new String[] {"Delete Row", "Add Row", "Cancel"};

		    //JOptionPane jop = new JOptionPane();
		    //int selection = JOptionPane.showOptionDialog(null, "", "Add/Delete Datafile Source", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
		    int selection = JOptionPane.showOptionDialog(null, "Add/Delete Target IP or Hostname", "Add/Delete", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);

		    System.out.println(selection+"=selection");
		    if(selection==1) {
			// showPopup(e);
			displayPopUp();
			System.out.println(selection+"=ssselection");
		    }
                    //displayPopUp();
                }

	    }

	    public void displayPopUp() {
                JTextField field1 = new JTextField(
                                                   "ip or hostname of JMS queue");
                JTextField field2 = new JTextField("port of JMS queue");
                // JPanel panelPopUp = new JPanel(new GridLayout(0, 1));

                JPanel panelPopUp = new JPanel();

                // panelPopUp.add(new JLabel("ip or hostname of JMS queue"));
                panelPopUp.add(field1);
                int result = JOptionPane.showConfirmDialog(null, panelPopUp,
                                                           "JMS queue selection", JOptionPane.OK_CANCEL_OPTION,
                                                           JOptionPane.PLAIN_MESSAGE);
                if (result == JOptionPane.OK_OPTION) {
                    System.out.println(" " + field1.getText() + " " + field2.getText());

		    //  dataVal[datacounter][0] = (String) field1.getText();
		    //  datacounter++;

		    String valueAdded = (String) field1.getText();
		    int numRows = 0;
		    numRows = ((DefaultTableModel)tableTargetHosts.getModel()).getRowCount();
		    ((DefaultTableModel)tableTargetHosts.getModel()).insertRow(numRows, new Object[]{valueAdded});
		    //  ((DefaultTableModel)table_Datafiles.getModel()).insertRow(0, new Object[]{valueAdded});
		    tableTargetHosts.revalidate();




                } else {
                    System.out.println("Cancelled");
                }


	    }

	}// end popup class/



	MouseListener popupListener = new PopupListener();
	((PopupListener) popupListener).addDataValues(dataValuesDatafiles);
	// add the listener specifically to the header
	tableDataFiles.addMouseListener(popupListener);
	tableDataFiles.getTableHeader().addMouseListener(popupListener);
	/*
	  MouseListener popupListenerB = new PopupListenerB();
	  ((PopupListenerB) popupListenerB).addDataValues(dataValuesTargetHosts);
	  tableB.addMouseListener(popupListenerB);
	  tableB.getTableHeader().addMouseListener(popupListenerB);
	  tableB.revalidate();
	*/

	MouseListener popupListenerB = new PopupListenerB();
	((PopupListenerB) popupListenerB).addDataValues(dataValuesTargetHosts);
	// add the listener specifically to the header
	tableTargetHosts.addMouseListener(popupListenerB);
	tableTargetHosts.getTableHeader().addMouseListener(popupListenerB);






	panel_Q2DE.add(scrollPaneDatafilesDE);

	final ArrayList<TableCellEditor> editors = new ArrayList<TableCellEditor>( 1);

	String[] columnNamesDrop1 = { "Type", "Value" };
	JComboBox comboBox1 = new JComboBox(columnNamesDrop1);
	DefaultCellEditor dce1 = new DefaultCellEditor(comboBox1);
	editors.add(dce1);

	String[] columnNamesDrop2 = { "Type", "Value" };
	JComboBox comboBox2 = new JComboBox(columnNamesDrop2);
	DefaultCellEditor dce2 = new DefaultCellEditor(comboBox2);
	editors.add(dce2);

	// String[] columnNamesDrop3 = {"CSV","Value"};
	// String[] columnNamesDrop3 = {"CSV","Value"};
	JComboBox comboBox3 = new JComboBox(types);
	DefaultCellEditor dce3 = new DefaultCellEditor(comboBox3);
	editors.add(dce3);

	final DefaultTableModel model = new DefaultTableModel(dataValuesParam,
							      columnNames2);

	// JTable tableB = new JTable(model) {
	tableB = new JTable(model) {
		// Determine editor to be used by row
		public TableCellEditor getCellEditor(int row, int column) {
		    int modelColumn = convertColumnIndexToModel(column);

		    if (modelColumn == 1 && row == 2)
			return editors.get(row);
		    // return (TableCellEditor)editors.get(row);
		    else
			return super.getCellEditor(row, column);
		}
	    };


	tableB.setBounds(12, 18, 219, 102);
	tableB.setPreferredScrollableViewportSize(new Dimension(12, 18));
	tableB.setFillsViewportHeight(true);

	final JScrollPane scrollPaneParametersDE = new JScrollPane(tableB);

	scrollPaneParametersDE.setVisible(true);
	scrollPaneParametersDE.setViewportBorder(new SoftBevelBorder( BevelBorder.LOWERED, null, null, null, null));

	scrollPaneParametersDE.setBounds(1, 170, 278, 167);

	// scrollPaneParametersDETargetHostsDE.setBounds(0, 2, 278, 167);

	// scrollPaneParametersDEDatafilesDE.setBounds(1, 2, 285, 161);

	JLabel label = new JLabel("select datafile");
	label.setBounds(35, 120, 134, 17);
	panelRootDE.add(label);

	panel_Q2DE.add(scrollPaneParametersDE);

	// /dropdown
	final JComboBox cBoxKeystore = new JComboBox();
	cBoxKeystore.setEnabled(true);
	cBoxKeystore.setEditable(false);

	cBoxKeystore.removeAll();
	// String keystorePath = "/home/craig2/keystore/";
	//final String keystorePath = "keystore/";
	final String keystorePath = (System.getProperty("user.dir"));
	File folder = new File(keystorePath);
	//File[] listOfFiles = folder.listFiles();
	File[] listOfFiles = folder.listFiles(new FilenameFilter() {
		public boolean accept(File folder, String filename) {
		    return filename.toLowerCase().endsWith(".ks");
		}
	    } );
	for (int i = 0; i < listOfFiles.length; i++) {
	    cBoxKeystore.addItem(listOfFiles[i].getName());
	    System.out.println(listOfFiles + "");
	}
		cBoxKeystore.setSelectedItem("");

	// cBoxKeystore.addItem("keystoreASTON");
	// cBoxKeystore.addItem("keystoreFORD");
	// cBoxKeystore.addItem("keystoreACURA");
	// cBoxKeystore.addItem("keystoreCHEVY");
	cBoxKeystore.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent event) {
		    // asignment
		    System.out.println(cBoxKeystore.getSelectedItem());
		    // boxArg0005 = ((String)cBoxKeystore.getSelectedItem());
		    //keyStoreLocation = ("keystorePath" + (String) cBoxKeystore.getSelectedItem());
		    //trustStoreLocation = ("truststorePath" + (String) cBoxKeystore.getSelectedItem());
		    //keyStoreLocation = (keystorePath+(String) cBoxKeystore.getSelectedItem());
		    //trustStoreLocation = (keystorePath+(String) cBoxKeystore.getSelectedItem());


		    System.out.println(System.getProperty("os.name")); 

		    if(System.getProperty("os.name").equals("Linux")) {
			keyStoreLocation = (System.getProperty("user.dir")+"/"+(String) cBoxKeystore.getSelectedItem());
			trustStoreLocation = (System.getProperty("user.dir")+"/"+(String) cBoxKeystore.getSelectedItem());
		    } else {
			keyStoreLocation = (System.getProperty("user.dir")+"\\"+(String) cBoxKeystore.getSelectedItem());
			trustStoreLocation = (System.getProperty("user.dir")+"\\"+(String) cBoxKeystore.getSelectedItem());
		    } 

		    System.out.println(keyStoreLocation);
		    System.out.println(trustStoreLocation);
		
		cBoxKeystore.setSelectedItem(keyStoreLocation);


		}
	    });

	cBoxKeystore.setVisible(true);
	// cBoxKeystore.setBounds(310, 180, 180, 25);
	// cBoxKeystore.setBounds(320, 190, 180, 25);
	cBoxKeystore.setBounds(400, 185, 180, 25);
	JLabel keystoreLabel = new JLabel("Keystore");
	// keystoreLabel.setText("Keystore");
	keystoreLabel.setBounds(330, 185, 180, 25);
	keystoreLabel.setVisible(true);

	JButton btnAddsystem = new JButton("save");

	btnAddsystem.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent e) {
		    /*
		     */
		    ArrayList<String> drfList = listFile("/tmp/");
		    for (String x : drfList) {
			// cBoxKeystore.addItem(listButton);
			cBoxKeystore.addItem(x);
		    }

		}
	    });

	btnAddsystem.setBounds(496, 290, 124, 25);
	btnAddsystem.setLocation(350, 290);
	// panelRootDE.add(btnAddsystem);
	panelRootDE.add(cBoxKeystore);
	panelRootDE.add(keystoreLabel);


	workingTab = true;

	int selectedIndex = tabbedPaneLocalRef.getSelectedIndex();

	final JButton btnCancel = new JButton("Cancel");
	btnCancel.setEnabled(false);
	btnCancel.setOpaque(true);

	//	final JButton btnUpload = new JButton("Upload");
	//	final JButton btnTest = new JButton("Test");
	btnUpload.setEnabled(true);
	btnUpload.setOpaque(false);
	btnTest.setEnabled(true);
	btnTest.setOpaque(false);
	btnTest.setBounds(315, 305, 90, 30);
	panelRootDE.add(btnTest);

	btnTest.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent e) {
	
    //	System.out.println("Upload initiated");
		    btnUpload.setEnabled(false);
		    btnUpload.setOpaque(true);
		    btnTest.setEnabled(false);
		    btnTest.setOpaque(true);
		    btnCancel.setEnabled(true);
		    btnCancel.setOpaque(false);

		    //	boolean runThis = true;
		    //boolean runThis = true;


		    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		    System.out.println(screenSize.toString());



		    UploadProc ulp;
		    try {

			//	ulp = new UploadProc("upload");
			//	ulp.setTest(false);
			ulp = new UploadProc("test");
			ulp.setTest(true);


			String currentTabSA = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
			//stopProcessingHM.put("Session_"+((tabbedPaneLocalRef.getSelectedIndex())--),true);
			stopProcessingHM.put(currentTabSA,false);




			ulp.loadConfig(copyStoreObjectConfig);
			ulp.addData((String) tableDataFiles.getModel().getValueAt( 0, 0));
			ulp.addTabRef(tabbedPaneLocalRef, spinIcon);

			//@@@@
			Integer currentTab = tabbedPaneLocalRef.getSelectedIndex();
			System.out.println(currentTab+"currentTab");
			Integer currentTabB = (currentTab-1);
			System.out.println(currentTab+"currentTab");
			//String currentTabS = "Session_"+currentTabB;

			//@@@@String currentTabS = "Session_"+(tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
			String currentTabS = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));

			System.out.println(currentTabS+"currentTab DTUSessionID");
			System.out.print("tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()))");
			System.out.println(tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));


			//register tab with session control
			//ulp.addSessionID(DTUSessionID, SessionNumber);
			ulp.addSessionID(currentTabS, SessionNumber);
			uploadProcs.put("Session" + ulp.hashCode(), ulp);

			System.out.println("DTUSessionID in upload button"+DTUSessionID);	




			ulp.addStoreLocations(keyStoreLocation, keyStoreLocation);
			//ulp.addLogDLQ(logAreaDLQ);

			// MonDLQ mdlq = new MonDLQ();
			MonDLQ mdlq = new MonDLQ();
			mdlq.addLog(logArea);
			mdlq.addLogDLQ(logAreaDLQ);
			mdlq.addDTUmainRef(dtuMainRef);

			// mdlq.addLogger(logger);

			mdlq.addSessionID(DTUSessionID);
			mdlq.addUploadProcRef(ulp);
			// mdlq.addProcessingMon(stopProcessing);
			// mdlq.start();



			ulp.addMonDLQProcRef(mdlq);

			// scrollPaneTargetHostsDE.setEnabled(false);
			tableTargetHosts.setEnabled(false);
			tableTargetHosts.setOpaque(true);
			tableTargetHosts.setBackground(Color.decode("#d2e8f8"));
			tableDataFiles.setEnabled(false);
			tableDataFiles.setOpaque(true);
			tableDataFiles.setBackground(Color.decode("#d2e8f8"));
			tableB.setEnabled(false);
			tableB.setOpaque(true);
			tableB.setBackground(Color.decode("#d2e8f8"));

			Logger logger = null;
			DTULogger tlg;
			try {
			    logger = DTULogger.getAppLogger("DTU.log");
			} catch (IOException e1) {
			    // TODO Auto-generated catch block
			    e1.printStackTrace();
			}

			String dests[][] = new String[20][20];

			TableModel modelb = tableTargetHosts.getModel();
			int i = 0;
			while (i < modelb.getRowCount()) {
			    //System.out.println("modelb");
			    if (modelb.getValueAt(i, 0) != null) {
				// String strS = (modelb.getValueAt(i,
				// 0).toString());
				dests[i][0] = (modelb.getValueAt(i, 0).toString());



				System.out.println("dests in upload");
				System.out.println(modelb.getValueAt(i, 0) .toString());
				//	logger.info(modelb.getValueAt(i, 0).toString());
			    }
			    i++;
			}

			ulp.setDests(dests);

               		//String dataValuesDatafilesN[][] = new String[table_DatafilesModel.getRowCount()][1];
			//String datafiles[][] = new String[20][20];

			TableModel modelc = tableDataFiles.getModel();
			String datafiles[][] = new String[modelc.getRowCount()][1];
			int ii = 0;

			while (ii < modelc.getRowCount()) {
			    if (modelc.getValueAt(ii, 0) != null) {
				datafiles[ii][0] = (modelc.getValueAt(ii, 0).toString());
			    }
			    ii++;
			}

			TableModel modeld = tableB.getModel();
			String params[][] = new String[20][20];
			int iii = 0;
			int ci = 0;

			//@@
			ulp.setData(datafiles);
/*	

                 int ii=0;
                 String dataValuesDatafilesN[][] = new String[table_DatafilesModel.getRowCount()][1];

                    while(ii< table_DatafilesModel.getRowCount()) {
                        if((table_DatafilesModel.getValueAt(ii, 0)!=null)) {
                            dataValuesDatafilesN[ii][0] = (table_DatafilesModel.getValueAt(ii, 0).toString());
                        }
                        ii++;
                    }


	
*/


			//@@ using these parameters pass in to uploaderProc as either Array or model
			//with a new addModel method... then assign to ulder basedupon that    	
			while (ci < 2) {
			    while (iii < modeld.getRowCount()) {
				System.out.println("model Params");
				if (modeld.getValueAt(iii, ci) != null) {
				    params[iii][ci] = (modeld.getValueAt(iii, ci).toString());
				}
				iii++;
			    }
			    iii = 0;
			    ci++;
			}



			ulp.addDataValues(params);


			StoreObjectConfig saveOCfg = new StoreObjectConfig();
			saveOCfg.addParam("Session", params);
			saveOCfg.addDatafiles("Session", datafiles);
			saveOCfg.addTargets("Session", dests);

			saveState(saveOCfg, DTUSessionID, "save");

			progressBar.setValue(mdlq.getStatusI(progressBar));

			//progressBar.setValue(ulp.getStatusI(progressBar));

			progressBar.setStringPainted(true);
			if(ulp.getStatusS(progressBar) != null) {
			    progressBar.setString(ulp.getStatusS(progressBar));
			}
			//		progressBar.setString("Upload Startup Process");
			progressBar.setStringPainted(true);
			// progressBar.setString(mdlq.getStatusS(progressBar));
			// progressBar.setString("this is progress");

			progressBar.setForeground(Color.decode("#7fa8ce"));

			progressBarB.setStringPainted(true);
			//progressBarB.setString("Upload Startup Process");
			// progressBarB.setString("dddj");
			progressBarB.setString(ulp.getStatusSB(progressBarB));
			progressBarB.setStringPainted(true);

			//@@
			progressBarB.setValue(mdlq.getStatusJ(progressBarB));
			//progressBarB.setValue(ulp.getStatusJ(progressBarB));

			ulp.start();

			mdlq.start();

			textProgressB.setText(ulp.getStatusT(textProgressB));

			textProgress.setText(mdlq.getStatusT(textProgress)); 
			textProgress.setText(ulp.getErrors());






		    } catch (SocketTimeoutException e2) {
			e2.printStackTrace();
		    }

		    cBoxKeystore.setEnabled(false);
		    workingTab = true;

		    // mdlq.stop();

		    Vector<String> vs = new Vector<String>();
		    try {
			Thread.sleep(1000);
		    } catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		    }

		




		}

	    });


	btnUpload.addActionListener(new ActionListener() {
		@SuppressWarnings("deprecation")
		    public void actionPerformed(ActionEvent e) {
		    //	System.out.println("Upload initiated");
		    btnUpload.setEnabled(false);
		    btnUpload.setOpaque(true);
		    btnTest.setEnabled(false);
		    btnTest.setOpaque(true);
		    btnCancel.setEnabled(true);
		    btnCancel.setOpaque(false);

		    //	boolean runThis = true;
		    //boolean runThis = true;


		    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		    System.out.println(screenSize.toString());



		    UploadProc ulp;
		    try {

			ulp = new UploadProc("upload");
			ulp.setTest(false);

			String currentTabSA = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
			//stopProcessingHM.put("Session_"+((tabbedPaneLocalRef.getSelectedIndex())--),true);
			stopProcessingHM.put(currentTabSA,false);




			ulp.loadConfig(copyStoreObjectConfig);

	//@@@		ulp.addData((String) tableDataFiles.getModel().getValueAt( 0, 0));



//@@WTF

			ulp.addTabRef(tabbedPaneLocalRef, spinIcon);

			//@@@@
			Integer currentTab = tabbedPaneLocalRef.getSelectedIndex();
			System.out.println(currentTab+"currentTab");
			Integer currentTabB = (currentTab-1);
			System.out.println(currentTab+"currentTab");
			//String currentTabS = "Session_"+currentTabB;

			//@@@@String currentTabS = "Session_"+(tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
			String currentTabS = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));

			System.out.println(currentTabS+"currentTab DTUSessionID");
			System.out.print("tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()))");
			System.out.println(tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));


			//register tab with session control
			//ulp.addSessionID(DTUSessionID, SessionNumber);
			ulp.addSessionID(currentTabS, SessionNumber);
			uploadProcs.put("Session" + ulp.hashCode(), ulp);

			System.out.println("DTUSessionID in upload button"+DTUSessionID);	




			ulp.addStoreLocations(keyStoreLocation, keyStoreLocation);
			//ulp.addLogDLQ(logAreaDLQ);

			// MonDLQ mdlq = new MonDLQ();
			MonDLQ mdlq = new MonDLQ();
			mdlq.addLog(logArea);
			mdlq.addLogDLQ(logAreaDLQ);
			mdlq.addDTUmainRef(dtuMainRef);

			// mdlq.addLogger(logger);

			mdlq.addSessionID(DTUSessionID);
			mdlq.addUploadProcRef(ulp);
			// mdlq.addProcessingMon(stopProcessing);
			// mdlq.start();



			ulp.addMonDLQProcRef(mdlq);

			// scrollPaneTargetHostsDE.setEnabled(false);
			tableTargetHosts.setEnabled(false);
			tableTargetHosts.setOpaque(true);
			tableTargetHosts.setBackground(Color.decode("#d2e8f8"));
			tableDataFiles.setEnabled(false);
			tableDataFiles.setOpaque(true);
			tableDataFiles.setBackground(Color.decode("#d2e8f8"));
			tableB.setEnabled(false);
			tableB.setOpaque(true);
			tableB.setBackground(Color.decode("#d2e8f8"));

			Logger logger = null;
			DTULogger tlg;
			try {
			    logger = DTULogger.getAppLogger("DTU.log");
			} catch (IOException e1) {
			    // TODO Auto-generated catch block
			    e1.printStackTrace();
			}

			String dests[][] = new String[20][20];

			TableModel modelb = tableTargetHosts.getModel();
			int i = 0;
			while (i < modelb.getRowCount()) {
			    //System.out.println("modelb");
			    if (modelb.getValueAt(i, 0) != null) {
				// String strS = (modelb.getValueAt(i,
				// 0).toString());
				dests[i][0] = (modelb.getValueAt(i, 0).toString());



				System.out.println("dests in upload");
				System.out.println(modelb.getValueAt(i, 0) .toString());
				//	logger.info(modelb.getValueAt(i, 0).toString());
			    }
			    i++;
			}

			ulp.setDests(dests);

			String datafiles[][] = new String[20][20];

			TableModel modelc = tableDataFiles.getModel();
			int ii = 0;

			while (ii < modelc.getRowCount()) {
			    if (modelc.getValueAt(ii, 0) != null) {
				datafiles[ii][0] = (modelc.getValueAt(ii, 0).toString());
			    }
			    ii++;
			}

			TableModel modeld = tableB.getModel();
			String params[][] = new String[20][20];
			int iii = 0;
			int ci = 0;

			  ulp.setData(datafiles);




			//@@ using these parameters pass in to uploaderProc as either Array or model
			//with a new addModel method... then assign to ulder basedupon that    	
			while (ci < 2) {
			    while (iii < modeld.getRowCount()) {
				System.out.println("model Params");
				if (modeld.getValueAt(iii, ci) != null) {
				    params[iii][ci] = (modeld.getValueAt(iii, ci).toString());
				}
				iii++;
			    }
			    iii = 0;
			    ci++;
			}



			ulp.addDataValues(params);


			StoreObjectConfig saveOCfg = new StoreObjectConfig();
			saveOCfg.addParam("Session", params);
			saveOCfg.addDatafiles("Session", datafiles);
			saveOCfg.addTargets("Session", dests);

			saveState(saveOCfg, DTUSessionID, "save");

			progressBar.setValue(mdlq.getStatusI(progressBar));

			//progressBar.setValue(ulp.getStatusI(progressBar));

			progressBar.setStringPainted(true);
			if(ulp.getStatusS(progressBar) != null) {
			    progressBar.setString(ulp.getStatusS(progressBar));
			}
			//		progressBar.setString("Upload Startup Process");
			progressBar.setStringPainted(true);
			// progressBar.setString(mdlq.getStatusS(progressBar));
			// progressBar.setString("this is progress");

			progressBar.setForeground(Color.decode("#7fa8ce"));

			progressBarB.setStringPainted(true);
			//progressBarB.setString("Upload Startup Process");
			// progressBarB.setString("dddj");
			progressBarB.setString(ulp.getStatusSB(progressBarB));
			progressBarB.setStringPainted(true);

			//@@
			progressBarB.setValue(mdlq.getStatusJ(progressBarB));
			//progressBarB.setValue(ulp.getStatusJ(progressBarB));

			ulp.start();

			mdlq.start();

			textProgressB.setText(ulp.getStatusT(textProgressB));

			textProgress.setText(mdlq.getStatusT(textProgress)); 
			textProgress.setText(ulp.getErrors());

		    } catch (SocketTimeoutException e2) {
			e2.printStackTrace();
		    }

		    cBoxKeystore.setEnabled(false);
		    workingTab = true;

		    // mdlq.stop();

		    Vector<String> vs = new Vector<String>();
		    try {
			Thread.sleep(1000);
		    } catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		    }

		}
			
	    });

	// textProgressB.setBounds(320, 315, 248, 30);
	// btnUpload.setBounds(403, 285, 90, 30);
	btnUpload.setBounds(403, 305, 90, 30);
	panelRootDE.add(btnUpload);


	btnCancel.addActionListener(new ActionListener() {
		@SuppressWarnings("deprecation")
		    public void actionPerformed(ActionEvent e) {

		    try {
			Thread.sleep(1000);
		    } catch (InterruptedException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		    }
		    btnCancel.setEnabled(false);
		    btnCancel.setOpaque(true);
		    btnUpload.setEnabled(true);
		    btnUpload.setOpaque(false);
		    btnTest.setEnabled(true);
		    btnTest.setOpaque(false);
		    stopProcessing = true;
		    //dtueRef.setStopProcessingHM(sessionID,true);
		    //stopProcessingHM.put((SessionNumber--).toString(),true);
		    //stopProcessingHM.put(tabbedPane.getSelectedIndex().toString(),true);

		    // jtpLocalRef.getSelectedIndex(),
		    //Integer currentTab = tabbedPaneLocalRef.getSelectedIndex();
		    //@@@@@	
		    Integer currentTab = tabbedPaneLocalRef.getSelectedIndex();
		    //Integer currentTab = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
		    System.out.println(currentTab+"currentTab");
		    Integer currentTabB = (currentTab-1);
		    System.out.println(currentTab+"currentTab");
		    //@@@@String currentTabS = "Session_"+currentTabB;

		    String currentTabS = (tabbedPaneLocalRef.getTitleAt(tabbedPaneLocalRef.getSelectedIndex()));
		    //stopProcessingHM.put("Session_"+((tabbedPaneLocalRef.getSelectedIndex())--),true);
		    stopProcessingHM.put(currentTabS,true);

		    //stopProcessingHM.put(DTUSessionID,true);
		    System.out.println(stopProcessingHM.toString());
		    //@@@
		    //@@@System.out.println(dtueRef.getClass().getName());
		    // mdlq.stopUpldr();
		    try {
			Thread.sleep(50);
		    } catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		    }

		    btnCancel.setEnabled(false);
		    btnCancel.setOpaque(true);
		    btnUpload.setEnabled(true);
		    btnUpload.setOpaque(false);
		    btnTest.setEnabled(true);
		    btnTest.setOpaque(false);
		    stopProcessing = false;
		    ///@@	stopProcessingHM.put(DTUSessionID,false);
		    System.out.println(stopProcessingHM.toString());

		    //@@@
		    //@@@ dtueRef.setStopProcessingHM(DTUSessionID,false);

		}
	    });

	btnCancel.setBounds(491, 305, 90, 30);
	panelRootDE.add(btnCancel);

	return panelRootDE;

    }

    public static void saveState(StoreObjectConfig soc, String DTUSessionID,
				 String Action) {

	FileOutputStream fos = null;
	ObjectOutputStream oos = null;
	try {

	    //System.out.println("DTUSessionID in saveState");
	    //System.out.println(DTUSessionID);

	    if (Action.equals("save")) {

		// output Live Session
		//@@@ make this one the one with no date
		fos = new FileOutputStream(DTUSessionID + ".session");
		oos = new ObjectOutputStream(fos);
		oos.writeObject((StoreObjectConfig) soc);
		oos.flush();
		oos.close();
		fos.close();

	    } else {

		// input Save Session

		FileInputStream fis = new FileInputStream(Action);
		ObjectInputStream ois = new ObjectInputStream(fis);
		StoreObjectConfig restoredOCfg = new StoreObjectConfig();
		restoredOCfg = (StoreObjectConfig) ois.readObject();

		// System.out.println("restoredOCfg.toString()");

		// output Saved Session
		//@@@ make this one the one with timeStamp
		fos = new FileOutputStream(DTUSessionID + "TimeStamp.session");
		oos = new ObjectOutputStream(fos);
		oos.writeObject((StoreObjectConfig) restoredOCfg);

		oos.flush();
		oos.close();
		fos.close();
		ois.close();
		fis.close();
	    }

	} catch (Exception e) {
	    // TODO Auto-generated catch block
	    e.printStackTrace();
	}

    }

    public static StoreObjectConfig getState(boolean restore) {

	FileInputStream fis = null;
	try {
	    if (restore) {
		fis = new FileInputStream(DTUSessionID + "TimeStamp.session");
	    } else {
		fis = new FileInputStream(DTUSessionID + ".session");
	    }

	    ObjectInputStream ois = new ObjectInputStream(fis);

	    StoreObjectConfig restoredOCfg = new StoreObjectConfig();

	    restoredOCfg = (StoreObjectConfig) ois.readObject();
	    ois.close();

	    return restoredOCfg;

	} catch (Exception e) {
	    // TODO Auto-generated catch block
	    e.printStackTrace();
	}
	return null;

    }

    public static ArrayList listFile(String pathname) {
	File f = new File(pathname);
	File[] listfiles = f.listFiles();
	String listing = "";
	ArrayList<String> dList = new ArrayList<String>();
	for (int i = 0; i < listfiles.length; i++) {
	    if (listfiles[i].isDirectory()) {
		File[] internalFile = listfiles[i].listFiles();
		for (int j = 0; j < internalFile.length; j++) {
		    System.out.println(internalFile[j]);
		    listing = (internalFile[j]).toString();
		    dList.add(listing);
		    if (internalFile[j].isDirectory()) {
			String name = internalFile[j].getAbsolutePath();
			System.out.println(name);
			System.out.println("name.split");
			System.out.println(name.split("\\/"));

			listFile(name);

		    }

		}
	    } else {
		System.out.println(listfiles[i]);
	    }

	}

	return dList;
    }

}

final class UploaderRun extends Thread  {

    Vector<String> statusV = new Vector<String>();
    Integer statusI = new Integer(0);
    String sessionID = new String();
    HashMap stateHM = new HashMap<String, String>();
    UploadProc ulp = null;
    String DTUSessionID = new String();
    JMSUploader juldr = null;
    String jmsuldrError = "No Errors";

    public UploaderRun(JMSUploader juldrIN) {
	juldr = juldrIN;
    }

    public String getERRORS() {

	return jmsuldrError;
    }



    public void run() {








	Logger logger = null;
	DTULogger tlg;
	try {
	    logger = DTULogger.getAppLogger("DTU.log");
	} catch (IOException e1) {
	    // TODO Auto-generated catch block
	    e1.printStackTrace();
	}

	try {
	    logger.info("Attempting Connection");
	    juldr.processGUI();

	} catch (Exception e) {
	    System.out.println("exception");
	    // System.out.println(e.getClass().getName());
	    e.printStackTrace();
	    if (e instanceof JMSException) {
		System.out.println("jms connection error");
		logger.info(DTUSessionID+" connection error, check connection ");
		juldr.setRunState(false);
		jmsuldrError = "connection error, check connection ";
		System.out.println("message"+e.getMessage());
		System.out.println("cause"+e.getCause());

		//JOptionPane.showMessageDialog(null,"connection error, check connection", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	if(e.getCause().toString().contains("unable to find valid certification")) {
		//JOptionPane.showMessageDialog(null,"connection error, check connection"+e.getCause() , "Configuration Error", JOptionPane.ERROR_MESSAGE);
		JOptionPane.showMessageDialog(null,"connection error, check keystore", "Configuration Error", JOptionPane.ERROR_MESSAGE);
		} else {
		JOptionPane.showMessageDialog(null,"connection error, check connection", "Configuration Error", JOptionPane.ERROR_MESSAGE);
		}

	    }
	    if (e.toString().contains("Key store not found")) {
		System.out.println("keystore missing ");
		logger.info("Key store not found");
		juldr.setRunState(false);
		jmsuldrError = "Key store not found";
		JOptionPane.showMessageDialog(null,"Key store not found", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("Trust store not found")) {
		System.out.println("truststore missing ");
		logger.info("Trust store not found");
		juldr.setRunState(false);
		jmsuldrError = "Trust store not found";
		JOptionPane.showMessageDialog(null,"Trust store not found", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("File source location")) {
		System.out.println("problem reading file ");
		logger.info("Problem reading data source");
		juldr.setRunState(false);
		jmsuldrError = "Problem reading data source";
		JOptionPane.showMessageDialog(null,"Problem reading data source", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("Number of headers")) {
		System.out.println("negative header number");
		logger.info("Number of headers incorrect");
		juldr.setRunState(false);
		jmsuldrError = "Number of headers incorrect";
		JOptionPane.showMessageDialog(null,"Number of headers incorrect", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("No definition found for splitter")) {
		System.out.println("splitter selection error");
		logger.info("No definition found for splitter");
		juldr.setRunState(false);
		jmsuldrError = "No definition found for splitter";
		JOptionPane.showMessageDialog(null,"No definition found for splitter", "Configuration Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("Invalid keystore format")) {
		System.out.println("Invalid keystore format");
		logger.info("Invalid keystore format");
		juldr.setRunState(false);
		jmsuldrError = "Invalid keystore format";
		JPanel panelPopUp = new JPanel();
		JOptionPane.showMessageDialog(null,"Invalid keystore format", "Configuration Error", JOptionPane.ERROR_MESSAGE);

	    }
	    if (e.toString().contains("File is not a PCAP file")) {
		System.out.println("File is not a PCAP file");
		logger.info("File is not a PCAP file");
		juldr.setRunState(false);
		jmsuldrError = "File is not a PCAP file";
		JOptionPane.showMessageDialog(null,"File is not a PCAP file", "Data Error", JOptionPane.ERROR_MESSAGE);
	    }
	    if (e.toString().contains("String index out of range: -1")) {
		System.out.println("File is not a JSON file");
		logger.info("File is not a JSON file");
		juldr.setRunState(false);
		jmsuldrError = "File is not a JSON file";
		JOptionPane.showMessageDialog(null,"File is not a JSON file", "Data Error", JOptionPane.ERROR_MESSAGE);
	    }



	}
    }
}// end class

final class MonDLQ extends Thread {

    JProgressBar jpb = new JProgressBar();
    JProgressBar jpbS = new JProgressBar();
    JProgressBar jpbBottom = new JProgressBar();
    Vector<String> statusV = new Vector<String>();
    Integer statusI = new Integer(0);
    String statusS = "Upload Reading Configuration";
    // Long statusJ = new Long(0);
    Integer statusJ = new Integer(0);
    String sessionID = new String();
    // JTextArea logAreaB = new JTextArea();
    // JTextArea logAreaB = null;
    JTextPane logAreaB = null;
    JTextPane logAreaMonDLQ = null;
    JMSUploader juldr = null;
    MonDLQ mdlq = null;
    UploadProc upldr = null;
    String logContent = new String();
    JTextField jtf = new JTextField();
    org.apache.log4j.Logger logger = null; 
    volatile boolean runThis = true;
    volatile boolean stopUPLDR = false;
    UploadStatus ulsMon = null;
    DTUmain dtuMainRef = null; 


    public MonDLQ() {
	//System.out.println("mondlq created");
    }

    public void addLogger(Logger loggerIN) {
	// TODO Auto-generated method stub
	logger = loggerIN;
    }

    public void addDTUmainRef(DTUmain dtuMainRefIN) {

	dtuMainRef = dtuMainRefIN;
    }

    public void stopUpldr() {
	stopUPLDR = true;
	runThis = false;
    }

    // public void addLog(JTextArea logArea) {
    public void addLog(JTextPane logArea) {
	logAreaB = logArea;
    }

    public void addLogDLQ(JTextPane logAreaMonDLQIN) {
	logAreaMonDLQ = logAreaMonDLQIN;
    }

    public void addProcessingMon(boolean stopUPLDRIN) {
	stopUPLDR = stopUPLDRIN;
    }

    public Integer getStatusI(JProgressBar jpbIn) {
	jpb = jpbIn;
	System.out.println("getStatusI");
	return statusI;
    }
    public String getStatusS(JProgressBar jpbIn) {
	jpbS = jpbIn;
	//System.out.println("getStatusI");
	return statusS;
    }

    // public Long getStatusJ(JProgressBar jpbBottomIn) {
    public Integer getStatusJ(JProgressBar jpbBottomIn) {
	jpbBottom = jpbBottomIn;
	System.out.println("getStatusJ");
	return statusJ.intValue();
    }

    public String getStatusT(JTextField jtfIn) {
	jtf = jtfIn;
	// jtf.revalidate();
	return logContent;
    }

    // String sessionID = new String();
    public void addSessionID(String sessionIDIn) {
	//sessionID = sessionIDIn;
	sessionID = new String(sessionIDIn);
    }

    public Vector getStatus(Vector vs) {
	return statusV;
    }

    public void addUploadProcRef(UploadProc upldrIN) {
	upldr = upldrIN;
    }

    public void run() {

	//UploadStatus ulsMon = null;

	Logger logger = null;
	DTULogger tlg;
	try {
	    // logger = DTULogger.getAppLogger("/usr/local/src/DTU.log");
	    logger = DTULogger.getAppLogger("DTU.log");
	} catch (IOException e1) {
	    // TODO Auto-generated catch block
	    e1.printStackTrace();
	}

	// /open logfile
	/*
	 * BufferedReader fin = null; try { fin = new BufferedReader(new
	 * FileReader(new File("/usr/local/src/DTU.log"))); } catch
	 * (FileNotFoundException e1) { // TODO Auto-generated catch block
	 * e1.printStackTrace(); } String logLine = null; try { logLine =
	 * logLine+ fin.readLine(); } catch (IOException e1) { // TODO
	 * Auto-generated catch block e1.printStackTrace(); }
	 * 
	 * try { logLine = fin.readLine(); } catch (IOException e1) { // TODO
	 * Auto-generated catch block e1.printStackTrace(); }
	 * System.out.println("THISisHERE"+logLine); ///
	 * logAreaB.append(logLine+"\n"); sb.append(logLine);
	 * logAreaB.setText(sb.toString());
	 * 
	 * logAreaB.validate();
	 */

	// jtf.setText("test");

	//	boolean 
	runThis = true;

	//	File logFile = null;
	BufferedReader fin = null;
	try {
	    // File logFile = new File("/usr/local/src/DTU.log");
	    //				File logFile = new File("DTU.log");
	    File logFile = new File("DTU.log");
	    fin = new BufferedReader(new FileReader(logFile));
	    Long fileSize = logFile.length();

	    if(fileSize > 5000) {
		try {
		    fin.skip(fileSize-100);
		} catch (IOException e) {
		    // TODO Auto-generated catch block
		    e.printStackTrace();
		}
	    }

	} catch (FileNotFoundException e1) {
	    // TODO Auto-generated catch block
	    e1.printStackTrace();
	}
	StringBuffer sb = new StringBuffer();

	String logLine = "Start of log";
	int counter =0;

	boolean firstLoop = true;
	List<TextMessage> dlqList = new CopyOnWriteArrayList<TextMessage>();

	//	while(stopProcessingV.get(SessionNumber))	
	//			{}

	while (runThis) {
	    Random rand = new Random();
	    int n = rand.nextInt(50000) + 1;

	    if(firstLoop) {
		logger.info("logging starting");
	    }
	    if (n > 49900) {
		logger.info("logging active");
	    }

	    firstLoop = false;
	    /*	
		Long fileSize = logFile.length();

		if(fileSize > 5000) {
		try {
		fin.skip(fileSize);
		} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		}
		}	
	    */

	    try {
		Thread.sleep(200);	
		Thread.yield();	
	    } catch (Exception e1) {
		// TODO Auto-generated catch block
		e1.printStackTrace();
	    }




	    //System.out.println("status");

	    if (stopUPLDR) {
		upldr.stopUpldr();
	    }
	    //	logger.info("start logging");
	    /*
	      try {
	      logLine = logLine + fin.readLine();
	      } catch (IOException e1) {
	      // TODO Auto-generated catch block
	      e1.printStackTrace();
	      }
	    */
	    //	logAreaMonDLQ.setText("sfdlkjsfdlkj");
	    try {
		if(fin.readLine() != null) {
		    logLine = fin.readLine();
		    sb.append(logLine + "\n");
		    logAreaB.setText(sb.toString());
		}

	    } catch (IOException e1) {
		// TODO Auto-generated catch block
		e1.printStackTrace();
	    }

	    //sb.append(logLine + "\n");
	    // if (sb.length() > 0) {
	    //logAreaB.setText(sb.toString());
	    // }
	    /*
	      if (sb.length() > 5000) {
	      sb.delete(0, sb.length() / 2);
	      }
	    */

	    //####		
	    logAreaB.setCaretPosition(logAreaB.getText().length() - 10);

	    //dtuMainRef.updateDLQ("dead letter queue messages");
	    //dtuMainRef.updateDLQ("dead letter queue messages"+sessionID+" "+counter);
	    //counter++;

	    if (ulsMon.INSTANCE != null) {
		try {

		    //dtuMainRef.updateDLQ("dead letter queue messages" + ulsMon.INSTANCE.getDeadLetterQueueMessages());




		    if (n > 40000 ) {

			dlqList = ulsMon.INSTANCE.getDeadLetterQueueMessages();
			dtuMainRef.updateDLQ("dead letter queue messages");
			dtuMainRef.updateDLQ( dlqList.get(0).getText());	

			for (TextMessage dlqTM : dlqList) { 
			    String dlqS = dlqTM.getText();
			    dtuMainRef.updateDLQ(dlqS);

			}

		    }

		    //@@@DLQ update	
		    //System.out.println(sessionID + "number of processed files" + ulsMon.INSTANCE.getProcessedFiles());
		    //System.out.println("number of total files" + ulsMon.INSTANCE.getTotalFiles());
		    //System.out.println("dead letter queue messages" + ulsMon.INSTANCE.getDeadLetterQueueMessages());

		    /*	
			SwingUtilities.invokeAndWait(new Runnable()
			{
			@Override
			public void run()
			{
			//		            jtextArea.append("i=" + x);
			logAreaMonDLQ.setText("dead letter queue messages");
			logAreaMonDLQ.setText("dead letter queue messages"+ulsMon.INSTANCE.getDeadLetterQueueMessages());
			System.out.println("DLQinvoke");
			//					logAreaProcDLQ.setText("DLQ");
			}
			});
		    */	    

		    // logArea.append("dead letter queue messages"+ulsMon.INSTANCE.getDeadLetterQueueMessages());
		    // statusV.add("dead letter queue messages"+ulsMon.INSTANCE.getDeadLetterQueueMessages());

		    statusV.add("" + ulsMon.INSTANCE.getProcessedFiles());
		    statusV.add("" + ulsMon.INSTANCE.getTotalFiles());


		    statusI = ulsMon.INSTANCE.getProcessedFiles() * (100 / ulsMon.INSTANCE.getTotalFiles());

		    System.out.println("statusI");
		    System.out.println(statusI);
		    // statusI = statusI + ulsMon.INSTANCE.getTotalFiles();
		    System.out.println(upldr.getJmsUploaderOutput());
		    // jtf.setText(upldr.getJmsUploaderOutput().toString());
		    // jtf.setText(upldr.getJmsUploaderOutput().get(0)+"bytes"+upldr.getJmsUploaderOutput().get(1)+"filesize"+upldr.getJmsUploaderOutput().get(2)+"");

		    // System.out.println(Long.valueOf(upldr.getJmsUploaderLongOutput().get(2))/Long.valueOf(upldr.getJmsUploaderLongOutput().get(1)));

		    if (upldr.getJmsUploaderLongOutput().size() > 1) {
			if (upldr.getJmsUploaderLongOutput().get(1) != 0
			    && upldr.getJmsUploaderLongOutput().get(0) != 0) {
			    // upldr.getJmsUploaderLongOutput().get(1));
			    //System.out.println((upldr .getJmsUploaderLongOutput().get(0) / upldr .getJmsUploaderLongOutput().get(1)) + 200 + "ratio");
			    if( (upldr.getJmsUploaderLongOutput().get(0) / upldr.getJmsUploaderLongOutput().get(1)) > 0) {
				//@@logger.info((sessionID + " " + (upldr.getJmsUploaderLongOutput().get(0) / upldr .getJmsUploaderLongOutput().get(1)) + 200 + "ratio"));
			    }
			    jtf.setText("transmitted " + upldr.getJmsUploaderLongOutput().get(0));
			    Thread.sleep(200);
			    jtf.setText("size " + upldr.getJmsUploaderLongOutput().get(1));

			    if(upldr.getJmsUploaderLongOutput().get(1) != null) {
				//@@logger.info("size " + upldr.getJmsUploaderLongOutput().get(1));
			    }
			    Thread.sleep(200);

			    if (!runThis) {
				jtf.setText("processing complete");
			    }

			    statusJ = ((upldr.getJmsUploaderLongOutput().get(0).intValue() / (upldr .getJmsUploaderLongOutput().get(1) .intValue() / 100)) );
			    //@@logger.info((upldr.getJmsUploaderLongOutput() .get(0).intValue() / (upldr .getJmsUploaderLongOutput().get(1) .intValue() / 100)) - 10);
			    //System.out.println(statusJ);
			}
		    }

		    if(upldr.getJmsUploaderOutput().get(0) != null) {
			//@@logger.info("file " + upldr.getJmsUploaderOutput().get(0));
			jtf.setText("file " + upldr.getJmsUploaderOutput().get(0));
		    }
		    Thread.sleep(50);

		    Thread.sleep(50);
		    upldr.getJmsUploaderOutput().clear();
		    upldr.getJmsUploaderLongOutput().clear();
		    // jtf.setText(logContent);

		    jpb.setValue(statusI);



		    int temp = statusJ.intValue();


		    //@@jpbBottom.setValue(statusJ.intValue());
		    jpbBottom.setValue(temp);

		    Thread.sleep(10);


		    // statusV.add(ulsMon.INSTANCE.getDeadLetterQueueMessages());

		} catch (Exception e) {
		    //System.err.println("Error reading dead letter queue message.  Stopping listener for this connection.");
		    //logger.debug("Error reading dead letter queue");
		}

		// true
	    }

	}
	jpb.setValue(0);
	jpbBottom.setValue(0);
	jpb.setString("Process Complete");
	jpbBottom.setString("Process Complete");

    }
}// end class

final class DTULogger {


    public static Logger getAppLogger(String path) throws IOException {
	Logger rootLogger = Logger.getLogger(DTULogger.class.getCanonicalName());
	Layout pattern = new PatternLayout("%d{MM-dd-yyyy HH:mm:ss,SSS} %m%n");
	// Layout pattern = new PatternLayout("%d{MM-dd-yyyy HH:mm:ss,SSS} %-5p %c:%m%n");
	//Layout pattern = new PatternLayout("%d{MM-dd-yyyy HH:mm:ss} %-5p :%m%n");
	Appender newAppender = null;
	newAppender = new FileAppender(pattern, path, true);
	rootLogger.setAdditivity(false);
	rootLogger.setLevel(Level.INFO);
	rootLogger.addAppender(newAppender);
	return rootLogger;

    }

}

final class UploadProc extends Thread {

    public UploadProc(String action) throws SocketTimeoutException {
    }


    Integer statusJ = new Integer(0);
    JTabbedPane jtpLocalRef = null;
    JProgressBar jpb = null;
    JProgressBar jpbb = null;
    String dataFileLocation = new String();
    ImageIcon sIcon = null;
    String action = null;
    String sessionID = new String();
    Vector<String[][]> dvalV = new Vector<String[][]>();
    StoreObjectConfig configLocal = null;
    Vector<String> jmsupldrOutput = new Vector<String>();
    Vector<Long> jmsupldrLongOutput = new Vector<Long>();
    volatile boolean runThisULP = true;
    String keyStore = null;
    String trustStore = null;
    volatile boolean stopUPLDR = false;
    String errors = "";
    JTextField jtf = new JTextField();
    String logContent = new String();
    Integer sessionNumber = new Integer(0);
    MonDLQ MonDLQ = null;
    DTUelements dtueRef = new DTUelements();
    private static JTextPane logAreaProcDLQ = null;
    Boolean testState = false;
    Long testLong = 0l;
    Long testLongB = 0l;
    String[][] dataValuesLocalTargetHostsB = null;
    String[][] dataValuesLocalDatafilesB = null;


    // static JTabbedPane tabbedPaneLocalRef = null;
    /*
     * public static void addTabRef(JTabbedPane tabbedPaneD, boolean restoreIN)
     * { tabbedPaneLocalRef = tabbedPaneD; }
     */
    public void stopUpldr() {
	stopUPLDR = true;
    }

    public void setDests(String[][] dataValuesTargetHostsIN) {
	dataValuesLocalTargetHostsB =  dataValuesTargetHostsIN;
    }

    public void setData(String[][] dataValuesLocalDatafilesIN) {
	dataValuesLocalDatafilesB = dataValuesLocalDatafilesIN;
    }

    public void setTest(boolean b) {
	testState = b;	
    }

    public void addDTURef(DTUelements dtueRefIN) {

	dtueRef = dtueRefIN;	
    }

    public void addLogDLQ(JTextPane logAreaProcDLQIN) {
	logAreaProcDLQ= logAreaProcDLQIN;
    }


    public String getStatusT(JTextField jtfIn) {
	jtf = jtfIn;
	return logContent;
    }

    public String getStatusS(JProgressBar jpbIn) {
	jpb = jpbIn;
	return logContent;
    }

    public String getStatusSB(JProgressBar jpbInB) {
	jpbb = jpbInB;
	return logContent;
    }
    /*
      public Integer getStatusJ(JProgressBar jpbIn) {
      jpbb = jpbIn;
      //	long tempLong = testLong;
      //	long tempLongB = testLongB;
      //   	jpbb.setValue((tempLong.intValue() / tempLongB.intValue() / 100));
      // 	 return ((tempLong.intValue() / tempLongB.intValue() / 100));
      return statusJ;
      }
    */


    public String getErrors() {
	return errors;
    }

    public void loadConfig(StoreObjectConfig restoredOCfgB) {
	configLocal = restoredOCfgB;
    }

    public void addSessionID(String sessionIDIn, Integer sessionNumberIN) {
	//sessionID = sessionIDIn;
	sessionID = new String(sessionIDIn);
	sessionNumber = sessionNumberIN;
    }

    public void stopProc() {
	runThisULP = false;
    }

    public Vector<String> getJmsUploaderOutput() {
	return jmsupldrOutput;
    }

    public Vector<Long> getJmsUploaderLongOutput() {
	return jmsupldrLongOutput;
    }

    public void addData(String dataFileLocationExt) {
	dataFileLocation = dataFileLocationExt;
    }

    public void addDataValues(String[][] dvals) {
	dvalV.add(dvals);
    }
    /*
      public void addParameterValues(String[][] dvals) {
      dvalV.add(dvals);
      }
    */

    public void addMonDLQProcRef(MonDLQ MonDLQIN) {
	MonDLQ = MonDLQIN;
    }

    public void addStoreLocations(String keyStoreIN, String trustStoreIN) {
	keyStore = keyStoreIN;
	trustStore = trustStoreIN;
    }

    // if(tabbedPaneLocalRef.getComponent(3) != null){
    public void addTabRef(JTabbedPane jtp, ImageIcon extIcon) {
	// public void addTabRef(JTabbedPane jtp, ImageIcon extIcon, boolean
	// restoreIN) {
	jtpLocalRef = jtp;
	sIcon = extIcon;

	


	// restore = restoreIN;
    }

    @SuppressWarnings("deprecation")
	public void run() {

	dtueRef.setStopProcessingHM(sessionNumber.toString(),false);
	Logger logger = null;
	try {

	    JMSUploader juldr = new JMSUploader();
	    // Logger logger = null;
	    DTULogger tlg;
	    try {
		logger = DTULogger.getAppLogger("DTU.log");
	    } catch (IOException e1) {
		// TODO Auto-generated catch block
		e1.printStackTrace();
	    }



	    JTextField warning = new JTextField();

	    //JMSUploader juldr = new JMSUploader();

	    String[][] dataValuesLocalTargetHosts = null; 
	    String[][] dataValuesLocalDatafiles = null;
	    String[][] dataValuesLocalParam = null;
/*
	    String[][] dataValuesLocalTargetHosts = new String[5][5];
	    String[][] dataValuesLocalDatafiles = new String[5][5];
	    String[][] dataValuesLocalParam = new String[5][5];
*/
	    System.out.println("set values StoredObjectConfig");

	    // if(configLocal.getParam(sessionID).length !null) {
	    /*
	     * dataValuesLocalTargetHosts = configLocal.getTargets(sessionID);
	     * dataValuesLocalDatafiles = configLocal.getDatafiles(sessionID);
	     * dataValuesLocalParam = configLocal.getParam(sessionID);
	     */



	    //@@Currently this is pulling from store File, should be pulling from 
	    //last updated copy...

	    dataValuesLocalTargetHosts = configLocal.getTargets("Session");
	    dataValuesLocalDatafiles = configLocal.getDatafiles("Session");


	    dataValuesLocalParam = configLocal.getParam("Session");

	    //@@ may want to do this for above Datafiles and TargetHosts
	    //@@ get Updated params
	    dataValuesLocalParam = dvalV.get(0);


	    //String dests[] = new String[2];
	    logger.info(sessionID+" Reading Destinations");

	    // logger.info((dataValuesLocalTargetHosts[0][1]));


	    //String destsB = new String[strA.size()];


	    Integer adjustedSessionLocationNumber = 0; 
	    int cntrI = jtpLocalRef.getTabCount();
	    int cntrII = 0;
	    while(cntrII < cntrI) {
		String title = jtpLocalRef.getTitleAt(cntrII);	
		if(title.equals(sessionID)) {
		    adjustedSessionLocationNumber=cntrII;
		}
		cntrII++;
	    }



	    Vector<String> targetV = new Vector<String>();	
	    //	int targetCounter = 0;
	    for (String[] strA : dataValuesLocalTargetHostsB) {
		for (String strS : strA) {
		    if (strS != null) {
			strS.replaceAll("(?m)^[ \t]*\r?\n", "");
			if((strS.trim()).length() > 0) { 
			    //dests[targetCounter] = String.valueOf(strS.trim());
			    targetV.add(String.valueOf(strS.trim()));
			    //	targetCounter++;

			}
		    }
		}
	    }

	    int targetCounter = 0;
	    String [] dests = targetV.toArray(new String[1]);	
	    for(String destHost : targetV) {


		TestSettings ts = new TestSettings();
		String testResult = "";
		System.out.println("testSettings");
		if (ts.testNet(61616, destHost)) {
		    testResult = testResult + ("Network Connection Ok,");

		} else {
		    testResult = testResult + ("Network Connection Failure,");
		    JOptionPane.showMessageDialog(null,"Basic Network Connectivity Failure", "Connection Error", JOptionPane.ERROR_MESSAGE);
		    juldr.setRunState(false);
		    logger.info(sessionID+"Netork Connection Failure to"+destHost);

		}

		dests[targetCounter] = destHost;
		targetCounter++;
	    }


	    System.out.println("dests.length");
	    System.out.println(dests.length);

	    //logger.info("dests0" + dests[0]);

	    //@@@
	    //juldr.setRunState(true);
	    //stopUPLDR = false;
	    //runThis = true;
	    //@@@ MONDQL.stopProc .....


	    ArrayList<File> dataFileList = new ArrayList<File>();

	    //juldr.setDestination(dests);
			
	    //for (String[] strA : dataValuesLocalDatafiles) {
	    for (String[] strA : dataValuesLocalDatafilesB) {
		for (String strS : strA) {
		    if (strS != null) {
			System.out.println("datafiles");
			System.out.println(strS);
			//juldr.setFile(new File(strS));
			dataFileList.add(new File(strS));
		    }
		}
	    }

	    if(dataFileList.size() < 1) {
		JOptionPane.showMessageDialog(null,"No Data Files", "Data Error", JOptionPane.ERROR_MESSAGE);

	    }


	    //		for(String fileS : dataFileList) { 

	    //		JMSUploader juldr = new JMSUploader();
	    juldr.setDestination(dests);

	    logger.info(sessionID+"Reading Parameters");
	    Integer counterA = 0;
	    for (String[] strA : dataValuesLocalParam) {
		/*
		  logger.info(dataValuesLocalParam);
		  logger.info(strA +""+ counterA);
		  logger.info(strA[0]);
		  logger.info(strA[1]);
		  counterA++;
		  Integer counter = 0;
		*/
		//				for (String strS : strA) {
		//					if (strS != null) {
		/*
		  System.out.println(strS +""+ counter);
		  counter++;
		  logger.info(strS);
		*/
		if(strA[0] != null && strA[1] != null ) {
		    if (strA[0].equals("input-format")) {
			juldr.setInputFormat(strA[1]);
			//juldr.setInputFormat("Cxx");
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("base64Encode")) {
			// Boolean boolean1 = Boolean.valueOf("true");
			juldr.setBase64Encode((boolean) (Boolean.parseBoolean(strA[1].toLowerCase())));
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("record-format")) {
			juldr.setSplitter(strA[1]);
			//	juldr.setInputFormat(strS);
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("record header lines")) {
			juldr.setNumHeaders((int) (Integer.parseInt(strA[1])));
			//	juldr.setInputFormat(strS);
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("batch size")) {
			juldr.setBatchSize((int) (Integer.parseInt(strA[1])));
			logger.info(sessionID+strA[0]+strA[1]);
		    }

		    if (strA[0].equals("Process Zip Files")) {
			juldr.setProcessZipFiles((boolean) (Boolean.parseBoolean(strA[1].toLowerCase())));
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("listen on DLQ")) {
			juldr.setListenDLQ((boolean) (Boolean.parseBoolean(strA[1].toLowerCase())));
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    if (strA[0].equals("interactive option")) {
			juldr.setInteractive((boolean) (Boolean.parseBoolean(strA[1].toLowerCase())));
			logger.info(sessionID+strA[0]+strA[1]);
		    }
		    /*
		     * if(strA.equals("zipfile option")) {
		     * juldr.setProcessZipFiles
		     * ((boolean)(Boolean.parseBoolean
		     * (strS.toLowerCase()))); System.out.println(strS); }
		     */

		}
	    }


     if(keyStore==null || trustStore==null) {
                JOptionPane.showMessageDialog(null,"Keystore File Not Selected", "Data Error", JOptionPane.ERROR_MESSAGE);
            }




	    juldr.setStoreLocations(new File(keyStore), new File(trustStore));
	    //juldr.setProcessZipFiles(true);

	    if(dataFileLocation != null) {
		logger.info(sessionID+dataFileLocation);
	    }

	    if (testState) {
		juldr.setTestOnly(true);
	    } else {
		juldr.setTestOnly(false);
	    }

	    //juldr.setFile(new File(fileS));
	    juldr.setFile(dataFileList);
	    UploaderRun uldrun = new UploaderRun(juldr);
	    uldrun.start();

	    if (!stopUPLDR) {
		//jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "GREEN"));
		jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "GREEN"));
		//jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "GREEN",sessionNumber));
	    }

	    int filesProcessed = 0;
	    int fileCount = 0; 

	    while (runThisULP) {
		filesProcessed = juldr.getFilesProcessed();
		fileCount = juldr.getFileCount();








		//if ( juldr.getFilesProcessed() == juldr.getFileCount() && juldr.getFileCount() > 0) {
		//if ((filesProcessed == fileCount) && (fileCount > 0)) {
		if(fileCount > 0) {
		    if ((filesProcessed == fileCount) ) {

			Thread.sleep(600);
			//jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "GRAY"));
			jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "GRAY"));




			//Thread.sleep(200);
			stopUPLDR = true;
			MonDLQ.stopUpldr();

			juldr.setRunState(false);
			runThisULP = false;

			dtueRef.stopProcessing = true;
			dtueRef.stopProcessingB = true;
			dtueRef.setStopProcessing(true);
			dtueRef.setStopProcessingHM(sessionID,true);
			Thread.sleep(200);

		    }

		}


		System.out.println("sessionID if(dtueRef.stopProcessingHM.get(sessionID))");
		System.out.println(dtueRef.stopProcessingHM.toString());
		System.out.println(sessionID);



		//if(dtueRef.stopProcessing ) {
		if(dtueRef.stopProcessingHM.get(sessionID)) {
		    //	if(dtueRef.stopProcessingHM.get(sessionNumber.toString())) {
		    System.out.println(dtueRef.stopProcessingHM.toString());
		    System.out.println("dtueRef.stopProcessinHM");
		    System.out.println(dtueRef.stopProcessing);
		    logger.info(sessionID+" shutdown called");
		    Thread.sleep(1000);
		    juldr.setRunState(false);
		    stopUPLDR = true;
		    runThisULP = false;
		    MonDLQ.stopUpldr(); 

		    jpb.setValue(0);
		    jpbb.setValue(0);

		} else {
		    System.out.println(dtueRef.stopProcessingHM.toString());
		    System.out.println("dtueRef.stopProcessinHM");
		    System.out.println("dtueRef.stopProcessing");
		    System.out.println(dtueRef.stopProcessing);
		    System.out.println(runThisULP);
		    System.out.println(stopUPLDR);
		    System.out.println(fileCount);
		    System.out.println(filesProcessed);
		    Thread.sleep(2000);
		}	

		Random rand = new Random();
		int n = rand.nextInt(50000) + 1;

	

		cntrI = jtpLocalRef.getTabCount();
		cntrII = 0;
		while(cntrII < cntrI) {
		    String title = jtpLocalRef.getTitleAt(cntrII);	
		    if(title.equals(sessionID)) {
			adjustedSessionLocationNumber=cntrII;
		    }
		    cntrII++;
		}

		if (n > 30000) {

		    //Integer adjustedSessionLocationNumber = 0; 

		    jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "SLATEBLUE"));
		    //jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "BLUE",adjustedSessionLocationNumber));
		    //	jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "BLUE",sessionNumber));
		}
		if (n < 30000) {

		    jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "GREEN"));
		    //	jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "GREEN", sessionNumber));
		}

		if (stopUPLDR) {
		    juldr.setRunState(false);

		}

		if(uldrun.getERRORS() != "No Errors") {
		    juldr.setRunState(false);
		    jpb.setString(uldrun.getERRORS());
		    jpbb.setString(uldrun.getERRORS());
		    jpb.setStringPainted(true);
		    jpbb.setStringPainted(true);
		    jtf.setText(uldrun.getERRORS());
		    logger.info(sessionID+uldrun.getERRORS());
		    //					dtueRef.disableButtons();
		    //	dtueRef.btnUpload.setEnabled(false);
		    //	dtueRef.btnUpload.setOpaque(true);
		    //	btnTest.setEnabled(false);
		    //	btnTest.setOpaque(true);
		    stopUPLDR = true;
		    runThisULP = false;
		    Thread.sleep(200);
		    MonDLQ.stopUpldr();
                    JOptionPane.showMessageDialog(null,"Test Failed", "Test Complete", JOptionPane.ERROR_MESSAGE);
		} else {
		    logger.info(sessionID+uldrun.getERRORS());
          	//   JOptionPane.showMessageDialog(null,"Test Successful", "Test Complete", JOptionPane.ERROR_MESSAGE);
		}


/*
			if(ulp.getErrors() != "No Errors") {
                JOptionPane.showMessageDialog(null,"Test Failed", "Test Complete", JOptionPane.ERROR_MESSAGE);
			}
			if(ulp.getErrors() == "No Errors") {
                JOptionPane.showMessageDialog(null,"Test Successful", "Test Complete", JOptionPane.ERROR_MESSAGE);
			} 
*/

		// jtpLocalRef.setTabComponentAt(jtpLocalRef.getSelectedIndex(),
		// butTab);
		//if (juldr.getLoaderState().equals("SHUTDOWN"))
		if (juldr.getLoaderState().equals("SHUTDOWN")  )
		    {
			logger.info(sessionID+" uploader shutdown");
			stopUPLDR = true;
			runThisULP = false;
			Thread.sleep(200);
			MonDLQ.stopUpldr();

		    }



		if(juldr.getCurrentlyProcessingFileName() == null) {
		    //	jpb.setString("Upload Startup");
		} else {
		    jpb.setString(juldr.getCurrentlyProcessingFileName());
		}
		//long testLong = 0;
		//long testLongB = 0;
		testLong = juldr.getCurrentlyProcessingFileProcessedBytes();
		testLongB = juldr.getCurrentlyProcessingFileSize();

		System.out.println("testLong");
		System.out.println(testLong);
		System.out.println("testLongB");
		System.out.println(testLongB);



		//jpbb.setValue((testLong.intValue() / testLongB.intValue() / 100));
		if(testLong.intValue() > 0) {
		    statusJ = ((testLong.intValue() / testLongB.intValue() / 100));
		}
		//@@  	jpbb.setValue(statusJ);


		if (testLong > 0 && testLongB > 0) {
		    if (Math.ceil(testLong/1024)>0) {
			DecimalFormat formatter = new DecimalFormat("#,###");
			jpbb.setString(String.valueOf(formatter.format(Math.ceil(testLong/1024)))+" kB" );
			//					jpbb.setString(String.valueOf(Math.ceil(testLong/1024))+" kB" );
		    }

		}

		jmsupldrOutput.clear();
		jmsupldrOutput.add(juldr.getCurrentlyProcessingFileName() + "");
		jmsupldrLongOutput.clear();
		jmsupldrLongOutput.add(juldr
				       .getCurrentlyProcessingFileProcessedBytes());
		jmsupldrLongOutput.add(juldr.getCurrentlyProcessingFileSize());
		System.out.println("......" + jmsupldrLongOutput);

	    }//end while

	    // completed zero out progress bars
	    Thread.sleep(100);	
	    jpb.setValue(0);
	    jpbb.setValue(0);

	    //@@
	    //maybe add check or just log for completion of  
	    System.out.println("done processing line set");

	    //		}//end forloop

	    System.out.println("after procGUI");
	    if (action == "upload") {
		// jtpLocalRef.setIconAt(3, nIcon);
		// jtpLocalRef.setIconAt(Character.getNumericValue(sessionID.charAt(sessionID.length()
		// - 1)) + 1, nIcon);

		//jtpLocalRef.setTabComponentAt(jtpLocalRef.getSelectedIndex(), new ButtonTabComponent(jtpLocalRef, "GRAY",sessionNumber));
		jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "GRAY"));
		// jtpLocalRef.revalidate();
	    }

	    //jtpLocalRef.setTabComponentAt(sessionNumber, new ButtonTabComponent(jtpLocalRef, "GRAY",sessionNumber));
	    jtpLocalRef.setTabComponentAt(adjustedSessionLocationNumber, new ButtonTabComponent(jtpLocalRef, "GRAY"));


	} catch (Exception e) {
	    System.out.println("exception");
	    System.out.println(e.getClass().getName());
	    //logger.info(e.getClass().getName());
	    e.printStackTrace();
	    //logger.info(e.toString());
	    if (e instanceof JMSException) {
		System.out.println("jmsexception");
		//logger.info("jmsexception error, check JMS target ip addressAFTERprocGUI");
		//logger.error("jmsexception error, check JMS target ip addressAFTERprocGUI");
		errors = "jmsexception";
		jtf.setText("jmsexception");
	    }

	    if (e.toString().contains("Key store not found or could not be read atk")) {
		//logger.info("keystore missing");
		//logger.error("keystore missing");
		errors = "keystore missing";
		jtf.setText("keystore missing");

	    }


	}

    }

}// end class

