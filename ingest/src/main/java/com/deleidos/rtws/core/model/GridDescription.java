/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.core.model;

import java.util.Arrays;

import org.apache.log4j.Logger;
import org.geotools.referencing.GeodeticCalculator;

import com.bbn.openmap.LatLonPoint;
import com.bbn.openmap.proj.coords.MGRSPoint;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.PrecisionModel;

public final class GridDescription {
	
	private static final Logger log = Logger.getLogger(GridDescription.class);
	
	/**
	 * Latitudinal zone identifier
	 */
	public static final char[] ZONE_LAT_ARRAY = {
		'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M',
		'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X'
	};
	/**
	 * Longitudinal 100 km square identifier
	 */
	public static final char[] HUNDRED_KM_LON_ARRAY = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 
		'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 
		'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
	};
	/**
	 * Latitudinal 100 km square identifier
	 */
	public static final char[] HUNDRED_KM_LAT_ARRAY = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 
		'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V'
	};
    private static final int GEODETIC_SRID = 8307;
    public static final char INVALID_CHAR = '\u007F';
	
	private int zoneLonCode = -1;
	private char zoneLatCode = INVALID_CHAR;
	private char hundredKmLonCode = INVALID_CHAR;
	private char hundredKmLatCode = INVALID_CHAR;
	private int easting = -1;
	private int northing = -1;
	private GridLayer layer = null;
	private double [] coordinates = null;
	private String name = null;
	private Long gridKey = -1L;

	public GridDescription () {
		super();
	}
	
	/**
	 * Constructor that takes a GridDescription string.
	 * @param gridName The well-formatted GridDescription name
	 * @throws IllegalArgumentException if grid name is invalid 
	 */
	public GridDescription (String gridName) throws IllegalArgumentException {
		super();
		setName(gridName);
	}
	
	/**
	 * Constructor that takes a longitude, latitude, and size (layer) indicator.
	 * @param longitude double decimal degrees within range: -180 to 180
	 * @param latitude double decimal degrees within range: -80 to 84
	 * @param layer GridLayer Enum
	 * @throws IllegalArgumentException if longitude, latitude, or layer are invalid 
	 */
	public GridDescription (double longitude, double latitude, GridLayer layer) throws IllegalArgumentException {
		super();
		String msg = null;
		if (longitude < -180.0 || longitude > 180.0) {
			msg = "longitude must be in the range: -180 <= x <= 180";
			log.warn(msg);
			throw new IllegalArgumentException(msg);
		}
		if (latitude < -80.0 || latitude > 84.0) {
			msg = "latitude must be in the range: -80 <= y <= 84";
			log.warn(msg);
			throw new IllegalArgumentException(msg);
		}
		MGRSPoint mgrs = new MGRSPoint(new LatLonPoint(latitude, longitude));
		mgrs.setAccuracy(MGRSPoint.ACCURACY_1000_METER);
		setLayer(layer);
		setName(mgrs.getMGRS());
	}
	
	/**
	 * Constructor that takes all the component parts of a GridDescription.
	 * @param zoneLon int within range: 1 - 60
	 * @param zoneLat uppercase char within range: C - X, omit I and O
	 * @param hundredKLon uppercase char within range: A - Z, omit I and O
	 * @param hundredKLat uppercase char within range: A - V, omit I and O
	 * @param easting int within range: 0 - 99
	 * @param northing int within range: 0 - 99
	 * @param layer GridLayer Enum
	 * @param coordinates double [10] of alternating lons and lats paired into (x,y) pairs
	 * @throws IllegalArgumentException if any param is invalid
	 */
	public GridDescription (int zoneLon, char zoneLat, char hundredKLon, char hundredKLat, 
			int easting, int northing, GridLayer layer, double...coordinates) throws IllegalArgumentException {
		super();
		setZoneLonCode(zoneLon);
		setZoneLatCode(zoneLat);
		setHundredKmLonCode(hundredKLon);
		setHundredKmLatCode(hundredKLat);
		setLayer(layer);
		setEasting(easting);
		setNorthing(northing);
		setCoordinates(coordinates);
	}

	/**
	 * Gets the grid name from the component parts.  Easting and Northing are set to the anchor point 
	 * of this grid according to the precise location and the GridLayer size.
	 * @return GridDescription name string representation, or null if any component part of the name is invalid.
	 */
	public String getName() {
		
		StringBuilder gridName = new StringBuilder(13); 
		try {
			gridName.append(getMgrsString(layer)).append(getLayer());
			name = gridName.toString();
		} catch (IllegalStateException e) {
			String msg = "one or more grid name components are invalid -- returning null";
			log.error(msg, e);
			return null;
		}
		return name;
	}
	
	/**
	 * Sets the name as well as parsing the name and setting the component parts.
	 * @param gridName The well-formatted GridDescription name.
	 */
	public void setName (String gridName) {

		name = null;
		if (gridName == null || gridName.length() < 8) {
			String msg = "grid name: " + gridName + ", must be well-formatted (ie. \"[#]#CCC####[L###]\")."; 
			log.error(msg);
			throw new IllegalArgumentException(msg);
		}
		
		String easting = null;
		String northing = null;
		
		int index = 0;
		int incr = 1;
		if (Character.isDigit(gridName.charAt(1))) {
			incr = 2;
		}
		
		try {
			setZoneLonCode(gridName.substring(index, index+=incr));
			setZoneLatCode(Character.toUpperCase(gridName.charAt(index++)));
			setHundredKmLonCode(Character.toUpperCase(gridName.charAt(index++)));
			setHundredKmLatCode(Character.toUpperCase(gridName.charAt(index++)));
			easting = gridName.substring(index, index+=2);
			northing = gridName.substring(index, index+=2);
			if (index < gridName.length()) {
				setLayer(gridName.substring(index));
			}
			setEasting(easting);
			setNorthing(northing);
		} catch (Exception e) {
			String msg = "Problem setting grid name from mgrs[" + gridName + "] : one or more properties are invalid";
			log.error(msg, e);
			throw new IllegalArgumentException(msg, e);
		}
		name = gridName;
	}

	public Long getGridKey() {
		return gridKey;
	}

	public void setGridKey(Long gridKey) {
		this.gridKey = gridKey;
	}

	/**
	 * Gets an MGRS string representation of the grid displaying the anchor point determined by 
	 * the GridLayer size, or 1 km if GridLayer is null.
	 * @return mgrsString
	 * @throws IllegalStateException if MGRS name is invalid
	 */
	public String getMgrsString (GridLayer layer) throws IllegalStateException {
		StringBuilder mgrs = new StringBuilder(9);
		try {
			mgrs.append(pad(getZoneLonCode(), 2))
			.append(getZoneLatCode())
			.append(getHundredKmLonCode())
			.append(getHundredKmLatCode());
			if (layer == null) {
				mgrs.append(pad(getEasting(), 2))
				.append(pad(getNorthing(), 2));
			} else {
				int sizeKm = layer.sizeMeters() / 1000;
				mgrs.append(pad((getEasting() - (getEasting() % sizeKm)), 2))
				.append(pad((getNorthing() - (getNorthing() % sizeKm)), 2));
			}
		} catch (IllegalStateException e) {
			String msg = "one or more MGRS string components is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		
		return mgrs.toString();
	}

	/**
	 * Pads value with preceding zero's until number of digits equals len
	 * @param value
	 * @param len
	 * @return
	 */
	private String pad (int value, int len) {
		if (value < 0 || value >= ((int)Math.pow(10, len))) {
			log.warn("invalid pad value: " + value);
			return null;
		}
		String str = Integer.toString(value);
		StringBuilder result = new StringBuilder(len);
		for (int i = 0; i < (len - str.length()); i++) {
			result.append("0");
		}
		result.append(value);
		
		return result.toString();
	}
	
	public int getZoneLonCode() throws IllegalStateException {
		if (zoneLonCode < 1 || zoneLonCode > 60) {
			String msg = "Zone longitude code value is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		} 
		return zoneLonCode;
	}
	
	public void setZoneLonCode(int zoneLon) throws IllegalArgumentException {
		if (zoneLon < 1 || zoneLon > 60) {
			String msg = "Zone longitude code must be a positive 1- or 2-digit integer from [0]1 - 60.";
			log.error(msg);
			this.zoneLonCode = -1;
			throw new IllegalArgumentException(msg);
		}
		this.zoneLonCode = zoneLon;
	}
	
	public void setZoneLonCode(String zoneLon) throws IllegalArgumentException {
		try {
			setZoneLonCode(Integer.parseInt(zoneLon));			
		} catch (Exception e) {
			String msg = "Zone longitude code must be a positive 1- or 2-digit integer from [0]1 - 60.";
			log.error(msg, e);
			this.zoneLonCode = -1;
			throw new IllegalArgumentException(msg, e);
		}
	}
	
	public char getZoneLatCode() throws IllegalStateException {
		if (indexOfCharArray(zoneLatCode, ZONE_LAT_ARRAY) < 0) {
			String msg = "Zone latitude code value is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return zoneLatCode;
	}
	
	public void setZoneLatCode(char zoneLat) throws IllegalArgumentException {
		if (indexOfCharArray(zoneLat, ZONE_LAT_ARRAY) < 0) {
			String msg = "Zone latitude code must be an upper-case character: C - X (excluding I & O)"; 
			log.error(msg);
			this.zoneLatCode = INVALID_CHAR;
			throw new IllegalArgumentException(msg);
		}
		this.zoneLatCode = zoneLat;
	}
	
	public char getHundredKmLonCode() throws IllegalStateException {
		if (indexOfCharArray(hundredKmLonCode, HUNDRED_KM_LON_ARRAY) < 0) {
			String msg = "Hundred Km longitude code is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return hundredKmLonCode;
	}
	
	public void setHundredKmLonCode(char hundredKLon) throws IllegalArgumentException {
		if (indexOfCharArray(hundredKLon, HUNDRED_KM_LON_ARRAY) < 0) {
			String msg = "Hundred Km longitude code must be an upper-case character: A - Z (excluding I & O)";
			log.error(msg);
			this.hundredKmLonCode = INVALID_CHAR;
			throw new IllegalArgumentException(msg);
		}
		this.hundredKmLonCode = hundredKLon;
	}
	
	public char getHundredKmLatCode() throws IllegalStateException {
		if (indexOfCharArray(hundredKmLatCode, HUNDRED_KM_LAT_ARRAY) < 0) {
			String msg = "Hundred Km latitude code is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return hundredKmLatCode;
	}
	
	public void setHundredKmLatCode(char hundredKLat) throws IllegalArgumentException {
		if (indexOfCharArray(hundredKLat, HUNDRED_KM_LAT_ARRAY) < 0) {
			String msg = "Hundred Km latitude code must be an upper-case character: A - V (excluding I & O)";
			log.error(msg);
			this.hundredKmLatCode = INVALID_CHAR;
			throw new IllegalArgumentException(msg);
		}
		this.hundredKmLatCode = hundredKLat;
	}

	/**
	 * Kilometres east of western boundary of 100km grid, in increments of GridLayer size in km.
	 * @return int easting
	 * @throws IllegalStateException if easting is not within valid range
	 */
	public int getEasting() throws IllegalStateException {
		if (easting < 0 || easting > 99) {
			String msg = "Easting value is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return easting;
	}
	
	/**
	 * Easting is truncated to the GridLayer size in kilometres.
	 * @param easting Easting
	 * @throws IllegalArgumentException if easting is not within valid range
	 */
	public void setEasting(int easting) throws IllegalArgumentException {
		if (easting < 0 || easting > 99) {
			String msg = "Easting must be a 2-digit integer from 00 - 60";
			log.error(msg);
			this.easting = -1;
			throw new IllegalArgumentException(msg);
		}
		int kmLayerSize = easting;
		if (layer != null) {
			kmLayerSize = layer.sizeMeters() / 1000;
		}
		this.easting = (easting - (easting % kmLayerSize));
	}
	
	/**
	 * Set easting.
	 * @param easting Easting
	 * @throws IllegalArgumentException if easting not a parsable integer
	 */
	public void setEasting(String easting) throws IllegalArgumentException {
		try {
			setEasting(Integer.parseInt(easting));
		} catch (Exception e) {
			String msg = "Easting must be a 2-digit integer from 00 - 60";
			log.error(msg, e);
			this.easting = -1;
			throw new IllegalArgumentException(msg, e);
		}
	}
	
	/**
	 * Kilometres north of southern boundary of 100km grid, in increments of GridLayer size in km.
	 * @return int northing
	 * @throws IllegalStateException if northing is not within valid range
	 */
	public int getNorthing() throws IllegalStateException {
		if (northing < 0 || northing > 99) {
			String msg = "Northing value is invalid";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return northing;
	}
	
	/**
	 * Northing is truncated to the GridLayer size in kilometres.
	 * @param northing Northing
	 * @throws IllegalArgumentException if northing is not within valid range
	 */
	public void setNorthing(int northing) throws IllegalArgumentException {
		if (northing < 0 || northing > 99) {
			String msg = "Northing must be a 2-digit integer from 00 - 60";
			log.error(msg);
			this.northing = -1;
			throw new IllegalArgumentException(msg);
		}
		int kmLayerSize = northing;
		if (layer != null) {
			kmLayerSize = layer.sizeMeters() / 1000;
		}
		this.northing = (northing - (northing % kmLayerSize));
	}
	
	/**
	 * Set northing.
	 * @param northing Northing
	 * @throws IllegalArgumentException if northing not a parsable integer
	 */
	public void setNorthing(String northing) throws IllegalArgumentException {
		try {
			setNorthing(Integer.parseInt(northing));
		} catch (Exception e) {
			String msg = "northing must be a 2-digit integer from 00 - 60";
			log.error(msg, e);
			this.northing = -1;
			throw new IllegalArgumentException(msg, e);
		}
	}
	
	public GridLayer getLayer() throws IllegalStateException {
		if (layer == null) {
			String msg = "GridLayer value is invalid: null";
			log.error(msg);
			throw new IllegalStateException(msg);
		}
		return layer;
	}
	
	public int getLayerSizeMeters () {
		int layerSizeMeters = 0;
		if (layer != null) {
			layerSizeMeters = layer.sizeMeters();
		}
		return layerSizeMeters;
	}
	
	public void setLayer(GridLayer layer) throws IllegalArgumentException {
		if (layer == null) {
			String msg = "Grid layer must be one of GridLayer.L100, .L050, .L020, .L010, or .L005";
			log.error(msg);
			throw new IllegalArgumentException(msg);
		}
		this.layer = layer;
	}
	
	public void setLayer(String layer) throws IllegalArgumentException {
			try {
				setLayer(GridLayer.valueOf(layer));
			} catch (IllegalArgumentException e) {
				String msg = "Grid layer must be one of GridLayer.L100, .L050, .L020, .L010, or .L005";
				log.error(msg, e);
				throw new IllegalArgumentException(msg, e);
			}
	}
	
	/**
	 * Tests whether a square GridDescription intersects an MBR defined by the given ordinates.  Grids
	 *  can overlap zone boundaries, so while a larger grid may intersect the zone, a smaller grid within
	 *   the larger grid might not intersect the zone.
	 * @param minLon The western-most longitude of the MBR
	 * @param minLat The southern-most latitude of the MBR
	 * @param maxLon The eastern-most longitude of the MBR
	 * @param maxLat The northern-most latitude of the MBR
	 * @return true if grid intersects the MBR defined by the given ordinates
	 */
	public boolean isGridInMBR (double minLon, double minLat, double maxLon, double maxLat) {
		
	    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(), GEODETIC_SRID);
	    
    	if (minLon < -180 || minLon > 180 || maxLon < -180 || maxLon > 180) {
    		StringBuilder msg = new StringBuilder("longitude not in range: -180 <= x <= 180 -- minLon = ")
    			.append(minLon).append("; maxLon = ").append(maxLon);
    		log.warn(msg);
	    	throw new IllegalArgumentException(msg.toString());
    	}
    	
    	if (minLat < -90 || minLat > 90 || maxLat < -90 || maxLat > 90) {
    		StringBuilder msg = new StringBuilder("latitude not in range: -90 <= y <= 90 -- minLat = ")
    			.append(minLat).append("; maxLat = ").append(maxLat);
    		log.warn(msg);
	    	throw new IllegalArgumentException(msg.toString());
    	}
    	
    	if (((minLon - maxLon) < 180) && (minLon > maxLon)) {
    		double temp = minLon;
    		minLon = maxLon;
    		maxLon = temp;
    	}
    	
    	if (minLat > maxLat) {
    		double temp = minLat;
    		minLat = maxLat;
    		maxLat = temp;
    	}
    	
	    Coordinate[] mbrCoordinates = new Coordinate [5];
    	mbrCoordinates[0] = new Coordinate(minLon, minLat);
    	mbrCoordinates[1] = new Coordinate(maxLon, minLat);
    	mbrCoordinates[2] = new Coordinate(maxLon, maxLat);
    	mbrCoordinates[3] = new Coordinate(minLon, maxLat);
    	mbrCoordinates[4] = new Coordinate(minLon, minLat);
	    Geometry mbrGeo = geometryFactory.createPolygon(geometryFactory.createLinearRing(mbrCoordinates), null);

	    double [] gridOrdinates = getCoordinates();
	    if (gridOrdinates == null || gridOrdinates.length != 10) {
	    	return false;
	    }
	    
	    Coordinate [] gridCoordinates = new Coordinate [gridOrdinates.length / 2];
	    for (int i = 0, j = 0; i < gridCoordinates.length; i++, j+=2) {
	    	gridCoordinates[i] = new Coordinate(gridOrdinates[j], gridOrdinates[j+1]);
	    }
	    Geometry gridGeo = geometryFactory.createPolygon(geometryFactory.createLinearRing(gridCoordinates), null);
	    
		return gridGeo.intersects(mbrGeo);
	}

	/**
	 * Tests whether a square BestFitGrid intersects its given zone.  Grids can overlap zone boundaries,
	 *  so while a larger grid may intersect the zone, a smaller grid within the larger grid may not 
	 *  intersect the zone.
	 * @return true if grid intersects its given zone
	 */
	public boolean isGridInZone () {
		
	    double [] zoneOrdinates = getZoneCoordinates();
	    if (zoneOrdinates == null) {
	    	log.error("Error getting zone coordinates for BestFitGrid: " + this.getName());
	    	return false;
	    }

	    return isGridInMBR(zoneOrdinates[0], zoneOrdinates[1], zoneOrdinates[4], zoneOrdinates[5]);
	}

	/**
	 * Returns the ordinates that define the grid's given zone.  This is primarily useful 
	 *  for determining if a GridDescription intersects its given zone.
	 * @return double [] set of ordinates
	 */
	public double [] getZoneCoordinates() {
		
		double minLon = zoneLonCode * 6 - 186;
		double maxLon = minLon + 5.9999999;

		int zoneLatIndex = indexOfCharArray(zoneLatCode, ZONE_LAT_ARRAY);
		if (zoneLatIndex == -1) return null;
		double minLat = (zoneLatIndex - 10) * 8;
		double maxLat = minLat + 7.9999999;
		
		if (zoneLatCode == 'X') {
			maxLat += 4;
			if (zoneLonCode == 31) {
				maxLon += 3;
			}
			else if (zoneLonCode == 33 || zoneLonCode == 35) {
				minLon -= 3;
				maxLon += 3;
			}
			else if (zoneLonCode == 37) {
				minLon -= 3;
			}
			else if (zoneLonCode == 32 || zoneLonCode == 34 || zoneLonCode == 36) {
				return null;
			}
		}
		else if (zoneLatCode == 'V') {
			if (zoneLonCode == 31) {
				maxLon -= 3;
			}
			else if (zoneLonCode == 32) {
				minLon -= 3;
			}
		}
		
		double [] zoneCoordinates = {minLon, minLat, maxLon, minLat, maxLon, maxLat, minLon, maxLat, minLon, minLat};

		return zoneCoordinates;
	}

	/**
	 * Returns the ordinates that define the size and location of this GridDescription.
	 * @return double [] set of ordinates
	 */
	public double [] getCoordinates() {

		if (coordinates == null || coordinates.length != 10) {
			coordinates = new double [10];
		}
		
		int gridSize = layer.sizeMeters();
		int tempEasting = easting * 1000;
		int tempNorthing = northing * 1000;
		StringBuilder mgrsString = new StringBuilder(15).append(getMgrsString(null));
		
		// SW coordinate
		MGRSPoint m = new MGRSPoint(mgrsString.toString());
		coordinates[0] = m.toLatLonPoint().getLongitude(); 
		coordinates[1] = m.toLatLonPoint().getLatitude();
		
		// SE coordinate
		tempEasting += gridSize;
		if (tempEasting > 99999) {
			tempEasting = 99999;
		}
		mgrsString.delete(5, mgrsString.length()).append(pad(tempEasting, 5)).append( pad(tempNorthing, 5));
		m = new MGRSPoint(mgrsString.toString());
		coordinates[2] = m.toLatLonPoint().getLongitude();
		coordinates[3] = m.toLatLonPoint().getLatitude();
		
		// NE coordinate
		tempNorthing += gridSize;
		if (tempNorthing > 99999) {
			tempNorthing = 99999;
		}
		mgrsString.delete(5, mgrsString.length()).append(pad(tempEasting, 5)).append( pad(tempNorthing, 5));
		m = new MGRSPoint(mgrsString.toString());
		coordinates[4] = m.toLatLonPoint().getLongitude();
		coordinates[5] = m.toLatLonPoint().getLatitude();
		
		// NW coordinate
		tempEasting = easting * 1000;
		mgrsString.delete(5, mgrsString.length()).append(pad(tempEasting, 5)).append( pad(tempNorthing, 5));
		m = new MGRSPoint(mgrsString.toString());
		coordinates[6] = m.toLatLonPoint().getLongitude();
		coordinates[7] = m.toLatLonPoint().getLatitude();

		// repeat SW coordinate for sdo_geometry closed loop
		coordinates[8] = coordinates[0];
		coordinates[9] = coordinates[1];
		
		if (!validateCoordinates(layer, coordinates)) {
			coordinates = null;
		}
		
		return coordinates;
	}
	
	public void setCoordinates(double...coordinates) {
		if (coordinates != null && coordinates.length == 10) {
			this.coordinates = coordinates;
		}
	}

	/**
	 * Ensures that the coordinates represent a grid of layer.sizeMeters. 
	 * @return true if coordinates represent a valid grid, false otherwise.
	 */
	private boolean validateCoordinates(GridLayer layer, double ... coordinates) {
		boolean valid = true;
		
		// Ensure begin equals end points
		valid &= coordinates[0] == coordinates[8];
		valid &= coordinates[1] == coordinates[9];
		
		// Ensure N > S
		valid &= coordinates[5] > coordinates[1];
		valid &= coordinates[5] > coordinates[3];
		valid &= coordinates[7] > coordinates[1];
		valid &= coordinates[7] > coordinates[3];
		
		// Ensure E > W  (NOTE: if line between longitudes crosses the antemeridian, ensure W > E)
		if (coordinates[0] - coordinates[2] > 180) {
			valid &= coordinates[0] > coordinates[2];
		} else {
			valid &= coordinates[2] > coordinates[0];
		}
		if (coordinates[6] - coordinates[4] > 180) {
			valid &= coordinates[6] > coordinates[4];
		} else {
			valid &= coordinates[4] > coordinates[6]; 
		}
		
		// Ensure point-to-point distances are within the tolerance range for the given layer size in meters
		// Ensure point-to-point azimuths are generally correct  (NOTE: grid sides are not necessarily parallel
		//		to lines of longitude and latitude)
		int size = layer.sizeMeters();
		int sizeTolerance = size / 100;
		int azimuthTolerance = 15;
		GeodeticCalculator geoCalc = new GeodeticCalculator();
		try {
			// sw to se
			geoCalc.setStartingGeographicPoint(coordinates[0], coordinates[1]);
			geoCalc.setDestinationGeographicPoint(coordinates[2], coordinates[3]);
			valid &= Math.abs(size - geoCalc.getOrthodromicDistance()) < sizeTolerance;
			valid &= Math.abs(90 - geoCalc.getAzimuth()) < azimuthTolerance;
			// se to ne
			geoCalc.setStartingGeographicPoint(geoCalc.getDestinationGeographicPoint());
			geoCalc.setDestinationGeographicPoint(coordinates[4], coordinates[5]);
			valid &= Math.abs(size - geoCalc.getOrthodromicDistance()) < sizeTolerance;
			valid &= Math.abs(geoCalc.getAzimuth()) < azimuthTolerance;
			// ne to nw
			geoCalc.setStartingGeographicPoint(geoCalc.getDestinationGeographicPoint());
			geoCalc.setDestinationGeographicPoint(coordinates[6], coordinates[7]);
			valid &= Math.abs(size - geoCalc.getOrthodromicDistance()) < sizeTolerance;
			valid &= Math.abs(-90 - geoCalc.getAzimuth()) < azimuthTolerance;
			// nw to sw
			geoCalc.setStartingGeographicPoint(geoCalc.getDestinationGeographicPoint());
			geoCalc.setDestinationGeographicPoint(coordinates[8], coordinates[9]);
			valid &= Math.abs(size - geoCalc.getOrthodromicDistance()) < sizeTolerance;
			valid &= (180 - Math.abs(geoCalc.getAzimuth())) < azimuthTolerance;
		} catch (Exception e) {
			valid = false;
			log.warn(this.getName() + " -- " + Arrays.toString(coordinates), e);
		}
		
		return valid;
	}

	/**
	 * Returns the index of the given character in the given array.
	 * @param ch character to find in array
	 * @param array in which to search for character
	 * @return int index of character, or -1 if it does not exist in array
	 */
	public int indexOfCharArray (char ch, char...array) {

		if (array == null || array.length < 1) {
			log.error("Null or empty array");
			return -1;
		}
		
		int index = (int) (ch - array[0]);
		
		if ((int) ch > 'I') {
			index -= 1;
		}
		if ((int) ch > 'O') {
			index -= 1;
		}
		
		if (index >= array.length || array[index] != (int) ch) {
			index = -1;
			log.error("Error getting index of '" + ch + "' from character array: " + new String(array));
		}
		
		return index;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		
		if (obj == null) return false;
		
		if (obj instanceof GridDescription) {
			return this.getName().equals(((GridDescription) obj).getName());
		}
			
		return false;
		
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return this.getName().hashCode();
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return this.getName();
	}
	
}
