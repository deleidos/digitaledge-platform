/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.commons.cloud.platform.aws;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.services.ec2.AmazonEC2Client;
import com.amazonaws.services.ec2.model.Address;
import com.amazonaws.services.ec2.model.AllocateAddressRequest;
import com.amazonaws.services.ec2.model.AssociateAddressRequest;
import com.amazonaws.services.ec2.model.AttachVolumeRequest;
import com.amazonaws.services.ec2.model.AttachVolumeResult;
import com.amazonaws.services.ec2.model.AuthorizeSecurityGroupIngressRequest;
import com.amazonaws.services.ec2.model.AvailabilityZone;
import com.amazonaws.services.ec2.model.CreateSecurityGroupRequest;
import com.amazonaws.services.ec2.model.CreateSecurityGroupResult;
import com.amazonaws.services.ec2.model.CreateSnapshotRequest;
import com.amazonaws.services.ec2.model.CreateSnapshotResult;
import com.amazonaws.services.ec2.model.CreateTagsRequest;
import com.amazonaws.services.ec2.model.CreateVolumeRequest;
import com.amazonaws.services.ec2.model.CreateVolumeResult;
import com.amazonaws.services.ec2.model.DeleteSecurityGroupRequest;
import com.amazonaws.services.ec2.model.DeleteSnapshotRequest;
import com.amazonaws.services.ec2.model.DeleteVolumeRequest;
import com.amazonaws.services.ec2.model.DescribeAddressesRequest;
import com.amazonaws.services.ec2.model.DescribeAddressesResult;
import com.amazonaws.services.ec2.model.DescribeAvailabilityZonesResult;
import com.amazonaws.services.ec2.model.DescribeInstanceAttributeRequest;
import com.amazonaws.services.ec2.model.DescribeInstanceAttributeResult;
import com.amazonaws.services.ec2.model.DescribeInstancesRequest;
import com.amazonaws.services.ec2.model.DescribeInstancesResult;
import com.amazonaws.services.ec2.model.DescribeRegionsResult;
import com.amazonaws.services.ec2.model.DescribeSecurityGroupsResult;
import com.amazonaws.services.ec2.model.DescribeSnapshotsResult;
import com.amazonaws.services.ec2.model.DescribeVolumesRequest;
import com.amazonaws.services.ec2.model.DescribeVolumesResult;
import com.amazonaws.services.ec2.model.DetachVolumeRequest;
import com.amazonaws.services.ec2.model.DisassociateAddressRequest;
import com.amazonaws.services.ec2.model.Filter;
import com.amazonaws.services.ec2.model.Instance;
import com.amazonaws.services.ec2.model.InstanceBlockDeviceMapping;
import com.amazonaws.services.ec2.model.InstanceStateName;
import com.amazonaws.services.ec2.model.IpPermission;
import com.amazonaws.services.ec2.model.ModifyImageAttributeRequest;
import com.amazonaws.services.ec2.model.ModifyInstanceAttributeRequest;
import com.amazonaws.services.ec2.model.Placement;
import com.amazonaws.services.ec2.model.Region;
import com.amazonaws.services.ec2.model.ReleaseAddressRequest;
import com.amazonaws.services.ec2.model.Reservation;
import com.amazonaws.services.ec2.model.RevokeSecurityGroupIngressRequest;
import com.amazonaws.services.ec2.model.RunInstancesRequest;
import com.amazonaws.services.ec2.model.RunInstancesResult;
import com.amazonaws.services.ec2.model.SecurityGroup;
import com.amazonaws.services.ec2.model.StartInstancesRequest;
import com.amazonaws.services.ec2.model.StopInstancesRequest;
import com.amazonaws.services.ec2.model.Tag;
import com.amazonaws.services.ec2.model.TerminateInstancesRequest;
import com.amazonaws.services.ec2.model.UserIdGroupPair;
import com.amazonaws.services.ec2.model.VolumeAttachment;
import com.jcabi.aspects.RetryOnFailure;
import com.deleidos.rtws.commons.cloud.IntrospectionClient;
import com.deleidos.rtws.commons.cloud.ProcessState;
import com.deleidos.rtws.commons.cloud.beans.FirewallGroup;
import com.deleidos.rtws.commons.cloud.beans.FirewallGroupSource;
import com.deleidos.rtws.commons.cloud.beans.FirewallIpRangeSource;
import com.deleidos.rtws.commons.cloud.beans.FirewallRule;
import com.deleidos.rtws.commons.cloud.beans.Process;
import com.deleidos.rtws.commons.cloud.beans.ProcessDefinition;
import com.deleidos.rtws.commons.cloud.beans.Snapshot;
import com.deleidos.rtws.commons.cloud.beans.State;
import com.deleidos.rtws.commons.cloud.beans.Volume;
import com.deleidos.rtws.commons.cloud.beans.vpc.NetworkACL;
import com.deleidos.rtws.commons.cloud.beans.vpc.PortRange;
import com.deleidos.rtws.commons.cloud.beans.vpc.RouteTable;
import com.deleidos.rtws.commons.cloud.beans.vpc.Subnet;
import com.deleidos.rtws.commons.cloud.beans.vpc.Vpc;
import com.deleidos.rtws.commons.cloud.exception.TimeoutException;
import com.deleidos.rtws.commons.cloud.platform.ServiceInterface;
import com.deleidos.rtws.commons.config.UserDataProperties;
import com.deleidos.rtws.commons.util.regex.Internet;

/**
 * A basic implementation of the ServiceInterface using the aws-java-sdk. It
 * provides a common wrapper to invoke the AWS functions for creating, starting,
 * stopping and destroying AMI instances.
 */
public class SimpleAwsServiceImpl implements ServiceInterface {

	private static final String DEFAULT_DEVICE_PREFIX = "/dev/sdf";
	
	private static final String availabilityState = "available";

	/** The connection factory being used to access the Amazon services API. */
	protected AwsConnectionFactory factory = null;

	/** Utility used to discover an AMI instances own properties. */
	protected IntrospectionClient introspectionClient = new IntrospectionClient();

	/**
	 * The maximum amount of time any command should wait for an API request to
	 * complete.
	 */
	protected long timeout = 24 * 60 * 1000;

	private static Logger log = Logger.getLogger(SimpleAwsServiceImpl.class);

	/**
	 * Constructor.
	 */
	public SimpleAwsServiceImpl() {
		super();
	}

	/**
	 * Returns the connection factory being used to access EC2 services.
	 */
	public AwsConnectionFactory getConnectionFactory() {
		return factory;
	}

	/**
	 * Sets the connection factory that should be used to access EC2 services.
	 */
	public void setConnectionFactory(AwsConnectionFactory value) {
		factory = value;
	}

	/**
	 * Gets the maximum time to wait for any service call to complete.
	 */
	public long getTimeout() {
		return timeout;
	}

	/**
	 * Sets the maximum time to wait for any service call to complete.
	 */
	public void setTimeout(long value) {
		timeout = value;
	}

	/**
	 * Returns a process object that describes AMI instance that this JVM is
	 * currently running within.
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	public Process self() {
		return self(new Process());
	}

	/**
	 * Returns a process object that describes AMI instance that this JVM is
	 * currently running within.
	 * 
	 * @param process
	 *            A process that has already been created.
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	public Process self(Process process) {
		try {
			describeInstance(factory.getAmazonEC2Client(),
					introspectionClient.getId(), process);
			return process;
		} catch (IOException e) {
			throw new AmazonClientException(
					"Unable to connect to AWS loopback address.", e);
		}
	}

	/**
	 * Return the current state of the given process; update process with any
	 * new address values.
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	public ProcessState status(Process process) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		String state = null;
		try {
			state = describeInstance(client, process.getId(), process);
		} catch (AmazonServiceException e) {
			// Assume that the given process does not exist.
			log.debug(e.getMessage(), e);
		}

		log.debug("process: " + process.getPersistentDnsName() + " state:"
				+ state);

		if (state == null) {
			return ProcessState.UNKNOWN;
		} else if (state.equals("pending")) {
			return ProcessState.RUNNING;
		} else if (state.equals("running")) {
			return ProcessState.RUNNING;
		} else if (state.equals("rebooting")) {
			return ProcessState.RUNNING;
		} else if (state.equals("stopping")) {
			return ProcessState.STOPPED;
		} else if (state.equals("stopped")) {
			return ProcessState.STOPPED;
		} else if (state.equals("shutting-down")) {
			return ProcessState.UNKNOWN;
		} else if (state.equals("terminated")) {
			return ProcessState.UNKNOWN;
		} else {
			return ProcessState.UNKNOWN;
		}

	}

	@Override
	public String getUserData(String id) {

		try
		{
		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstanceAttributeResult result = client
				.describeInstanceAttribute(new DescribeInstanceAttributeRequest(
						id, "userData"));

		String userdata = result.getInstanceAttribute().getUserData();
		if (userdata == null) {
			userdata = "";
		}

		return new String(Base64.decodeBase64(userdata));
		} catch (Exception ex)
		{
			// TODO REMOVE THIS ONCE EUCA SUPPORTS describeInstanceAttribute (not in as of 3.4)
			String userdata = String.format("%s=%s;", UserDataProperties.RTWS_SW_VERSION, UserDataProperties.getInstance().getString(UserDataProperties.RTWS_SW_VERSION));
			
			return userdata;
		}
		

	}

	@Override
	public void setUserData(String id, String userData) {

		ModifyInstanceAttributeRequest request = new ModifyInstanceAttributeRequest();
		request.setInstanceId(id);
		request.setAttribute("userData");
		request.setValue(Base64.encodeBase64String(userData.getBytes()));

		AmazonEC2Client client = factory.getAmazonEC2Client();
		client.modifyInstanceAttribute(request);

	}

	@Override
	public List<String> getAvailabilityZones() {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeAvailabilityZonesResult result = client
				.describeAvailabilityZones();

		ArrayList<String> azones = new ArrayList<String>();
		for (AvailabilityZone zone : result.getAvailabilityZones()) {
			azones.add(zone.getZoneName());
		}

		return azones;

	}

	@Override
	public Map<String, List<String>> getRegionAzoneMapping() {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeRegionsResult regionResult = client.describeRegions();

		HashMap<String, List<String>> holder = new HashMap<String, List<String>>();
		for (Region region : regionResult.getRegions()) {
			client.setEndpoint(region.getEndpoint());

			try {
				DescribeAvailabilityZonesResult azoneResult = client
						.describeAvailabilityZones();
				ArrayList<String> azones = new ArrayList<String>();
				for (AvailabilityZone zone : azoneResult.getAvailabilityZones()) {
					azones.add(zone.getZoneName());
				}

				holder.put(region.getRegionName(), azones);
			} catch (AmazonClientException ignore) {
				// This will always happen in Eucalyptus, so let's not log
				// anything please
			}
		}

		return holder;

	}

	/**
	 * Create (and starts) a new AMI instance based on the given template.
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	@Override
	public String create(ProcessDefinition template) {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		return runInstance(client, template);

	}

	/**
	 * Creates (and starts) a new AMI instance based on the given template. Also
	 * re-attaches any storage devices listed for the process.
	 * @throws Exception 
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	public void create(ProcessDefinition template, Process process) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		String id = null;
		String assignedPersistentIpAddress = null;
		String templatePersistentIpAddress = null;
		String previousPersistentIpAddress = null;
		Volume[] volumes = null;
		boolean rollbackOnError = false;

		try {

			volumes = process.getVolumes();

			// If the template needs volumes, create or retreive them.
			if (template.getVolumeCount() > 0) {
				volumes = createOrRetrieveVolumes(client, template, volumes);
				process.setVolumes(volumes);
				rollbackOnError = true;
			}
			if (volumes != null) {
				template.getProperties().put("RTWS_RAID_DEVICES",
						buildDeviceList(volumes));
			}

			id = runInstance(client, template);
			waitForStateTransition(client, id, "running", timeout, false);

			// Attach the volumes which were created or retrieved earlier.
			if ((volumes != null) && (template.getVolumeCount() > 0)) {
				attachVolumes(client, id, volumes);
			}

			if (template.getAllocatePersistentAddress()) {
				// Get the assigned persistent ip address from services.xml
				templatePersistentIpAddress = template.getPersistentIpAddress();
				// Get the persistent ip address from processes.xml
				previousPersistentIpAddress = process.getPersistentIpAddress();
				// Determine the assigned persistent IP address.
				assignedPersistentIpAddress = determinePersistentIpAddress(
						previousPersistentIpAddress,
						templatePersistentIpAddress);
				// May need to deallocate IP address
				disassocaitePreviousIpAddressIfNecessary(client,
						previousPersistentIpAddress,
						templatePersistentIpAddress);
				// If there is not one specified, then allocate an elastic ip.
				if (assignedPersistentIpAddress == null) {
					assignedPersistentIpAddress = allocateAddress(client, process);
				}
				// Associate the new Elastic IP address.
				associateAddress(client, id, assignedPersistentIpAddress);
				process.setPersistentIpAddress(assignedPersistentIpAddress);
				rollbackOnError = true;
			}

			process.setAllocateInternetAddress(template
					.getAllocateInternetAddress());
			process.setInternetAddress(template.getInternetAddress());
			describeInstance(client, id, process);

		} catch (AmazonServiceException e) {
			if (id != null)
				try {
					log.error("Error in creating process: " + e.getMessage());
					terminateInstance(client, id);
				} catch (Exception ignore) {
				}
			if (rollbackOnError) {
				if (assignedPersistentIpAddress != null)
					try {
						disassociateAddress(client, assignedPersistentIpAddress);
					} catch (Exception ignore) {
					}
				if (volumes != null)
					try {
						deleteVolumes(client, volumes);
					} catch (Exception ignore) {
					}
			}
			throw e;
		}

	}

	protected String determinePersistentIpAddress(
			String previousPersistentIpAddress,
			String templatePersistentIpAddress) {
		String assignedPersistentIpAddress = null;

		// If the template persistent IP address is assigned, then it will be
		// used.
		if (templatePersistentIpAddress != null) {
			assignedPersistentIpAddress = templatePersistentIpAddress;
		} else if ((previousPersistentIpAddress != null)) {
			// If the template Persistent IP address is null, then use the
			// previous persistent IP address if it is assigned.
			assignedPersistentIpAddress = previousPersistentIpAddress;
		}

		// If both are null, then return null and system will assign a new
		// elastic IP address.
		return assignedPersistentIpAddress;
	}

	protected void disassocaitePreviousIpAddressIfNecessary(
			AmazonEC2Client client, String previousPersistentIpAddress,
			String templatePersistentIpAddress) {
		// If both the previous persistent IP address and the template
		// persistent IP address are both assigned
		if ((previousPersistentIpAddress != null)
				&& (templatePersistentIpAddress != null)) {
			// If the previous persistent IP address not equal to template
			// persistent IP, then deallocate previous persistent IP address.
			if (!(previousPersistentIpAddress
					.equals(templatePersistentIpAddress))) {
				disassociateAddress(client, previousPersistentIpAddress);
			}
		}
	}

	/**
	 * Stops and destroys an AMI instance; retaining or discarding attached
	 * resources as specified.
	 */
	@RetryOnFailure(attempts = 3, delay = 3000, verbose = false)
	public void terminate(Process process, boolean retain, boolean wait) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		String id = process.getId();
		String ip = process.getPersistentIpAddress();

		terminateInstance(client, id);

		if (!retain && ip != null) {
			releaseAddress(client, ip);
		}

		try {
			if (wait) {
				waitForStateTransition(client, id, "terminated", timeout, true);
			}
		} catch (TimeoutException e) {
			// Ignore.
		}

		Volume[] volumes = process.getVolumes();
		if (!retain && volumes != null) {
			deleteVolumes(client, volumes);
		}
	}

	public void terminateInstance(String id) {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		terminateInstance(client, id);

	}

	public void checkTerminationStatusOfProcesses(List<Process> processes) {
		for (Process process : processes) {
			AmazonEC2Client client = factory.getAmazonEC2Client();

			String id = process.getId();

			try {
				waitForStateTransition(client, id, "terminated", timeout, true);
			} catch (TimeoutException e) {
				log.info(e.toString(), e);
			}
		}
	}

	/**
	 * Associates the given process's persistent IP address to itself, creating
	 * a new Elastic IP if one is not provided.
	 */
	public String bind(Process process, String previousPersistentIpAddress,
			String templatePersistentIpAddress) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		// Determine which persistent Ip address to use.
		String assignedPersistentIpAddress = determinePersistentIpAddress(
				previousPersistentIpAddress, templatePersistentIpAddress);
		// Determine if the previous persistent address has been deleted.
		disassocaitePreviousIpAddressIfNecessary(client,
				previousPersistentIpAddress, templatePersistentIpAddress);

		String id = process.getId();

		// If an persistent IP address is not assigned, get an available one.
		if (assignedPersistentIpAddress == null) {
			assignedPersistentIpAddress = allocateAddress(client, process);
		}

		// Associate the Elastic IP Address
		associateAddress(client, id, assignedPersistentIpAddress);
		return assignedPersistentIpAddress;

	}

	/**
	 * Assigns the given attributes to the given resource id.
	 */
	public void assignAttributes(String id, Properties attributes) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		LinkedList<Tag> tags = new LinkedList<Tag>();
		for (String key : attributes.stringPropertyNames()) {
			tags.add(new Tag(key, attributes.getProperty(key)));
		}

		createTags(client, id, tags);

	}

	/**
	 * Assigns the given attributes to the given process.
	 */
	public void assignAttributes(Process process, Properties attributes) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		String id = process.getId();
		LinkedList<Tag> tags = new LinkedList<Tag>();
		for (String key : attributes.stringPropertyNames()) {
			tags.add(new Tag(key, attributes.getProperty(key)));
		}

		createTags(client, id, tags);
		if (process.getVolumes() != null) {
			for (Volume volume : process.getVolumes()) {
				createTags(client, volume.getId(), tags);
				createTags(client, volume.getId(),
						Collections.singleton(new Tag("Device", volume
								.getDevice())));
			}
		}

	}

	/**
	 * Requests EC2 to allocate a new Elastic IP address to the given account.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * 
	 * @return The allocated address.
	 */
	protected String allocateAddress(AmazonEC2Client client, Process process) {
		return client.allocateAddress().getPublicIp();
	}

	/**
	 * Requests EC2 to release the Elastic IP address and return it to the given
	 * accounts available pool of address.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param address
	 *            The address to be released.
	 */
	protected void releaseAddress(AmazonEC2Client client, String address) {
		ReleaseAddressRequest request = new ReleaseAddressRequest();
		request.setPublicIp(address);
		client.releaseAddress(request);
	}

	/**
	 * Requests that EC2 assign the given Elastic IP address to the given AMI
	 * instance.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to which the address should be
	 *            assigned.
	 * @param address
	 *            The Elastic IP address to be assigned.
	 */
	protected void associateAddress(AmazonEC2Client client, String id,
			String address) {
		AssociateAddressRequest request = new AssociateAddressRequest();
		request.setInstanceId(id);
		request.setPublicIp(address);
		client.associateAddress(request);
	}

	/**
	 * Requests that EC2 assign the given Elastic IP address to the given AMI
	 * instance.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param address
	 *            The Elastic IP address to be assigned.
	 */
	protected void disassociateAddress(AmazonEC2Client client,
			String address) {
		DisassociateAddressRequest request = new DisassociateAddressRequest();
		request.setPublicIp(address);
		client.disassociateAddress(request);
	}

	/**
	 * Requests that EC2 start the given AMI instance and reclaim its resources.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be started.
	 */
	protected void startInstance(AmazonEC2Client client, String id) {
		StartInstancesRequest request = new StartInstancesRequest();
		request.setInstanceIds(Collections.singletonList(id));
		client.startInstances(request);
	}

	/**
	 * Requests that EC2 create a new AMI instance.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param template
	 *            The information needed to create the new instance.
	 * 
	 * @return The AMI ID of the new instance.
	 */
	protected String runInstance(AmazonEC2Client client,
			ProcessDefinition template) {

		RunInstancesRequest request = new RunInstancesRequest();
		request.setImageId(template.getImage());
		request.setInstanceType(template.getType());
		request.setPlacement(new Placement().withAvailabilityZone(template.getZone()));
		request.setKeyName(template.getKey());
		request.setKernelId(template.getKernel());
		request.setRamdiskId(template.getRamdisk());
		
		if (template.getSecurity() != null) {
			request.setSecurityGroups(Collections.singleton(template.getSecurity()));
		} else {
			request.setSecurityGroupIds(Collections.singleton(template.getSecurityId()));
		}
		
		request.setMinCount(1);
		request.setMaxCount(1);
		request.setUserData(buildUserData(template.getProperties()));

		if(StringUtils.isNotBlank(template.getSubnet())){
			request.setSubnetId(template.getSubnet());
		}

		RunInstancesResult result = client.runInstances(request);
		Instance instance = extractSingleInstance(result);

		return instance.getInstanceId();

	}

	/**
	 * Requests that EC2 stop the given AMI instance and reclaim its resources.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be stopped.
	 */
	protected void stopInstance(AmazonEC2Client client, String id) {
		StopInstancesRequest request = new StopInstancesRequest();
		request.setInstanceIds(Collections.singletonList(id));
		client.stopInstances(request);
	}

	/**
	 * Requests that EC2 terminate the given AMI instance and reclaim its
	 * resources.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be destroyed.
	 */
	protected void terminateInstance(AmazonEC2Client client, String id) {
		TerminateInstancesRequest request = new TerminateInstancesRequest();
		request.setInstanceIds(Collections.singleton(id));
		client.terminateInstances(request);
	}

	/**
	 * Populates the given Process object with meta-data about the given AMI
	 * instance.
	 * 
	 * Note that EC2 returns a public IP address value regardless of whether the
	 * instance has an elastic address; however it does not give any way to tell
	 * whether the address is static or dynamic. So don't count on that value
	 * being the same after a restart.
	 * 
	 * Note that EC2 occasionally returns bogus results, such as a response that
	 * does not include a private IP address. Since this is essentially invalid,
	 * and the clients of this service need to count on valid addressing
	 * information being provided, it is necessary to repeat the request until
	 * the results make sense. It is not clear what causes this, or how long the
	 * condition generally persists, but it seems to iron itself out eventually.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be stopped.
	 * @param process
	 *            The object to be populated.
	 */
	protected String describeInstance(AmazonEC2Client client, String id,
			Process process) {

		String state = null;

		do {

			DescribeInstancesRequest request = new DescribeInstancesRequest();
			request.setInstanceIds(Collections.singleton(id));

			DescribeInstancesResult result = client.describeInstances(request);
			Instance instance = extractSingleInstance(result);

			if (instance != null) {
				process.setId(instance.getInstanceId());
				process.setPrivateDnsName(instance.getPrivateDnsName());
				process.setPublicDnsName(instance.getPublicDnsName());
				process.setPrivateIpAddress(resolveAddress(
						instance.getPrivateDnsName(),
						instance.getPrivateIpAddress()));
				process.setPublicIpAddress(resolveAddress(
						instance.getPublicDnsName(),
						instance.getPublicIpAddress()));
				process.setImageId(instance.getImageId());
				process.setLaunchTime(instance.getLaunchTime());
				state = instance.getState().getName();
			} else {
				// Technically this shouldn't happen; if you tried to describe
				// an instance
				// that doesn't exist, amazon should throw an exception. But
				// just in case
				// it instead returns a result with zero entries, treat it as an
				// error.
				throw new AmazonServiceException("Instance does not exist '"
						+ id + "'.");
			}

		} while (isInitializing(state) && process.getPrivateIpAddress() == null);

		return state;

	}

	/**
	 * Will get the information for the specified instance, such as public and
	 * private address and DNS names.
	 * 
	 * 
	 * @param instanceId
	 *            - The identifier for the instance.
	 * @return The instance identified by the Instance Id. This method will
	 *         return null, if the instance is not found.
	 */

	public Instance describeInstance(String instanceId) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		DescribeInstancesRequest describeInstancesRequest = new DescribeInstancesRequest();
		describeInstancesRequest.setInstanceIds(Collections
				.singleton(instanceId));

		DescribeInstancesResult result = client
				.describeInstances(describeInstancesRequest);
		return extractSingleInstance(result);

	}

	public Address describeAddress(Address partialAddr) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		DescribeAddressesRequest describeAddressesRequest = new DescribeAddressesRequest();
		if (partialAddr.getAllocationId() != null) {
			describeAddressesRequest.setAllocationIds(Collections
					.singleton(partialAddr.getAllocationId()));
		}
		else if (partialAddr.getPublicIp() != null) {
			describeAddressesRequest.setPublicIps(Collections
					.singleton(partialAddr.getPublicIp()));
		}

		DescribeAddressesResult result = client
				.describeAddresses(describeAddressesRequest);
		return extractSingleInstance(result);
	}

	/**
	 * Return an IP address. Name resolution on the host parameter will be used
	 * if instanceAddress is not filled in.
	 */
	protected String resolveAddress(String host, String instanceAddress) {
		String ipAddress = null;

		if (instanceAddress == null) {
			try {
				ipAddress = InetAddress.getByName(host).getHostAddress();
			} catch (UnknownHostException uhe) {
				log.error(uhe.getMessage(), uhe);
			}
		} else {
			ipAddress = instanceAddress;
		}

		return ipAddress;
	}

	/**
	 * Assigns the given attributes to the given AMI instance.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be stopped.
	 * @param tags
	 *            The list of tags to be assigned.
	 */
	protected void createTags(AmazonEC2Client client, String id,
			Collection<Tag> tags) {

		CreateTagsRequest request = new CreateTagsRequest();
		request.setResources(Collections.singletonList(id));
		request.setTags(tags);

		client.createTags(request);

	}

	/**
	 * Creates the volumes in the number and size specified by the given
	 * template.
	 */
	protected Volume[] createOrRetrieveVolumes(AmazonEC2Client client,
			ProcessDefinition template, Volume[] assignedVolumes) {

		// Does this process have assigned volumes
		boolean hasAssignedVolumes;
		int volumeCount = template.getVolumeCount();
		Volume[] volumes = new Volume[volumeCount];
		// Get all the volumes for this client.
		Map<String, Volume> allVolumes = listAllVolumesById();
		Volume assignedVolume;

		String devicePrefix = null;
		devicePrefix = template.getVolumeBlockPrefix();

		// Determine if the process has assigned volumes.
		if (assignedVolumes == null) {
			// Create All new Volumes
			hasAssignedVolumes = false;
		} else {
			hasAssignedVolumes = true;
		}

		/*
		 * re-decide how many volumes to create use number from template ONLY if
		 * there are no assigned volumes no assigned volumes means a fresh
		 * start, (or a new addition of volumes) so we want to allocate some. If
		 * we have ANY assigned volumes, we just want to use them, all of them,
		 * and only them, to avoid destroying our raid array and losing data.
		 */
		if (hasAssignedVolumes) {
			volumeCount = assignedVolumes.length;
			volumes = new Volume[volumeCount];
		}

		try {
			for (int i = 0; i < volumeCount; i++) {
				if ((hasAssignedVolumes) && (i < assignedVolumes.length)) {
					assignedVolume = assignedVolumes[i];
				} else {
					assignedVolume = null; // There is no assigned volume
				}

				String increment = String.valueOf(i + 1);
				if (!devicePrefix.contains(DEFAULT_DEVICE_PREFIX)) {
					increment = Character.toString((char)(i + 98));
				}
				String device = devicePrefix + increment;
				if (isVolumeAvailable(allVolumes, assignedVolume)) {
					assignedVolume.setDevice(device);
					volumes[i] = assignedVolume;
				} else {
					String id = createVolume(client, template);

					volumes[i] = new Volume();
					volumes[i].setId(id);
					volumes[i].setDevice(device);
				}
			}
		} catch (AmazonServiceException e) {
			for (int i = 0; i < volumeCount; i++) {
				if (volumes[i] != null)
					try {
						deleteVolume(client, volumes[i]);
					} catch (Exception ignore) {
						// ignore.
					}
			}
			throw e;
		}

		return volumes;

	}

	/**
	 * Creates a single volumes using the size and availability zone specified
	 * in the given template.
	 */
	protected String createVolume(AmazonEC2Client client,
			ProcessDefinition template) {

		CreateVolumeRequest request = new CreateVolumeRequest();
		request.setSize(template.getVolumeSize());
		request.setAvailabilityZone(template.getZone());

		CreateVolumeResult result = client.createVolume(request);
		return result.getVolume().getVolumeId();

	}

	/**
	 * Forcibly detach a set of volumes.
	 * 
	 * @param volume
	 *            Volumes to detach
	 */
	public void forceVolumesDetach(Volume[] volumes) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		forceVolumesDetach(client, volumes);
	}

	/**
	 * Detach the given set of volumes.
	 */
	protected void forceVolumesDetach(AmazonEC2Client client, Volume[] volumes) {
		for (Volume volume : volumes) {
			forceVolumeDetach(client, volume);
		}
	}

	/**
	 * Forcibly detach a volume.
	 * 
	 * @param volume
	 *            Volume to detach
	 */
	public void forceVolumeDetach(Volume volume) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		forceVolumeDetach(client, volume);
	}

	/**
	 * Detach the given volume.
	 */
	protected void forceVolumeDetach(AmazonEC2Client client, Volume volume) {
		DetachVolumeRequest request = new DetachVolumeRequest(volume.getId());
		request.setForce(true);

		client.detachVolume(request);
	}

	/**
	 * Deletes the given set of volumes.
	 * 
	 * @param volumes
	 *            Volumes to delete
	 */
	public void deleteVolumes(Volume[] volumes) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		deleteVolumes(client, volumes);
	}

	/**
	 * Deletes the given set of volumes.
	 */
	protected void deleteVolumes(AmazonEC2Client client, Volume[] volumes) {
		for (Volume volume : volumes) {
			deleteVolume(client, volume);
		}
	}

	/**
	 * Deletes the given volume.
	 * 
	 * @param volume
	 *            Volume to delete
	 */
	public void deleteVolume(Volume volume) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		deleteVolume(client, volume);
	}

	/**
	 * Deletes the given volume.
	 */
	protected void deleteVolume(AmazonEC2Client client, Volume volume) {
		client.deleteVolume(new DeleteVolumeRequest(volume.getId()));
	}

	/**
	 * Attaches the given volume to the given instance.
	 */
	protected void attachVolume(AmazonEC2Client client, String id,
			Volume volume) {

		AttachVolumeRequest request = new AttachVolumeRequest();
		request.setInstanceId(id);
		request.setVolumeId(volume.getId());
		request.setDevice(volume.getDevice());

		// TODO what should the logic be if this request fails ????
		client.attachVolume(request);
	}

	/**
	 * Attaches each of the given volumes to the given instance.
	 */
	protected void attachVolumes(AmazonEC2Client client, String id,
			Volume[] volumes) {
		List<String> volumeIds = new ArrayList<String>(volumes.length);
		for (Volume volume: volumes) {
			volumeIds.add(volume.getId());
		}
		
		// Block until all volumes are available or retry has been exceeded
		boolean allAvailable = waitForVolumeAvailability(volumeIds, false);
		if (!allAvailable)
			log.warn("One or more volume(s) were not available before cutoff, please check out this instance.");
		
		// All volumes now available, issue the attach for each
		for (Volume volume : volumes) {
			attachVolume(client, id, volume);
		}

		// Block until all volumes are attached or retry has been exceeded
		log.info(String.format("Checking volume(s) states: '{%s}' for instance: '{%s}'", volumeIds.toString(), id));
		boolean allAttached = waitForVolumeAttachment(volumeIds, false);

		if (!allAttached)
			log.warn("One or more volume(s) were not attached properly before cutoff, please check out this instance.");
	}

	/**
	 * 
	 * This method will determine if a volume is available.
	 * 
	 * @param volume
	 *            - Volume to check.
	 * @return
	 */

	protected boolean isVolumeAvailable(Map<String, Volume> allVolumes,
			Volume volume) {

		// No volume specified, so it is not available
		if (volume == null) {
			return false;
		}

		// Get the allocated volume.
		Volume allocatedVolume = allVolumes.get(volume.getId());

		// Check if the volume is available by checking the volume state against
		// the availability state string.
		if ((allocatedVolume != null)
				&& (availabilityState.equals(allocatedVolume.getState()))) {
			// Need to create a new volume, it was not found.
			return true;
		} else {
			// Volume is not available.
			return false;
		}
	}

	/**
	 * Waits for the given AMI instance to go into the given run state. This
	 * method exists because some EC2 API requests can only be issued while an
	 * instance is in a specific state (otherwise it results in an error). For
	 * example, you can assign an Elastic IP to an instance unless it is in the
	 * "running" state. Unfortunate, a start instance request will return
	 * successfully before the instance has actually started, leaving you know
	 * way to know when it is safe to request an IP assignment.
	 * 
	 * @param client
	 *            The connection over which to send the request.
	 * @param id
	 *            The AMI ID of the instance to be stopped.
	 * @param state
	 *            The state to wait for.
	 * @param timeout
	 *            The maximum about time to wait (in milliseconds).
	 * @param breakOnNullInstanceOrException
	 * 			  If the instance that is being checked for state does not 
	 * 			  exist, break and return from the method immediately even
	 * 			  for infinite timeout.  AWS throws an error for a non-existent
	 * 			  instance, Euca returns a result but the instance ends up being null.
	 * 			  
	 */
	protected void waitForStateTransition(AmazonEC2Client client,
			String id, String state, long timeout, boolean breakOnNullInstanceOrException) {
		long limit = 0;
		if (timeout == -1) {
			// essentially wait forever
			limit = Long.MAX_VALUE;
		} else {
			limit = System.currentTimeMillis() + timeout;
		}
		DescribeInstancesRequest request = new DescribeInstancesRequest();
		request.setInstanceIds(Collections.singleton(id));

		while (System.currentTimeMillis() < limit) {
			try {
				DescribeInstancesResult result = client.describeInstances(request);
				Instance instance = extractSingleInstance(result);
				if (instance == null) {
					if (breakOnNullInstanceOrException) {
						log.info("InstanceId: " + id + " is null, breaking out of waitForStateTransition loop");
						return;
					}
				} else if (instance.getState().getName().equals(state)) {
					return;
				}
			} catch (AmazonServiceException e) {
				// When new instances are being created, Amazon occasionally
				// "forgets" what instances
				// actually exist. Calling describe on an instance that has
				// just
				// been created may
				// result in an exception. Eventually Amazon remembers what
				// it
				// is doing and will
				// acknowledge the existence of your instance. Just just
				// keep
				// trying, unless...
				if (breakOnNullInstanceOrException) {
					// as described above you may want to ignore this exception when waiting
					// for a new instance to go to "running", but when waiting for a terminating
					// instance actually should break out
					log.info("InstanceId: " + id + " exception: " + 
							e.toString() + ", breaking out of waitForStateTransition loop");
					return;
				}
			}
			try { Thread.sleep(3000); } catch (InterruptedException ignore) {}
		}
		// if we get here, we have timed out waiting 
		throw new TimeoutException("Timout waiting for state transition '" + state + "'.");
	}

	/**
	 * Builds a user data string from the given properties. The AWS credential
	 * data is added to the list of properties. The data is encoded as key/value
	 * pairs, where key/value are separated be '=' and pairs are delimited by
	 * ';'. It is assumed that something will be pre-installed on the AMI that
	 * can retrieve, parse and use this data.
	 */
	protected String buildUserData(Properties properties) {

		AWSCredentials credentials = factory.getCredentials();
		properties.put("RTWS_ACCESS_KEY", credentials.getAWSAccessKeyId());
		properties.put("RTWS_SECRET_KEY", credentials.getAWSSecretKey());

		StringBuilder buffer = new StringBuilder();
		for (String key : properties.stringPropertyNames()) {
			buffer.append(key);
			buffer.append("=");
			buffer.append(properties.getProperty(key));
			buffer.append(";");
		}

		return Base64.encodeBase64String(buffer.toString().getBytes());

	}

	/**
	 * Builds a comma separated list of device names from the given list of
	 * volumes.
	 */
	protected String buildDeviceList(Volume[] volumes) {
		StringBuilder list = new StringBuilder();
		for (int i = 0; i < volumes.length; i++) {
			list.append(volumes[i].getDevice());
			list.append(",");
		}
		return list.substring(0, list.length() - 1);
	}

	/**
	 * Convenience method getting the Instance object out of a
	 * describe-instances request, when you expect a single result.
	 * 
	 * @param result
	 *            The result object from which to extract Instance information.
	 * 
	 * @return The first instance in the list of instances in the first
	 *         reservation of the list of reservations.
	 */
	protected static Instance extractSingleInstance(DescribeInstancesResult result) {
		List<Reservation> reservations = result.getReservations();
		if (reservations.isEmpty()) {
			return null;
		}
		List<Instance> instances = reservations.get(0).getInstances();
		if (instances.isEmpty()) {
			return null;
		}
		return instances.get(0);
	}

	/**
	 * Convenience method getting the Instance object out of a run-instances
	 * request, when you expect a single result.
	 * 
	 * @param result
	 *            The result object from which to extract Instance information.
	 * 
	 * @return The first instance in the list of instances.
	 */
	protected static Instance extractSingleInstance(RunInstancesResult result) {
		return result.getReservation().getInstances().get(0);
	}

	protected static Address extractSingleInstance(DescribeAddressesResult result) {
		if (result.getAddresses().size() == 0) {
			return null;
		}
		return result.getAddresses().get(0);
	}

	/**
	 * Determine whether the given status indicates that an instance is in (or
	 * is transitioning to) a running state.
	 */
	protected static boolean isInitializing(String state) {
		return Arrays.asList("pending", "running", "rebooting").contains(state);
	}

	/**
	 * Return a process that exist in the cloud environment given an instance
	 * id.
	 */
	@Override
	public Process listProcess(String id) {

		DescribeInstancesRequest request = new DescribeInstancesRequest();
		request.setInstanceIds(Collections.singleton(id));

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances(request);

		Map<String, Volume> volumes = listAllVolumesById();

		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			if (instances.size() == 1) {
				Instance instance = instances.get(0);
				return createProcess(instance, volumes);
			}
		}

		return null;

	}
	
	@Override
	public Process listProcessWithoutVolumes(String id) {
		
		DescribeInstancesRequest request = new DescribeInstancesRequest();
		request.setInstanceIds(Collections.singleton(id));

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances(request);

		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			if (instances.size() == 1) {
				Instance instance = instances.get(0);
				return createProcess(instance, null);
			}
		}

		return null;
		
	}
	
	@Override
	public Collection<Process> listProcessWithoutVolumes(List<String> ids) {
		
		ArrayList<Process> processes = new ArrayList<Process>();
		
		DescribeInstancesRequest request = new DescribeInstancesRequest();
		request.setInstanceIds(ids);

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances(request);

		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			if (instances.size() == 1) {
				Instance instance = instances.get(0);
				processes.add(createProcess(instance, null));
			}
		}

		return processes;
		
	}

	/**
	 * Return a list of processes that exist in the cloud environment.
	 */
	@Override
	public Collection<Process> listAllProcesses() {

		ArrayList<Process> processes = new ArrayList<Process>();

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances();

		Map<String, Volume> volumes = listAllVolumesById();
		
		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			for (Instance instance : instances) {
				processes.add(createProcess(instance, volumes));
			}
		}

		return processes;

	}

	/**
	 * Return a map of instance id and process that exist in the cloud
	 * environment.
	 */
	@Override
	public Map<String, Process> listProcessById() {

		HashMap<String, Process> processes = new HashMap<String, Process>();

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances();

		Map<String, Volume> volumes = listAllVolumesById();

		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			for (Instance instance : instances) {
				processes.put(instance.getInstanceId(),
						createProcess(instance, volumes));
			}
		}

		return processes;

	}
	
	@Override
	public Map<String, Process> listProcessByIdWithoutVolumes() {
		
		HashMap<String, Process> processes = new HashMap<String, Process>();

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeInstancesResult result = client.describeInstances();

		List<Reservation> reservations = result.getReservations();
		for (Reservation reservation : reservations) {
			List<Instance> instances = reservation.getInstances();
			for (Instance instance : instances) {
				processes.put(instance.getInstanceId(),
						createProcess(instance, null));
			}
		}

		return processes;
		
	}

	@Override
	public Collection<Volume> listVolumes(List<String> volumeIds) {

		Collection<Volume> cVolumes = new ArrayList<Volume>();

		DescribeVolumesRequest request = new DescribeVolumesRequest();
		request.setVolumeIds(volumeIds);

		DescribeVolumesResult result = describeVolumesWithRetry(request);

		List<com.amazonaws.services.ec2.model.Volume> volumes = result.getVolumes();
	
		for (com.amazonaws.services.ec2.model.Volume volume : volumes) {
			String volId = volume.getVolumeId();
			Integer size = volume.getSize();
			String state = volume.getState();
			Date createTime = volume.getCreateTime();
			String device = null;

			for (VolumeAttachment attachment : volume.getAttachments()) {
				if (attachment.getVolumeId().equals(volId)) {
					device = attachment.getDevice();
				}
			}

			cVolumes.add(new Volume(volId, size.floatValue(), device, state, createTime));
		}

		return cVolumes;
		
	}

	@Override
	public Map<String, Volume> listVolumesById(List<String> volumeIds) {

		HashMap<String, Volume> cVolumes = new HashMap<String, Volume>();

		for (Volume volume : listVolumes(volumeIds)) {
			cVolumes.put(volume.getId(), volume);
		}

		return cVolumes;

	}

	/**
	 * Returns a list of volumes the user owns.
	 */
	@Override
	public Collection<Volume> listAllVolumes() {

		Collection<Volume> cVolumes = new ArrayList<Volume>();

		DescribeVolumesResult result = describeVolumesWithRetry(null);

		List<com.amazonaws.services.ec2.model.Volume> volumes = result
				.getVolumes();
		for (com.amazonaws.services.ec2.model.Volume volume : volumes) {
			String volId = volume.getVolumeId();
			Integer size = volume.getSize();
			String state = volume.getState();
			Date createTime = volume.getCreateTime();
			String device = null;

			for (VolumeAttachment attachment : volume.getAttachments()) {
				if (attachment.getVolumeId().equals(volId)) {
					device = attachment.getDevice();
				}
			}

			cVolumes.add(new Volume(volId, size.floatValue(), device, state,
					createTime));
		}

		return cVolumes;

	}

	/**
	 * Returns a map of volumes the user owns.
	 */
	@Override
	public Map<String, Volume> listAllVolumesById() {

		HashMap<String, Volume> cVolumes = new HashMap<String, Volume>();

		for (Volume volume : listAllVolumes()) {
			cVolumes.put(volume.getId(), volume);
		}

		return cVolumes;

	}

	/**
	 * Returns a single volume a user owns.
	 */
	@Override
	public Volume listVolume(String volumeId) {

		Volume cVolume = null;

		DescribeVolumesResult result = describeVolumesWithRetry(
				new DescribeVolumesRequest(Collections.singletonList(volumeId)));

		if (result.getVolumes().size() == 1) {
			com.amazonaws.services.ec2.model.Volume volume = result
					.getVolumes().get(0);
			String state = volume.getState();
			String device = null;

			for (VolumeAttachment attachment : volume.getAttachments()) {
				if (attachment.getVolumeId().equals(volume.getVolumeId())) {
					device = attachment.getDevice();
				}
			}

			cVolume = new Volume(volume.getVolumeId(), volume.getSize()
					.floatValue(), device, state, volume.getCreateTime());
		}

		return cVolume;

	}
	
	/**
	 * We have seen transient errors on DescribeVolumes especially from Euca.
	 * Retrying a few times with a small sleep if we get a ServiceException.
	 * @param request
	 * @return
	 */
	private DescribeVolumesResult describeVolumesWithRetry(DescribeVolumesRequest request) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeVolumesResult result = null;
		int attempt = 0;
		while (result == null && attempt < 3) {
			attempt++;
			try {
				if (request == null) {
					result = client.describeVolumes();
				} else {
					result = client.describeVolumes(request);
				}
			} catch (AmazonServiceException ase) {
				log.warn("Describe volumes request failed, retrying", ase);
				try { Thread.sleep(3000); } catch (InterruptedException ignore) {}
			}
		}
		if (result == null) {
			result = new DescribeVolumesResult();
			result.setVolumes(new ArrayList<com.amazonaws.services.ec2.model.Volume>());
		}
		return result;
	}

	/**
	 * Returns a list of firewall groups.
	 */
	public Collection<FirewallGroup> listFirewallGroups() {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DescribeSecurityGroupsResult result = client.describeSecurityGroups();

		// AWS SDK doesn't return back the group name for vpc security
		// group rule source. This map is used later on to fill in the missing
		// value. EC2 security rules doesn't have this problem. Don't know why
		// this is happening for vpc security rules maybe its the version of the sdk. 
		// Remove this map once the group name is return back.
		
		HashMap<String, String> sgIdGroupNameMapper = new HashMap<String, String>();
		for (SecurityGroup sGroup : result.getSecurityGroups()) {
			sgIdGroupNameMapper.put(sGroup.getGroupId(), sGroup.getGroupName());
		}
		
		ArrayList<FirewallGroup> fGroups = new ArrayList<FirewallGroup>();

		for (SecurityGroup sGroup : result.getSecurityGroups()) {
			FirewallGroup fGroup = new FirewallGroup();
			fGroup.setId(sGroup.getGroupId());
			fGroup.setName(sGroup.getGroupName());
			fGroup.setDescription(sGroup.getDescription());
			fGroup.setVpcId(sGroup.getVpcId());

			for (IpPermission permission : sGroup.getIpPermissions()) {
				FirewallRule rule = new FirewallRule();

				// According to the aws documentation, if the protocol
				// is icmp than the fromPort() method will return the icmp
				// type and the toPort() method will return the icmp code.

				rule.setProtocol(permission.getIpProtocol());
				rule.setFromPort(permission.getFromPort());
				rule.setToPort(permission.getToPort());

				for (String range : permission.getIpRanges()) {
					FirewallIpRangeSource source = new FirewallIpRangeSource();
					source.setIpRange(range);

					rule.addIpRange(source);
				}

				for (UserIdGroupPair pair : permission.getUserIdGroupPairs()) {
					FirewallGroupSource source = new FirewallGroupSource();
					source.setGroupId(pair.getGroupId());
					
					if (pair.getGroupName() == null) {
						source.setGroupName(sgIdGroupNameMapper.get(pair.getGroupId()));
					} else { 
						source.setGroupName(pair.getGroupName());
					}
					
					source.setUserId(pair.getUserId());

					rule.addFirewallGroupSource(source);
				}

				fGroup.addRule(rule);
			}

			fGroups.add(fGroup);
		}

		return fGroups;

	}
	
	/**
	 * Returns a map of firewall groups with the group id as the key.
	 */
	@Override
	public Map<String, FirewallGroup> listFirewallGroupsById() {
		
		Collection<FirewallGroup> fgroups = listFirewallGroups();

		HashMap<String, FirewallGroup> holder = new HashMap<String, FirewallGroup>();
		for (FirewallGroup fgroup : fgroups) {
			holder.put(fgroup.getId(), fgroup);
		}

		return holder;
		
	}

	/**
	 * Returns a map of firewall groups with the group name as the key.
	 */
	@Override
	public Map<String, FirewallGroup> listFirewallGroupsByName() {

		Collection<FirewallGroup> fgroups = listFirewallGroups();

		HashMap<String, FirewallGroup> holder = new HashMap<String, FirewallGroup>();
		for (FirewallGroup fgroup : fgroups) {
			holder.put(fgroup.getName(), fgroup);
		}

		return holder;

	}

	@Override
	public String createFirewallGroup(String name, String description, String vpcId) {

		boolean groupExists = false;
		String groupId = null;
		Collection<FirewallGroup> existingGroups = listFirewallGroups();
		for (FirewallGroup eGrps : existingGroups) {
			if (eGrps.getName().equals(name)) {
				groupExists = true;
				groupId = eGrps.getId();
			}
		}

		if (!groupExists) {
			AmazonEC2Client client = factory.getAmazonEC2Client();
			CreateSecurityGroupResult result = client
					.createSecurityGroup(new CreateSecurityGroupRequest(name,
							description));
			groupId = result.getGroupId();
		}

		return groupId;

	}

	@Override
	public void deleteFirewallGroup(String name) {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		DeleteSecurityGroupRequest deleteSecurityGroupRequest = new DeleteSecurityGroupRequest(
				name);
		client.deleteSecurityGroup(deleteSecurityGroupRequest);

	}
	
	@Override
	public void deleteFirewallGroup(String name, String vpcId) {
		
		String groupId = null;
		for (FirewallGroup eGrps : listFirewallGroups()) {
			if (eGrps.getVpcId() != null && vpcId.equals(eGrps.getVpcId()) && eGrps.getName().equals(name)) {
				groupId = eGrps.getId();
			}
		}

		if (groupId != null) {
			AmazonEC2Client client = factory.getAmazonEC2Client();
			
			DeleteSecurityGroupRequest request = new DeleteSecurityGroupRequest();
			request.setGroupId(groupId);
			
			client.deleteSecurityGroup(request);
		}
		
	}
	
	/**
	 * Create a firewall rule (aka security rule) with a group id using a ip range as the source.
	 */
	@Override
	public void createFirewallRuleByIpPermissionWithGroupId(String groupId,
			String protocol, int fromPort, int toPort, String ipRange) {
		
		AmazonEC2Client client = null;
		
		try {
			client = factory.getAmazonEC2Client();

			IpPermission ipPermission = new IpPermission();
			ipPermission.withIpProtocol(protocol).withFromPort(fromPort).withToPort(toPort).withIpRanges(ipRange);
			
			AuthorizeSecurityGroupIngressRequest request = new AuthorizeSecurityGroupIngressRequest();
			request.withGroupId(groupId).withIpPermissions(ipPermission);
			
			client.authorizeSecurityGroupIngress(request);
		} catch (AmazonServiceException e) {
			if (!e.getErrorCode().equals("InvalidPermission.Duplicate")) {
				throw e;
			}
		} finally {
			if (client != null)
				client.shutdown();
		}

	}

	/**
	 * Create a firewall rule (aka security rule) with a group name using a ip range as the source.
	 */
	@Override
	public void createFirewallRuleByIpPermission(String groupName,
			String protocol, int fromPort, int toPort, String ipRange) {
		AmazonEC2Client client = null;
		try {
			client = factory.getAmazonEC2Client();

			AuthorizeSecurityGroupIngressRequest request = new AuthorizeSecurityGroupIngressRequest();
			request.withGroupName(groupName).withIpProtocol(protocol)
					.withFromPort(fromPort).withToPort(toPort)
					.withCidrIp(ipRange);

			client.authorizeSecurityGroupIngress(request);
		} catch (AmazonServiceException e) {
			if (!e.getErrorCode().equals("InvalidPermission.Duplicate")) {
				throw e;
			}
		} finally {
			if (client != null)
				client.shutdown();
		}

	}
	
	/**
	 * Create a firewall rule (aka security rule) with a group id using 
	 * another security group as the source.
	 */
	@Override
	public void createFirewallRuleByUserIdGroupWithGroupId(String groupId,
			String protocol, int fromPort, int toPort, String userId,
			String userIdGroupId) {
		
		AmazonEC2Client client = null;
		
		try {
			client = factory.getAmazonEC2Client();

			UserIdGroupPair pair = new UserIdGroupPair();
			pair.setUserId(userId);
			pair.setGroupId(userIdGroupId);

			IpPermission permission = new IpPermission();
			permission.setIpProtocol(protocol);
			permission.setFromPort(fromPort);
			permission.setToPort(toPort);
			permission.setUserIdGroupPairs(Collections.singletonList(pair));

			AuthorizeSecurityGroupIngressRequest request = new AuthorizeSecurityGroupIngressRequest();
			request.withGroupId(groupId).withIpPermissions(permission);

			client.authorizeSecurityGroupIngress(request);
		} catch (AmazonServiceException e) {
			if (!e.getErrorCode().equals("InvalidPermission.Duplicate")) {
				throw e;
			}
		} finally {
			if (client != null)
				client.shutdown();
		}

	}

	/**
	 * Create a firewall rule (aka security rule) with a group name using another 
	 * security group as the source.
	 */
	@Override
	public void createFirewallRuleByUserIdGroup(String groupName,
			String protocol, int fromPort, int toPort, String userId,
			String userIdGroupId) {
		
		AmazonEC2Client client = null;
		
		try {
			client = factory.getAmazonEC2Client();

			UserIdGroupPair pair = new UserIdGroupPair();
			pair.setUserId(userId);
			pair.setGroupId(userIdGroupId);

			IpPermission permission = new IpPermission();
			permission.setIpProtocol(protocol);
			permission.setFromPort(fromPort);
			permission.setToPort(toPort);
			permission.setUserIdGroupPairs(Collections.singletonList(pair));

			AuthorizeSecurityGroupIngressRequest request = new AuthorizeSecurityGroupIngressRequest();
			request.withGroupName(groupName).withIpPermissions(permission);

			client.authorizeSecurityGroupIngress(request);
		} catch (AmazonServiceException e) {
			if (!e.getErrorCode().equals("InvalidPermission.Duplicate")) {
				throw e;
			}
		} finally {
			if (client != null)
				client.shutdown();
		}

	}
	
	/**
	 * Delete a firewall rule (aka security rule) with a group id using 
	 * a ip range as the source.
	 */
	@Override
	public void deleteFirewallRuleByIpPermissionWithGroupId(String groupId,
			String protocol, int fromPort, int toPort, String ipRange) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		IpPermission ipPermission = new IpPermission();
		ipPermission.withIpProtocol(protocol).withFromPort(fromPort).withToPort(toPort).withIpRanges(ipRange);

		RevokeSecurityGroupIngressRequest request = new RevokeSecurityGroupIngressRequest();
		request.withGroupId(groupId).withIpPermissions(ipPermission);

		client.revokeSecurityGroupIngress(request);

	}

	/**
	 * Delete a firewall rule (aka security rule) with a group name using 
	 * a ip range as the source.
	 */
	@Override
	public void deleteFirewallRuleByIpPermission(String groupName,
			String protocol, int fromPort, int toPort, String ipRange) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		RevokeSecurityGroupIngressRequest request = new RevokeSecurityGroupIngressRequest();
		request.withGroupName(groupName).withIpProtocol(protocol)
				.withFromPort(fromPort).withToPort(toPort).withCidrIp(ipRange);

		client.revokeSecurityGroupIngress(request);

	}
	
	/**
	 * Delete a firewall rule (aka security rule) with a group id using another security group
	 * as the source.
	 */
	@Override
	public void deleteFirewallRuleByUserIdGroupWithGroupId(String groupId,
			String protocol, int fromPort, int toPort, String userId,
			String userIdGroupId) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		UserIdGroupPair pair = new UserIdGroupPair();
		pair.setUserId(userId);
		pair.setGroupId(userIdGroupId);

		IpPermission permission = new IpPermission();
		permission.setIpProtocol(protocol);
		permission.setFromPort(fromPort);
		permission.setToPort(toPort);
		permission.setUserIdGroupPairs(Collections.singletonList(pair));

		RevokeSecurityGroupIngressRequest request = new RevokeSecurityGroupIngressRequest();
		request.withGroupId(groupId).withIpPermissions(permission);

		client.revokeSecurityGroupIngress(request);

	}

	/**
	 * Delete a firewall rule (aka security rule) with a group name using another security group
	 * as the source.
	 */
	@Override
	public void deleteFirewallRuleByUserIdGroup(String groupName,
			String protocol, int fromPort, int toPort, String userId,
			String userIdGroupId) {

		AmazonEC2Client client = factory.getAmazonEC2Client();

		UserIdGroupPair pair = new UserIdGroupPair();
		pair.setUserId(userId);
		pair.setGroupId(userIdGroupId);

		IpPermission permission = new IpPermission();
		permission.setIpProtocol(protocol);
		permission.setFromPort(fromPort);
		permission.setToPort(toPort);
		permission.setUserIdGroupPairs(Collections.singletonList(pair));

		RevokeSecurityGroupIngressRequest request = new RevokeSecurityGroupIngressRequest();
		request.withGroupName(groupName).withIpPermissions(permission);

		client.revokeSecurityGroupIngress(request);

	}
	
	/**
	 * Start a EC2 instance given the node model.
	 */
	@Override
	public void start(String id) {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		startInstance(client, id);

	}

	/**
	 * Stop a EC2 instance given the node model.
	 */
	@Override
	public void stop(String id) {

		AmazonEC2Client client = factory.getAmazonEC2Client();
		stopInstance(client, id);

	}

	/**
	 * Helper function to create process.
	 */
	protected Process createProcess(Instance instance,
			Map<String, Volume> volumes) {

		String id = instance.getInstanceId();
		String imageId = instance.getImageId();
		String type = instance.getInstanceType();
		String state = instance.getState().getName();
		String publicDnsName = instance.getPublicDnsName();
		String publicIpAddress = instance.getPublicIpAddress();
		String privateDnsName = instance.getPrivateDnsName();
		String privateIpAddress = instance.getPrivateIpAddress();
		String rootDeviceType = instance.getRootDeviceType();
		String vpcId = instance.getVpcId();
		String subnetId = instance.getSubnetId();

		Process process = new Process();
		process.setId(id);
		process.setType(type);
		process.setImageId(imageId);
		process.setState(State.fromValue(state));
		process.setPublicDnsName(publicDnsName);
		process.setPublicIpAddress(publicIpAddress);
		process.setPrivateDnsName(privateDnsName);
		process.setPrivateIpAddress(privateIpAddress);
		process.setRootDeviceType(rootDeviceType);
		process.setVpcId(vpcId);
		process.setSubnetId(subnetId);
		process.setLaunchTime(instance.getLaunchTime());

		ArrayList<Volume> filteredVolumes = new ArrayList<Volume>();

		List<InstanceBlockDeviceMapping> deviceBlocks = instance
				.getBlockDeviceMappings();
		for (InstanceBlockDeviceMapping deviceBlock : deviceBlocks) {
			if (volumes != null) {
				Volume volume = volumes.get(deviceBlock.getEbs().getVolumeId());
				if (volume != null) {
					filteredVolumes.add(volume);
				}
			}
		}

		if (filteredVolumes.size() > 0) {
			process.setVolumes(filteredVolumes
					.toArray(new Volume[filteredVolumes.size()]));
		}
		
		
		if (process.getVolumes() != null) {
			Map<Volume, Float> volumesWithSizes = new HashMap<Volume, Float>(process.getVolumes().length);
			for (Volume vol: process.getVolumes()) {
				volumesWithSizes.put(vol, vol.getSize());
			}
			process.setVolumesWithSizes(volumesWithSizes);
		}

		return process;

	}

	/**
	 * Monitors a list of processes for a termination state change.
	 */
	// TODO allow monitoring for a different state, such as "running"
	@Override
	public void monitorProcessStateChange(Collection<Process> processes,
			boolean timeOutInfinity) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		for (Process process : processes) {
			String id = process.getId();
			log.info("Checking instance termination state for "
					+ process.getPersistentDnsName());

			try {
				// wait indefinently until process state changes
				if (timeOutInfinity == true) {
					waitForStateTransition(client, id, "terminated", -1, true);
				}
				// wait until timeout for process state to change
				else {
					waitForStateTransition(client, id, "terminated", timeout, true);
				}

			} catch (TimeoutException e) {
				log.info(e.toString(), e);
			}
		}
	}

	@Override
	public CreateVolumeResult createVolume(Volume volume, String zone) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		CreateVolumeRequest createVolumeRequest = new CreateVolumeRequest();
		createVolumeRequest.setSize(volume.getSize().intValue());
		createVolumeRequest.setAvailabilityZone(zone);
		CreateVolumeResult volumeResult = client
				.createVolume(createVolumeRequest);

		return volumeResult;
	}

	@Override
	public List<Snapshot> listAllSnapshots() {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		List<Snapshot> snapshots = new ArrayList<Snapshot>();

		DescribeSnapshotsResult result = client.describeSnapshots();
		for (com.amazonaws.services.ec2.model.Snapshot ss : result
				.getSnapshots()) {
			snapshots.add(new Snapshot(ss.getSnapshotId(), ss.getState(), ss
					.getVolumeId(), ss.getDescription(), ss.getStartTime()));
		}

		return snapshots;
	}

	@Override
	public Snapshot createSnapshot(String volumeId, String description) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		CreateSnapshotRequest request = new CreateSnapshotRequest();
		request.setVolumeId(volumeId);
		request.setDescription(description);

		CreateSnapshotResult result = client.createSnapshot(request);

		Snapshot snapshot = new Snapshot(result.getSnapshot().getSnapshotId(),
				result.getSnapshot().getState(), result.getSnapshot()
						.getVolumeId(), result.getSnapshot().getDescription(),
				result.getSnapshot().getStartTime());

		return snapshot;
	}

	@Override
	public void deleteSnapshot(String snapshotId) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		DeleteSnapshotRequest request = new DeleteSnapshotRequest();
		request.setSnapshotId(snapshotId);

		client.deleteSnapshot(request);
	}

	@Override
	public AttachVolumeResult attachVolume(CreateVolumeResult volumeResult,
			String instanceId, String mountDevice, String prefixNum) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		AttachVolumeRequest attachVolumeRequest = new AttachVolumeRequest();
		attachVolumeRequest.setInstanceId(instanceId);
		attachVolumeRequest.setVolumeId(volumeResult.getVolume().getVolumeId());

		String devicePrefix = mountDevice;
		
		String increment = prefixNum;
		//if not using sdf, need to add letters instead of numbers, will cast number to correct ascii char value
		if (!devicePrefix.contains(DEFAULT_DEVICE_PREFIX)) {
			increment = Character.toString((char)(Integer.parseInt(prefixNum) + 97));
		}		
		
		attachVolumeRequest.setDevice(String.format("%s%s", devicePrefix,
				increment));

		AttachVolumeResult attachResult = client
				.attachVolume(attachVolumeRequest);

		return attachResult;
	}

	@Override
	public AttachVolumeResult attachVolume(Volume volume, String instanceId) {
		AmazonEC2Client client = factory.getAmazonEC2Client();

		AttachVolumeRequest attachVolumeRequest = new AttachVolumeRequest();
		attachVolumeRequest.setInstanceId(instanceId);
		attachVolumeRequest.setVolumeId(volume.getId());
		attachVolumeRequest.setDevice(volume.getDevice());

		AttachVolumeResult attachResult = client
				.attachVolume(attachVolumeRequest);

		return attachResult;
	}

	@Override
	public String getInstanceId() {
		String id = null;
		try {
			id = introspectionClient.getId();
		} catch (Exception e) {
			log.error(e.toString(), e);
		}

		return id;
	}

	@Override
	public List<String> getExpectedVolumeIds() {
		String detectedInstanceId = getInstanceId();
		if (detectedInstanceId != null) {
			return getExpectedVolumeIds(getInstanceId());
		} else {
			return new ArrayList<String>(0);
		}

	}

	@Override
	public List<String> getExpectedVolumeIds(String instanceId) {
		List<String> volumeIds = new ArrayList<String>();
		AmazonEC2Client client = null;
		try {
			client = factory.getAmazonEC2Client();
			DescribeInstancesRequest describeInstancesRequest = new DescribeInstancesRequest()
					.withInstanceIds(instanceId);

			DescribeInstancesResult rslt = client
					.describeInstances(describeInstancesRequest);

			if (rslt.getReservations().size() == 1) {
				if (rslt.getReservations().get(0).getInstances().size() == 1) {
					List<InstanceBlockDeviceMapping> mappings = rslt
							.getReservations().get(0).getInstances().get(0)
							.getBlockDeviceMappings();
					for (InstanceBlockDeviceMapping mapping : mappings) {
						volumeIds.add(mapping.getEbs().getVolumeId());
					}
				} else {
					log.error("An unexpected number of instances was returned.  Not attempting to determine volume ids.");
					for (Instance instance : rslt.getReservations().get(0)
							.getInstances()) {
						log.error(instance);
					}
				}
			} else {
				log.error("An unexpected number of reservations was returned.  Not attempting to determine volume ids.");
				for (Reservation reservation : rslt.getReservations()) {
					log.error(reservation);
				}
			}
		} catch (AmazonServiceException e) {
			log.error(e);
		} catch (AmazonClientException e) {
			log.error(e);
		} finally {
			if (client != null)
				client.shutdown();
		}

		return volumeIds;
	}

	@Override
	public boolean waitForVolumeAvailability(List<String> volumeIds,
			boolean checkIndefinitely) {
		AwsVolumeStatusUtil util = new AwsVolumeStatusUtil();

		Map<String, Boolean> status = util.isAvailable(
				factory.getAmazonEC2Client(), volumeIds, checkIndefinitely);

		if (status.size() == volumeIds.size()) {
			return true;
		}

		return false;
	}
	
	@Override
	public boolean waitForVolumeAttachment(List<String> volumeIds,
			boolean checkIndefinitely) {
		AwsVolumeStatusUtil util = new AwsVolumeStatusUtil();

		Map<String, Boolean> status = util.isAttached(
				factory.getAmazonEC2Client(), volumeIds, checkIndefinitely);

		if (status.size() == volumeIds.size()) {
			return true;
		}

		return false;
	}

	@Override
	public boolean waitForVolumeDetachment(List<String> volumeIds,
			boolean checkIndefinitely) {
		AwsVolumeStatusUtil util = new AwsVolumeStatusUtil();

		Map<String, Boolean> status = util.isDetached(
				factory.getAmazonEC2Client(), volumeIds, checkIndefinitely);

		if (status.size() == volumeIds.size()) {
			return true;
		}

		return false;
	}

	@Override
	public Collection<String> getVpcIds() {
		return Collections.emptyList();
	}
	
	@Override
	public Map<String, String> getVpcsCidrBlock(List<String> vpcIds) {
		return Collections.emptyMap();
	}

	@Override
	public String associateRouteTable(String routeTableId, String subnetId) {
		//no op
		return null;
	}

	@Override
	public void attachInternetGateway(String internetGatewayId, String vpcId) {
		// no op
	}

	@Override
	public void detachInternetGateway(String internetGatewayId, String vpcId) {
		// no op
	}
	
	@Override
	public String createVPC(String cidrBlock, String instanceTenancy) {
		//no op
		return null;
	}
	
	@Override
	public Map<String, String> getSubnetsCidrBlock(List<String> subnetIds) {
		return Collections.emptyMap();
	}

	@Override
	public String createSubnet(String availabilityZone, String cidrBlock, String vpcId) {
		//no op
		return null;
	}
	
	@Override
	public String getInternetGatewayId(String vpcId) {
		//no op
		
		return null;
	}

	@Override
	public String createInternetGateway() {
		//no op
		return null;
	}

	@Override
	public String createNetworkAcl(String vpcId) {
		//no op
		return null;
	}

	@Override
	public void createNetworkAclEntry(String cidrBlock, boolean egress, String networkAclId, PortRange portRange, String protocol,
											String ruleAction, int ruleNumber) {
		//no op
	}

	@Override
	public void createRoute(String destinationCidrBlock, String instanceId, String gatewayId, String routeTableId) {
		//no op
	}

	@Override
	public String createRouteTable(String vpcId) {
		//no op
		return null;
	}

	@Override
	public void deleteInternetGateway(String internetGatewayId) {
		//no op
	}

	@Override
	public void deleteNetworkAcl(String networkAclId) {
		//no op
	}

	@Override
	public void deleteNetworkAclEntry(String networkAclId, int ruleNumber) {
		//no op
	}

	@Override
	public void deleteRoute(String destinationCidrBlock, String routeTableId) {
		//no op
	}

	@Override
	public void deleteRouteTable(String routeTableId) {
		//no op
	}

	@Override
	public void deleteSubnet(String subnetId) {
		//no op
	}

	@Override
	public void deleteVpc(String vpcId) {
		//no op
	}

	@Override
	public List<NetworkACL> describeNetworkAcls() {
		return Collections.emptyList();
	}

	@Override
	public List<RouteTable> describeRouteTables() {
		return Collections.emptyList();
	}
	
	@Override
	public List<RouteTable> describeRouteTables(String vpcId, Boolean onlyMain) {
		return Collections.emptyList();
	}

	@Override
	public List<Subnet> describeSubnets() {
		return Collections.emptyList();
	}

	@Override
	public List<Vpc> describeVpcs() {
		return Collections.emptyList();
	}
	
	@Override
	public Vpc describeVpc(String vpcId) {
		return null;
	}

	@Override
	public void disassociateRouteTable(String associationId) {
		//no op
	}

	@Override
	public String replaceNetworkAclAssociation(String associationId, String networkAclId) {
		//no op
		return null;
	}

	@Override
	public void replaceNetworkAclEntry(String cidrBlock, boolean egress, String networkAclId, PortRange portRange, String protocol,
											String ruleAction, int ruleNumber) {
		//no op
	}

	@Override
	public void replaceRoute(String destinationCidrBlock, String gatewayId, String instanceId, String routeTableId) {
		//no op
	}

	@Override
	public String replaceRouteTableAssociation(String associationId, String routeTableId) {
		//no op
		return null;
	}
	
	@Override
	public void setSrcDestCheckAttribute(String instanceId, Boolean value) {
		//no op
	}
	
	@Override
	public Map<String, String> describeElasticAddresses() {
		HashMap<String, String> result = new HashMap<String, String>();
		
		AmazonEC2Client client = factory.getAmazonEC2Client();
		
		for (Address address : client.describeAddresses().getAddresses()) {
			result.put(address.getInstanceId(), address.getAllocationId());
		}
		
		return result;
	}
	
	@Override
	public String allocateElasticAddress() {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		
		return client.allocateAddress().getPublicIp();
	}
	
	@Override
	public String allocateElasticAddress(boolean vpcEnabled) {
		//*********ONLY USE THIS CALL FROM SYSTEMBUILDER TO ALLOCATE ELASTIC IPS**********
		//due to how interfaces are handled/marshalled throughout the code,
		//ec2 needs the vpc impl, so not able to create IPs correct in ec2 for correct env
		
		AmazonEC2Client client = factory.getAmazonEC2Client();
		
		if(vpcEnabled == false){
			return client.allocateAddress().getPublicIp();
		}
		else{
			AllocateAddressRequest request = new AllocateAddressRequest().withDomain("vpc");
			return client.allocateAddress(request).getPublicIp();
		}
	}
	
	@Override
	public String associateElasticAddress(String instanceId, String elasticAddress) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		
		Address address = new Address().withPublicIp(elasticAddress);
		DescribeAddressesRequest describeAddressesRequest = new DescribeAddressesRequest();
		describeAddressesRequest.setPublicIps(Collections.singleton(address.getPublicIp()));
		DescribeAddressesResult result = client.describeAddresses(describeAddressesRequest);
		
		String allocationId = result.getAddresses().get(0).getAllocationId();
		AssociateAddressRequest request = new AssociateAddressRequest();
		request.setInstanceId(instanceId);
		request.setAllocationId(allocationId);
		
		return client.associateAddress(request).getAssociationId();
	}
	
	@Override
	public void disassociateElasticAddress(String associationId) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		DisassociateAddressRequest request = new DisassociateAddressRequest().withAssociationId(associationId);
		client.disassociateAddress(request);
	}

	/**
	 * Release an elastic address.
	 *
	 * @param releasableValue The Public IP to be released or the Allocation
	 * 						  ID that is provided when the address is allocated
	 */
	@Override
	public void releaseElasticAddress(String releasableValue) {
		AmazonEC2Client client = factory.getAmazonEC2Client();
		ReleaseAddressRequest request;
		if(Internet.IP_ADDRESS_PATTERN.matcher(releasableValue).find()) {
			// The value to release is specified by an IP Address
			request = new ReleaseAddressRequest().withPublicIp(releasableValue);
		}
		else {
			// The value must be an Allocation Id
			request = new ReleaseAddressRequest().withAllocationId(releasableValue);
		}
		client.releaseAddress(request);
	}
	
	@Override
	public void shareAmi(String amiId, List<String> accountIds) {

		if (amiId != null && accountIds != null) {
			AmazonEC2Client client = null;

			try {
				client = factory.getAmazonEC2Client();
				client.modifyImageAttribute(new ModifyImageAttributeRequest(amiId, "launchPermission").withUserIds(accountIds));
			} catch (AmazonServiceException e) {
				log.error(e.getMessage());
			} catch (AmazonClientException e) {
				log.error(e.getMessage());
			} finally {
				if (client != null)
					client.shutdown();
			}
		}

	}

	@Override
	public List<Instance> listAllRunningInstances() {
		List<Instance> runningInstances = new LinkedList<Instance>();

		AmazonEC2Client client = null;		
		try {
			client = factory.getAmazonEC2Client();		
		
			DescribeInstancesRequest describeInstancesRequest = 
				new DescribeInstancesRequest().withFilters(new Filter("instance-state-name").withValues(
						InstanceStateName.Pending.toString(),
						InstanceStateName.Running.toString(),
						InstanceStateName.ShuttingDown.toString()));
			DescribeInstancesResult result = client.describeInstances(describeInstancesRequest );
		
			List<Reservation> reservations = result.getReservations();
			for (Reservation reservation : reservations) {
				List<Instance> instances = reservation.getInstances();
				for (Instance instance : instances) {
					runningInstances.add(instance);
				}	
			}
		} catch (AmazonServiceException e) {
			log.error(e.getMessage(),e);
		} catch (AmazonClientException e) {
			log.error(e.getMessage(),e);
		}finally {
			if (client != null)
				client.shutdown();
		}

		return runningInstances;
	}

	@Override
	public String retrieveServiceEndpoint() {
		return factory.getServiceEndpoint();
	}
}
