/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.leidos.de.DTU;

import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.util.Enumeration;
import java.util.Map;

import javax.jms.Connection;
import javax.jms.DeliveryMode;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Queue;
import javax.jms.ResourceAllocationException;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;

import org.apache.activemq.ActiveMQSslConnectionFactory;

import com.deleidos.rtws.UploadUtil.DirectoryCrawler;
import com.deleidos.rtws.UploadUtil.FileDecompressor;
import com.deleidos.rtws.UploadUtil.WildcardPatternFilterMap;
import com.deleidos.rtws.splitter.Splitter;
import com.deleidos.rtws.splitter.SplitterFactory;

public class JMSUploader {
	private static final String connection_prefix = "ssl://";
	private static final String connection_postfix = ":61616";
	private static final String store_passwords = "redacted";// todo: change it

	private String[] endpoints;
	private File sourceFile;
	private ArrayList<File> sourceFiles;   
	private String inputFormat;
	private File ks;
	private File ts;
	private int numHeaders;
	private String splitterType;
	private boolean recursive;
	private boolean base64Encode;
	private boolean listen;
	private boolean testConnectionOnly;
	private boolean processZipFiles;

	private Connection[] connections;
	private MessageProducer[] producers;
	private Session[] sessions;
	private MessageConsumer[] consumers;
	private Splitter splitter;
	private WildcardPatternFilterMap filterMap=null;

	private int roundRobinCounter = 0;// iterates after every sent message
	private int messageCounter = 0;

	private int messagesBeforeSwitch = 100;
	
	private boolean stopBetweenMessages = false;
	
	private boolean nextRecordFromGUI=false;
	private boolean needInput=false;
	
	private volatile String currentFileName="N/A";
	private volatile long currentFileSizeBytes = 0;
	private volatile long currentFileProcessedBytes = 0;
	private volatile int fileCount = 0;
	private volatile int filesProcessed = 0;
	private volatile boolean runThis = true;
        private volatile String loaderState = "STOPPED";


	
	//NEW
	
	public JMSUploader() {
	}

	/**
	 * set the location of the activemq nodes to send messages to.
	 * 
	 * @param entries
	 *            a set of public ip addresses or dns names to send messages to.
	 *            Should be ip or dns name only.
	 */
	public void setDestination(String[] entries) {
		for (int i = 0; i < entries.length; i++) {
			entries[i] = connection_prefix + entries[i] + connection_postfix;
		}
		endpoints = entries;
	}

	
	
	public void setRunState(boolean runThisIN) {

	runThis = runThisIN;
	}


     /**
         * set the file or directory to send up to jms.
         * 
         * @param f
         */
        public void setFile(ArrayList<File> files) {
        //public void setFile(File f) {
        //      sourceFile = f;
        sourceFiles = files;
        }

	/*	
	public void setFile(File f) {
		sourceFile = f;
	}
	*/

	/**
	 * set the number of header 'records' to skip (record defined as one entry
	 * from splitter)
	 * 
	 * @param headers
	 *            the number of headers to skip
	 */
	public void setNumHeaders(int headers) {
		numHeaders = headers;
	}

	/**
	 * set the input format of the records
	 * 
	 * @param format
	 *            input format from data model editor
	 */
	public void setInputFormat(String format) {
		inputFormat = format;
	}

	/**
	 * set the location of the keystore and truststore
	 * 
	 * @param keyStoreLocation
	 *            path to key store
	 * @param trustStoreLocation
	 *            path to trust store
	 */
	public void setStoreLocations(File keyStoreLocation, File trustStoreLocation) {
		ks = keyStoreLocation;
		ts = trustStoreLocation;
	}

	public void setSplitter(String splitterType) {
		this.splitterType = splitterType;
	}

	public void setRecursive(boolean r) {
		recursive = r;
	}
	

	public void setBase64Encode(boolean encode) {
		base64Encode = encode;
	}
	
	public void setListenDLQ(boolean listen) {
		this.listen=listen;
	}

	public void processCLI() {

		try {
			validateSettings();
		} catch (Exception e) {
			System.out.println("Error validating arguments: " + e.getMessage());
			System.exit(1);
		}

		try {
			connect(true);
		} catch (Exception e) {
			System.out.println("Error connecting to JMS node(s): "
					+ e.getMessage());
			e.printStackTrace();
			System.exit(1);
		}

		try{
		process(true);
		} catch (Exception e) {
			System.out.println("Error processing data: "
					+ e.getMessage());
			e.printStackTrace();
			System.exit(1);
		}
		
		if(listen){
			System.out.println("Done processing data.  Continuing to listen on DLQ...");
		}else{
			System.out.println("Done processing data.  Begin shutdown...");
		}
		try{
		shutdown(true);
		} catch (Exception e) {
			System.out.println("Error shutting down: "
					+ e.getMessage());
			e.printStackTrace();
			System.exit(1);
		}
	}

	private void shutdown(boolean outputToConsole) throws JMSException {
		loaderState = "SHUTDOWN";
		for (int i = 0; i < sessions.length; i++) {
			try {

				//sessions[i].commit();
				if (!listen) {// if we're listening, we don't want to close
								// anything
					producers[i].close();
					consumers[i].close();
					sessions[i].close();
					connections[i].close();
				}
			} catch (JMSException e) {
				if (outputToConsole) {
					System.out.println(e.getMessage());
					e.printStackTrace();
				} else {
					throw e;
				}

			}
		}
	}

	private void process(boolean outputToConsole) throws Exception {
		if(filterMap==null){
			splitter = SplitterFactory.create(splitterType);
		}else{
			splitter=null;
		}
	         loaderState = "PROCESS";

    for(File sFile : sourceFiles) {
                        sourceFile = sFile;


		DirectoryCrawler crawler = new DirectoryCrawler(sourceFile,recursive);
		
		UploadStatus.INSTANCE.setTotalFiles(crawler.fileCount());
		if(outputToConsole)
			System.out.println("Found " + crawler.fileCount() + " file(s) to process.");
		
		File toProcess;
		while((toProcess = crawler.nextFile())!=null && runThis){
			processFile(toProcess,outputToConsole);
		}
	}
		/*
		if (sourceFile.isDirectory()) {
			if(runThis) {
			int fileCount = countFiles(sourceFile, 0);
			System.out.println("Found " + fileCount + " files to process.");
			UploadStatus.INSTANCE.setTotalFiles(fileCount);
			processDirectory(sourceFile, true);
			}
		} else {
			if(runThis) {
			// is file
			UploadStatus.INSTANCE.setTotalFiles(1);
			processFile(sourceFile, true);
			}
		}
		*/
	}

	private void processFile(File file, boolean outputToConsole)
			throws Exception {
		FileInputStream fis = null;
		try {
			if(runThis) {
			currentFileName = file.getName();
			currentFileSizeBytes = file.length();
			currentFileProcessedBytes = 0;
			if (outputToConsole) {
				System.out.println("Begin processing file "+file.getAbsolutePath()+".");
			}
			if(FileDecompressor.isCompressedType(file) && processZipFiles){//compressed file
				filesProcessed++; 
				currentFileSizeBytes=-1;
				FileDecompressor dc = new FileDecompressor(file);
				if(outputToConsole){
					System.out.println(currentFileName+" will be de-compressed and uploaded.");
				}
				InputStream is;
				while((is = dc.nextEntry())!=null && runThis){
					if(outputToConsole){
						System.out.println("Decompressing and uploading entry: "+dc.entryName()+" from compressed file "+currentFileName);
					}
					processFileStream(outputToConsole, is,dc.entryName());
					waitForInput(outputToConsole);
					
				}
				
			}else{//not compressed file or compressed but not processing as compressed
				fis = new FileInputStream(file);
				processFileStream(outputToConsole, fis,file.getName());
				UploadStatus.INSTANCE.fileProcessed();
				filesProcessed++;	
				waitForInput(outputToConsole);
				if (outputToConsole) {
					System.out.println("Processed file "
							+ UploadStatus.INSTANCE.getProcessedFiles()
							+ " of " + UploadStatus.INSTANCE.getTotalFiles()
							+ ": " + file.getAbsolutePath());
				}
			}
			/* old decompression code
			if (currentFileName.toLowerCase().endsWith("zip") && processZipFiles) {
				ZipInputStream zis = new ZipInputStream(fis);
				ZipEntry entry = null;
				System.out.println(currentFileName+" will be unzipped and uploaded.");
				while ((entry = zis.getNextEntry()) != null) {
					processFileStream(outputToConsole, zis);
					UploadStatus.INSTANCE.fileProcessed();
					waitForInput(outputToConsole);
					if (outputToConsole) {
						System.out.println("Processed part of zip file "
								+ UploadStatus.INSTANCE.getProcessedFiles()
								+ " of " + UploadStatus.INSTANCE.getTotalFiles()
								+ ": Zipfile: " + file.getAbsolutePath()+", Unzipped file: "+entry.getName());
					}
				}
			} else if(currentFileName.toLowerCase().endsWith("tar.gz") && processZipFiles){
				TarArchiveInputStream tarInput = 
					      new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(file)));

					 TarArchiveEntry currentEntry = tarInput.getNextTarEntry();
					 while(currentEntry != null) {
					      processFileStream(outputToConsole,tarInput);
					      System.out.println("Processed part of tar.gz file "
									+ UploadStatus.INSTANCE.getProcessedFiles()
									+ " of " + UploadStatus.INSTANCE.getTotalFiles()
									+ ": tarfile: " + file.getAbsolutePath()+", Untarred file: "+currentEntry.getName());
					 }
					 
			} else {
				fis = new FileInputStream(file);
				processFileStream(outputToConsole, fis);
				UploadStatus.INSTANCE.fileProcessed();
				waitForInput(outputToConsole);
				if (outputToConsole) {
					System.out.println("Processed file "
							+ UploadStatus.INSTANCE.getProcessedFiles()
							+ " of " + UploadStatus.INSTANCE.getTotalFiles()
							+ ": " + file.getAbsolutePath());
				}
			}
			*/
			}//runThis	
		} catch (Exception e) {
			if (outputToConsole) {
				System.out.println(e.getMessage());
				e.printStackTrace();
			} else {
				throw e;
			}
		} finally {
			if (fis != null)
				try {
					fis.close();
				} catch (IOException e) {
				}// ignore
		}
	}

	private void processFileStream(boolean outputToConsole, InputStream fis, String fileName)
			throws JMSException, InterruptedException {
		
		
		if(filterMap!=null){
			Map<String,String> params = filterMap.filter(fileName);
			String recordFormat = params.get(WildcardPatternFilterMap.RECORD_FORMAT_PARAM);
			if(recordFormat == null) {
				throw new JMSException(String.format("Missing required parameter [%s].", WildcardPatternFilterMap.RECORD_FORMAT_PARAM));
			}
			
			String recordHeaderLines = params.get(WildcardPatternFilterMap.RECORD_HEADER_LINES_PARAM);
			if(recordHeaderLines == null) {
				throw new JMSException(String.format("Missing required parameter [%s].", WildcardPatternFilterMap.RECORD_HEADER_LINES_PARAM));
			}
			
			splitter = filterMap.getSplitterForFormat(recordFormat);
			numHeaders = Integer.parseInt(recordHeaderLines);
			inputFormat = params.get(WildcardPatternFilterMap.INPUT_FORMAT_PARAM);
			
			//logger.debug(String.format("Transport updated to use splitter for record format [%s] with [%s] record header lines.", 
				//							recordFormat, recordHeaderLines));
		}
		
		splitter.setInputStream(fis);
		splitter.setNumHeaders(numHeaders);
		String headers = splitter.parseHeaders();

		BasicStringBundler bundler = new BasicStringBundler(65536);
		bundler.setHeaderln(headers);
		String line = null;
		while ((line = splitter.split()) != null) {
		if(runThis) {
			if(base64Encode){
				line = javax.xml.bind.DatatypeConverter.printBase64Binary(line.getBytes());
			}
			String message = bundler.appendln(line);
			if (message != null) {
				currentFileProcessedBytes+=message.length();
				// full message
				if (!testConnectionOnly) {
					TextMessage jmsMessage = sessions[roundRobinCounter
							% producers.length].createTextMessage(message);
					jmsMessage
							.setStringProperty("Data.Format", inputFormat);

					
					try{
					
					producers[roundRobinCounter % producers.length]
							.send(jmsMessage);
					
					}catch(ResourceAllocationException rae){
						//no room to send.  Wait a bit and retry.
						boolean succeeded=false;
						while(!succeeded){
							succeeded=true;
							Thread.sleep(10*1000);//sleep 10 seconds before retrying
							try{
							producers[roundRobinCounter % producers.length]
									.send(jmsMessage);
							}catch(ResourceAllocationException e){
								succeeded=false;
								System.out.println("retry...");
							}
						}
					}
					
				}
				waitForInput(outputToConsole);
				messageCounter++;
				if (messageCounter >= messagesBeforeSwitch) {
					//sessions[roundRobinCounter % producers.length].commit();
					messageCounter = 0;
					roundRobinCounter++;
				}
			}
		}//runThis
		}

		// end of record. send it
		String message = bundler.purge();
		if (message != null && !message.isEmpty()) {
			// short message, less than full, containing rest of record from
			// last message to end of file
			if (!testConnectionOnly) {
				TextMessage jmsMessage = sessions[roundRobinCounter
						% producers.length].createTextMessage(message);
				jmsMessage.setStringProperty("Data.Format", inputFormat);
				producers[roundRobinCounter % producers.length]
						.send(jmsMessage);
			}
			messageCounter++;
			if (messageCounter >= messagesBeforeSwitch) {
				//sessions[roundRobinCounter % producers.length].commit();
				messageCounter = 0;
				roundRobinCounter++;
			}
		}
	}
	
	private void waitForInput(boolean fromConsole){
		if (stopBetweenMessages) {
			if (fromConsole) {
				BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
				System.out.println("Press ENTER to go to next message...");
				try {
					input.readLine();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				// wait for input from GUI.
				needInput=true;
				while (!nextRecordFromGUI) {
					try {
						Thread.sleep(1000);// sleep a second
					} catch (Exception drop) {
					}
				}
				// nextRecordFromGui is now true
				nextRecordFromGUI = false;// reset to false, and continue;
			}
		}
	}
	
	public void guiNextRecord(){
		needInput=false;
		nextRecordFromGUI=true;
	}

	public void processGUI() throws Exception {
		if(runThis) {
		validateSettings();
		}
		if(runThis) {
		connect(false);
		}
		if(runThis) {
		process(false);
		}
		shutdown(false);
	}

	private void validateSettings() throws Exception {
		if(runThis) {
		if (!ts.exists() || !ts.canRead()) {
			throw new Exception(
					"Trust store not found or could not be read at "
							+ ts.getAbsolutePath());
		}
		if (!ks.exists() || !ks.canRead()) {
			throw new Exception("Key store not found or could not be read at "
					+ ks.getAbsolutePath());
		}


    		for(File sFile : sourceFiles) {
               
	         sourceFile = sFile;

		if (!sourceFile.exists() || !sourceFile.canRead()) {
			throw new Exception("File source location " + sourceFile.getAbsolutePath() + " does not exist or cannot be read.");
		}

		}
/*
		if (!sourceFile.exists() || !sourceFile.canRead()) {
			throw new Exception("File source location "
					+ sourceFile.getAbsolutePath()
					+ " does not exist or cannot be read.");
		}
*/
		if (numHeaders < 0) {
			throw new Exception("Number of headers must be non-negative.");
		}

		if(!SplitterFactory.hasTypeDef(splitterType)){
			throw new Exception("No definition found for splitter type "+splitterType);
		}
		}//runThis
	}

	private void connect(boolean toConsole) throws Exception {
		producers = new MessageProducer[endpoints.length];
		consumers = new MessageConsumer[endpoints.length];
		sessions = new Session[endpoints.length];
		connections = new Connection[endpoints.length];
		loaderState = "CONNECT";
		if (runThis) {
			for (int i = 0; i < endpoints.length; i++) {
				if (runThis) {
					String password = "redacted";// TODO: we need a random
														// password,
														// possibly encrypted
					// String store_passwords =
					// ConfigEncryptor.instance().decryptWithWrapper("XXXX");
					ActiveMQSslConnectionFactory conFac = new ActiveMQSslConnectionFactory();
					conFac.setBrokerURL(endpoints[i]);

					TrustManager[] trustManagers = getTrustManagers(ts,
							store_passwords);
					KeyManager[] keyManagers = getKeyManagers(ks,
							store_passwords, "");

					SecureRandom secureRandom = new SecureRandom();

					conFac.setKeyAndTrustManagers(keyManagers, trustManagers,
							secureRandom);

					// conFac.setKeyAndTrustManagers(null, null, new
					// SecureRandom());
					Connection conn = conFac.createConnection("system",
							password);
					conn.start();

					// Create the session
					Session session = conn.createSession(false,
							Session.CLIENT_ACKNOWLEDGE);
					Queue destination = session
							.createQueue("com.deleidos.rtws.parse");
					Queue deadLetterQueue = session
							.createQueue("com.deleidos.rtws.DLQ?consumer.prefetchSize=0");

					MessageConsumer dlqConsumer = session.createConsumer(
							deadLetterQueue, null, false);

					// Create the producer
					MessageProducer producer = session
							.createProducer(destination);

					producer.setDeliveryMode(DeliveryMode.PERSISTENT);

					if (listen) {
						DLQThread thrd = new DLQThread(dlqConsumer, toConsole);
						thrd.start();
					}
					connections[i] = conn;
					sessions[i] = session;
					producers[i] = producer;
					consumers[i] = dlqConsumer;
				}// runThisInner
			}
		}// runThisOuter
	}

	// TODO: the following two methods (getKeyManagers, getTrustManagers) are
	// copied straight from commons-core. redo, and/or clear for open sourcing
	private KeyManager[] getKeyManagers(File keyStoreFile,
			String keyStorePassword, String certAlias)
			throws KeyStoreException, IOException, NoSuchAlgorithmException,
			CertificateException, UnrecoverableKeyException {

		KeyStore keyStore = KeyStore.getInstance("JKS");
		char[] keyStorePwd = (keyStorePassword != null) ? keyStorePassword
				.toCharArray() : null;
		keyStore.load(new FileInputStream(keyStoreFile), keyStorePwd);

		// if certAlias given then load single cert with given alias
		if (certAlias != null) {
			Enumeration<String> aliases = keyStore.aliases();

			while (aliases.hasMoreElements()) {
				String alias = aliases.nextElement();

				if (!certAlias.equals(alias)) {
					keyStore.deleteEntry(alias); // remove cert only load
													// certificate with given
													// alias
				}
			}
		}
		KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory
				.getDefaultAlgorithm());
		kmf.init(keyStore, keyStorePwd);

		return kmf.getKeyManagers();

	}

	private TrustManager[] getTrustManagers(File trustStoreFile,
			String trustStorePassword) throws IOException, KeyStoreException,
			NoSuchAlgorithmException, CertificateException {

		KeyStore trustStore = KeyStore.getInstance("JKS");
		char[] trustStorePwd = (trustStorePassword != null) ? trustStorePassword
				.toCharArray() : null;
		trustStore.load(new FileInputStream(trustStoreFile), trustStorePwd);
		TrustManagerFactory trustManagerFactory = TrustManagerFactory
				.getInstance(TrustManagerFactory.getDefaultAlgorithm());
		trustManagerFactory.init(trustStore);

		return trustManagerFactory.getTrustManagers();

	}
	
	private class DLQThread extends Thread{
		
		MessageConsumer reader;
		boolean outputToConsole;
		
		public DLQThread(MessageConsumer consumer,boolean echoToConsole){
			reader = consumer;
			outputToConsole=echoToConsole;
		}

		public void run() {
			Message m;
			try {

				while (true) {
					while(runThis) {
					m = reader.receive(50);
					if (m != null) {
						TextMessage tm = (TextMessage) m;
						tm.acknowledge();
						//session.commit();
						UploadStatus.INSTANCE.addDeadLetterQueueMessage(tm);
						if (outputToConsole) {
							System.out.println("DLQ: \"" + tm.getText()
									+ "\" Error: "
									+ tm.getStringProperty("Error"));
						}
					}
					// m = reader.receive();
					}//runThis
				}
			} catch (Exception e) {
				System.err
						.println("Error reading dead letter queue message.  Stopping listener for this connection.");
			}

		}

	}

	public void setTestOnly(boolean testOnly) {
		testConnectionOnly = testOnly;
	}

	public void setBatchSize(int batchSize) {
		messagesBeforeSwitch = batchSize;
	}

	public void setInteractive(boolean interactive) {
		stopBetweenMessages=interactive;
	}
	
	public boolean getNeedInputFromGui(){
		return needInput;
	}
	
	public String getCurrentlyProcessingFileName(){
		return currentFileName;
	}
	
	public long getCurrentlyProcessingFileSize(){
		return currentFileSizeBytes;
	}
	
	public long getCurrentlyProcessingFileProcessedBytes(){
		return currentFileProcessedBytes;
	}

	public int getFileCount(){
		return fileCount;
	}

	public int getFilesProcessed(){
		return filesProcessed;
	}

	public void setProcessZipFiles(boolean processZip) {
		processZipFiles = processZip;
	}

	public boolean getProcessZipFiles() {
		return processZipFiles;
	}

	public String getLoaderState() {
		return loaderState;
	}

	public void setInputMapping(String patternMap) {
		if(patternMap!=null && !patternMap.isEmpty()){
			filterMap = new WildcardPatternFilterMap();
			filterMap.buildFilterMap(patternMap);
		}
	}

}
