/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.master.core;

import static com.deleidos.rtws.commons.util.regex.Internet.FQDN_GROUP_DOMAIN;
import static com.deleidos.rtws.commons.util.regex.Internet.FQDN_GROUP_HOST;
import static com.deleidos.rtws.commons.util.regex.Internet.FQDN_PATTERN;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Queue;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.deleidos.rtws.commons.cloud.ProcessState;
import com.deleidos.rtws.commons.cloud.beans.FirewallGroup;
import com.deleidos.rtws.commons.cloud.beans.Process;
import com.deleidos.rtws.commons.cloud.beans.ProcessDefinition;
import com.deleidos.rtws.commons.cloud.platform.ServiceInterface;
import com.deleidos.rtws.commons.cloud.platform.StorageInterface;
import com.deleidos.rtws.commons.config.RtwsConfig;
import com.deleidos.rtws.commons.config.UserDataProperties;
import com.deleidos.rtws.commons.jersey.config.JerseyClientConfig;
import com.deleidos.rtws.commons.net.dns.DnsClient;
import com.deleidos.rtws.commons.net.dns.exception.DNSException;
import com.deleidos.rtws.commons.util.env.SystemEnvUtil;
import com.deleidos.rtws.master.core.ProcessTable.Evictable;
import com.deleidos.rtws.master.core.ProcessTable.Reservable;
import com.deleidos.rtws.master.core.beans.ShutdownHook;
import com.deleidos.rtws.master.core.client.RestClientManager;
import com.deleidos.rtws.master.core.dao.ProcessDao;
import com.deleidos.rtws.master.core.exception.AllocationException;
import com.deleidos.rtws.master.core.exception.ServiceException;
import com.deleidos.rtws.master.core.lock.ProcessChangeLock;
import com.deleidos.rtws.master.core.management.ManagementContext;
import com.deleidos.rtws.master.core.monitor.BasicProcessControllerMonitor;
import com.deleidos.rtws.master.core.net.dns.query.dao.DNSAddressThreadListener;
import com.deleidos.rtws.master.core.net.dns.query.dao.DNSAnchorThreadListener;
import com.deleidos.rtws.master.core.util.HashUtil;
import com.deleidos.rtws.master.core.util.NatUtil;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;

/**
 * Handles the allocation and deallocation of processes with a group. Processes
 * within a group are intended to have a common purpose, and thus have a common
 * template and allocation policy.
 */
public class BasicProcessController extends AbstractProcessController implements
		ProcessController {

	private static final Logger log = Logger
			.getLogger(BasicProcessController.class);

	/** The service provider being used to manage remote processes. */
	private ServiceInterface provider;

	/** The storage implementation */
	private StorageInterface storageImpl;

	/**
	 * The DAO that is being used to save process state for allocated processes.
	 */
	private ProcessDao dao;

	/**
	 * The number to be placed after the public DNS of the node launched
	 */
	private int numPublic = 1;
	
	/** The utility class that is being used to update the DNS server. */
	private DnsClient dns;

	//private InternetDnsClient internetDns;

	/** The management context used to expose managed objects through JMX. */
	private ManagementContext jmx;

	/** The monitor for watching all the process groups status */
	private BasicProcessControllerMonitor monitor;
	
	/** The IP address where the DNS server is running. */
	private String dnsAddress;

	/** List of processes currently being managed in this group. */
	private ProcessTable processes = new ProcessTable();

	/** Executor used to multi-thread process allocation. */
	private ExecutorService executor;
	
	private ExecutorService dnsServiceExecutor;

	/**
	 * The nodes will store information in tags. Set to true because it is the
	 * preferred value and need for JUnit.
	 */
	private boolean taggingEnabled = true;

	/**
	 * Hash utility used to generate a hash value.
	 */
	private HashUtil hashUtil;
	
	private Client client;
	
	/**
	 * Process group node # regex.
	 */
	private Pattern nodeNumber = Pattern.compile("\\d+");
	
	private int maxProcessGroupInstancesToSpawnConcurrently = 1;
	
	
	/**
	 * Constructor.
	 * @throws ServiceException 
	 */
	public BasicProcessController(){
		super();
		setHashUtil(new HashUtil());
		
		client = Client.create(JerseyClientConfig.getInstance().getInternalConfig());
		
		String cloudProviderKey = RtwsConfig.getInstance().getString("rtws.cloud.provider", "EUC");	
		if (log.isDebugEnabled())
			log.debug(String.format("%s process group instances will be launched concurrently.", maxProcessGroupInstancesToSpawnConcurrently));
		
		maxProcessGroupInstancesToSpawnConcurrently = Integer.valueOf(RtwsConfig.getInstance().getString("master." + cloudProviderKey + ".max.concurrent.process.allocation", "1"));
		
		executor = Executors.newFixedThreadPool(maxProcessGroupInstancesToSpawnConcurrently);
	}

	/**
	 * Returns the service provider being used to manage remote processes.
	 */
	public ServiceInterface getServiceInterface() {
		return provider;
	}

	/**
	 * Sets the service provider that should be used to manage remote processes.
	 */
	public void setServiceInterface(ServiceInterface bean) {
		provider = bean;
	}

	/**
	 * Returns the storage implementation.
	 */
	public StorageInterface getStorageInterface() {
		return storageImpl;
	}

	/**
	 * Sets the service provider that should be used to manage remote processes.
	 */
	public void setStorageInterface(StorageInterface impl) {
		storageImpl = impl;
	}

	/**
	 * Returns the DAO that is being used to save process state for allocated
	 * processes.
	 */
	public ProcessDao getProcessDao() {
		return dao;
	}

	/**
	 * Sets the DAO that should be used to save process state for allocated
	 * processes.
	 */
	public void setProcessDao(ProcessDao bean) {
		dao = bean;
	}

	/**
	 * Returns the utility class that is being used to update the DNS server.
	 */
	public DnsClient getDnsClient() {
		return dns;
	}

	/**
	 * Sets the utility class that should be used to update the DNS server.
	 */
	public void setDnsClient(DnsClient bean) {
		dns = bean;
	}
	
	public void setDnsService(ExecutorService dnsServiceExecutor){
		this.dnsServiceExecutor = dnsServiceExecutor;
	}
	
	public ExecutorService getDnsService(){
		return dnsServiceExecutor;
	}

	//Do not remove set method for HashUtil this allows the hashUtil to be mocked during unit test.
	//the rest call to get a hash during testing has to be mocked.  Should not be called from outside this class.
	/**
	 * Sets the {@link HashUtil}.
	 * 
	 * @param hashUtil
	 */
	public void setHashUtil(HashUtil hashUtil){
		this.hashUtil = hashUtil;
	}

	/**
	 * The management context used to expose managed objects through JMX.
	 */
	public ManagementContext getManagementContext() {
		return jmx;
	}

	/**
	 * The management context used to expose managed objects through JMX.
	 */
	public void setManagementContext(ManagementContext bean) {
		jmx = bean;
	}

	/**
	 * Returns the IP address where the DNS server is running.
	 */
	public String getDnsAddress() {
		return dnsAddress;
	}

	/**
	 * Sets the IP address where the DNS server is running.
	 */
	public void setDnsAddress(String dnsAddress) {
		this.dnsAddress = dnsAddress;
	}

	/**
	 * Returns the number of processes that are currently allocated.
	 */
	public final int getActiveProcessCount() {
		return processes.size();
	}

	/**
	 * Returns the list of currently active processes.
	 */
	public Collection<Process> getActiveProcesses() {
		return processes.list();
	}

	/**
	 * Returns the "high-water-mark" for number of processes in this group.
	 */
	public final int getPersistentProcessCount() {
		return dao.findByGroup(name).size();
	}

	/**
	 * Returns the list of all previously allocated processes in this group.
	 */
	public Collection<Process> getPersistentProcesses() {
		return dao.findByGroup(name);
	}

	/**
	 * Gets the process table implementation being used to track active
	 * processes (used for testing).
	 */
	protected final ProcessTable getProcessTable() {
		return processes;
	}

	/**
	 * Sets the process table implementation to be used to track active
	 * processes (used for testing).
	 */
	protected final void setProcessTable(ProcessTable table) {
		this.processes = table;
	}

	public boolean isTaggingEnabled() {
		return taggingEnabled;
	}

	public void setTaggingEnabled(boolean enabled) {
		taggingEnabled = enabled;
	}

	/**
	 * Determines the state of the given process.
	 */
	public final ProcessState status(Process process) {
		return provider.status(process);
	}

	/**
	 * Attempts to discover the current status of each processes known (by the
	 * ProcessDao) to be associated with this group, adding or removing each
	 * process to/from the internally managed list of active processes as
	 * appropriate.
	 */
	public final void sync() {

		log.info("Synchronizing process state for group '" + name + "'.");
		for (Process process : dao.findByGroup(name)) {

			String fqdn = process.getPersistentDnsName();
			ProcessState state = provider.status(process);
			if (state == ProcessState.RUNNING) {

				try {

					log.info("Process '" + fqdn + "' is currently running.");

					// Rebind the DNS address. Technically this is only needed
					// if the entire node
					// has been rebooted. However, there is no way to know what
					// the current state
					// is, and doing it when it is not needed doesn;t hurt
					// anything.
					String ip = process.getPrivateIpAddress();
					log.info("Re-binding DNS address '" + ip + "' for host '"
							+ fqdn + "'.");
					dns.bind(fqdn, ip);

					processes.insert(process);
					if (jmx != null) {
						jmx.manage(process);
					}

				} catch (IOException e) {
					// If the process's DNS name can't be bound, then it is
					// effectively unreachable by
					// any other process. Since we don't know whether other
					// processes need to reach it,
					// the safest assumption is that the process can't function
					// correctly, shutting it
					// down now will at least put the system into a consistent
					// state.
					try {
						provider.terminate(process, true, true);
					} catch (Exception ignore) {
					}
					processes.remove(process);
					if (jmx != null) {
						jmx.release(process);
					}
				}

			} else {
				processes.remove(process);
				if (jmx != null) {
					jmx.release(process);
				}
			}
		}
	}

	/**
	 * Allocates an additional process to this group.
	 */
	public final Process allocateProcess() throws ServiceException {

		// Figure out the DNS name for the next process to be started.
		Reservable slot = processes.reserve();
		String fqdn = generateNextDnsName(slot.index());

		// See if a process by this name has been allocated in the past.
		Process process = dao.findByDns(fqdn);
		if (process == null) {
			process = new Process();
			process.setGroup(name);
			process.setNumber(slot.index());
			process.setPersistentDnsName(fqdn);
			process.setSubnetId(group.getDefinition().getSubnet());
		}

		// Create the process and add it to the active process list.
		try {
			//update system lock status
			ProcessChangeLock.getInstance().generateLock(process.getGroup(), process.getPersistentDnsName());
			allocateProcessInternal(process);
			slot.fill(process);
			return process;
		} finally {
			slot.release();
		}

	}

	/**
	 * Re-creates the given process, adding it to this group.
	 */
	public final void allocateProcess(Process process) throws ServiceException {
		try {
			//update system lock status
			ProcessChangeLock.getInstance().generateLock(process.getGroup(), process.getPersistentDnsName());
			
			processes.insert(process);
			allocateProcessInternal(process);
		} catch (RuntimeException e) {
			throw new AllocationException(
					"Unable to re-instantiate previously allocated process.", e);
		}
	}

	/**
	 * Creates the given process.
	 */
	private Process allocateProcessInternal(Process process)
			throws ServiceException {
		String initialLockId = process.getPersistentDnsName();
		ProcessChangeLock.getInstance().generateLock(process.getGroup(), process.getPersistentDnsName());
		try{
			boolean exists = dao.contains(process);
			String fqdn = process.getPersistentDnsName();
	
			// Tailor the process definition template to this specific instance.
			ProcessDefinition template = group.getDefinition().clone();
			template.getProperties().setProperty("RTWS_DNS_ADDRESS", dnsAddress);
			template.getProperties().setProperty("RTWS_FQDN", fqdn);
			template.getProperties().setProperty("RTWS_TENANT_ID",
					System.getProperty("RTWS_TENANT_ID"));
			template.getProperties().setProperty("RTWS_BUCKET_NAME",
					System.getProperty("RTWS_BUCKET_NAME"));
			template.getProperties().setProperty("RTWS_DOMAIN",
					System.getProperty("RTWS_DOMAIN"));
			template.getProperties().setProperty("RTWS_MOUNT_MODE",
					System.getProperty("RTWS_MOUNT_MODE", ""));
			template.getProperties().setProperty("RTWS_MOUNT_DEVICE",
					System.getProperty("RTWS_MOUNT_DEVICE"));
			template.getProperties().setProperty("RTWS_SW_VERSION",
					System.getProperty("RTWS_SW_VERSION"));
			template.getProperties().setProperty("RTWS_ROOT_LOG_LEVEL",
					System.getProperty("RTWS_ROOT_LOG_LEVEL"));
			template.getProperties().setProperty("RTWS_APP_LOG_LEVEL",
					System.getProperty("RTWS_APP_LOG_LEVEL"));
			template.getProperties().setProperty("RTWS_PROCESS_GROUP", process.getGroup());
			if (StringUtils.isNotBlank(System.getProperty("RTWS_STORAGE_ENDPOINT"))) {
				template.getProperties().setProperty("RTWS_STORAGE_ENDPOINT",
						System.getProperty("RTWS_STORAGE_ENDPOINT"));
			}
			if(StringUtils.isNotBlank(UserDataProperties.getInstance().getString(UserDataProperties.RTWS_IS_TMS))){
				template.getProperties().setProperty(UserDataProperties.RTWS_IS_TMS, 
						UserDataProperties.getInstance().getString(UserDataProperties.RTWS_IS_TMS));
			}
			
			String encodedHash = hashUtil.getHash(System.getProperty("RTWS_DOMAIN"));
			template.getProperties().setProperty(UserDataProperties.RTWS_SETUP_KEY, encodedHash);
			
			// If max requested, supply it :)
			if (template.getProperties().containsKey("RTWS_MAX_ALLOCATION_REQUEST")) {
				template.getProperties().setProperty("RTWS_MAX_ALLOCATION_REQUEST",
						String.valueOf(group.getAllocationPolicy().getMax()));
			}
	
			// The process allocation policy has the information that is needed to
			// determine if
			// a process can have an elastic IP address. If the process cannot have
			// an elastic IP
			// address, the decision will be logged and the allocate persistent
			// address variable will
			// be set to false. If the process can allocate an elastic IP address it
			// will be done in the
			// complete method.
			if ((template.getAllocatePersistentAddress())
					&& (!(canHaveElasticIP()))) {
				// Set the allocate persistent address to false.
				template.setAllocatePersistentAddress(false);
				// Create the elastic IP address error message.
				String groupElasticIPErrorMessage = "Unable to assign elastic IP address to group, must set the following parameters in the "
						+ "process group: min=1, max=1 and auto allocation policy = 0";
				log.error(groupElasticIPErrorMessage);
			}
			
			if (template.getSubnet() != null) {
				String vpcId = provider.self().getVpcId();
				String securityId = getVpcSecurityGroupId(vpcId, template.getSecurity());
				template.setSecurityId(securityId);
				template.setSecurity(null);
			}
	
			// Create/start the process.
			log.info("Creating process '" + fqdn + "' from template.");
			try {
				provider.create(template, process);
			} catch (RuntimeException e) {
				throw new AllocationException("Unable to create process '" + fqdn
						+ ".", e);
			}
	
			// Check if an Internet address is assigned.
			if (template.getAllocatePersistentAddress()) {
				log.info("Starting a DNS Listenr Thread");
				// Start an new DNS listener to get the updated public DNS Name. It
				// will also be used for the Internet address if one is assigned.
				DNSAddressThreadListener dnsAddressThreadListener = new DNSAddressThreadListener(
						provider, dao, process);
				Thread dnsListener = new Thread(dnsAddressThreadListener);
				dnsListener.start();
				// Not assigning an Elastic IP, but will assign an Elastic IP.
			} else if (template.getAllocateInternetAddress()) {
				// Set this in the processes.xml file.
				process.setAllocateInternetAddress(true);
				template.setInternetAddress(template.getInternetAddress().replaceAll("\\?", String.valueOf(numPublic++)));
				log.info("Assigning " + template.getInternetAddress() + " to "
						+ process.getPublicIpAddress());
				
				// Assign the Internet address to the public DNS.
				assignInternetAddress(template.getInternetAddress(), process.getPublicIpAddress(), process.getPrivateIpAddress());
			}
	
			// Save the process' meta-data so it is available if the master node is
			// restarted.
			try {
				log.info("Saving processes state for '" + fqdn + "'.");
				dao.store(process);
			} catch (Exception e) {
				// In cases where the process meta-data can't be stored, it may not
				// be possible to restart
				// the process in the future, or for a failover master node to take
				// ownership of the cluster.
				// To be safe, the process needs to be treaded as if it didn't
				// start; terminate it. However,
				// depending whether it is being created from scratch for the first
				// time, or whether it is
				// being re-created from already saved state, it may not be safe to
				// discard attached resources
				// (like elastic IP addresses and volume id's). If the process is
				// brand new, it's resources
				// can be discarded, otherwise they must be retained.
				try {
					provider.terminate(process, exists, true);
				} catch (Exception ignore) {
				}
				throw new AllocationException(
						"Unable to persist meta-data while starting remote process '"
								+ fqdn + "'; terminating process.", e);
				
			}
	
			// Assign some useful meta-data to the process so that the process is
			// easily identifiable
			// through the management console.
			if (taggingEnabled) {
				try {
					provider.assignAttributes(process,
							buildAttributes(fqdn, group.getName()));
				} catch (Exception e) {
					// This meta-data is only used for informational purposes; the
					// system is not dependent on
					// it. If it fails, it won't prevent anything from working
					// correctly, so the error can be
					// ignored.
					log.warn("Unable to assign meta-data attributes to process.", e);
				}
			}
	
			// Bind the dynamically assigned IP address to the local DNS.
			try {
	
				String ip = process.getPrivateIpAddress();
				log.info("Binding DNS address '" + ip + "' for host '" + fqdn
						+ "'.");
				dns.bind(fqdn, ip);
				log.info("Binding DNS address '" + ip + "' for host '" + fqdn
						+ "' complete.");
				
				//if system is running with a configured NAT add IP table entries for external internet access through NAT
				if(SystemEnvUtil.isNatConfigured()){
					DNSAnchorThreadListener dnsUpdateThread = NatUtil.performProcessGroupOperations(process.getGroup(), ip, 
																			template.getAllocateInternetAddress(), fqdn);
					if(dnsUpdateThread != null){
						dnsServiceExecutor.execute(dnsUpdateThread);
					}
				}
			} catch (IOException e) {
				// If the process's DNS name can't be bound, then it is effectively
				// unreachable by
				// any other process. Since we don't know whether other processes
				// need to reach it,
				// the safest assumption is that the process can't function
				// correctly and should
				// be shut down. However, since it's meta-data has been successfully
				// saved, there
				// is nothing to prevent it form starting successfully in the
				// future; it's attached
				// resources can be retained for future use.
				try {
					provider.terminate(process, true, true);
				} catch (Exception ignore) {
				}
				
				throw new AllocationException(
						"Unable to bind DNS name while starting remote process '"
								+ fqdn + "'.", e);
			}
	
			if (jmx != null) {
				log.info("Managing JMX beans for process "+fqdn+".");
				jmx.manage(process);
				log.info("JMX beans published for process "+fqdn+".");
			}
		}finally{
			//release lock
			if(initialLockId == process.getId()){
				ProcessChangeLock.getInstance().releaseLock(process.getGroup(), process.getPersistentDnsName());
			}
			else{
				ProcessChangeLock.getInstance().releaseLock(process.getGroup(), initialLockId);
			}
		}
		log.info("Process "+process.getPersistentDnsName()+" allocated.");
		return process;

	}

	/**
	 * Attempts to allocate the given number of processes. Process state may be
	 * reused from previously running instances. If process creation fails for
	 * any of the requested processes, this method will create and return as
	 * many as possible.
	 * 
	 * @return The list of successfully created processes.
	 */
	public Collection<Process> allocateProcesses(int count)
			throws ServiceException {

		Exception error = null;
		
		checkPoolBeforeAllocation();

		// Submit each process allocation task for background execution.
		Queue<Future<Process>> tasks = new LinkedList<Future<Process>>();
		for (int i = 0; i < count; i++) {
			// Collect the "pending" results into a list.
			tasks.add(executor.submit(new AllocateProcessInBackground()));
		}

		// Wait for each task to complete.
		LinkedList<Process> results = new LinkedList<Process>();
		while (!tasks.isEmpty())
			try {
				// Collect each deallocated process into a list.
				results.add(tasks.remove().get());
			} catch (Exception e) {
				// If something goes wrong, log but ignore it. The caller will
				// have to sort it
				// out by comparing the number of returned results to the number
				// of requested.
				log.warn(e.getMessage());
				error = e;
			}

		if (!results.isEmpty()) {
			return results;
		} else {
			throw new AllocationException("Unable to allocate any of the "
					+ count + " requested processes.", error);
		}

	}

	/**
	 * Recreates processes from the given list, reusing process state for each
	 * instance. If process creation fails for any of the requested processes,
	 * this method will create and return as many as possible.
	 * 
	 * @return The list of successfully created processes.
	 */
	public Collection<Process> allocateProcesses(Collection<Process> list)
			throws ServiceException {

		Exception error = null;
		
		checkPoolBeforeAllocation();

		// Submit each process allocation task for background execution.
		Queue<Future<Process>> tasks = new LinkedList<Future<Process>>();
		for (Process process : list) {
			// Collect the "pending" results into a list.
			tasks.add(executor.submit(new AllocateProcessInBackground(process)));
		}

		// Wait for each task to complete.
		LinkedList<Process> results = new LinkedList<Process>();
		while (!tasks.isEmpty())
			try {
				// Collect each deallocated process into a list.
				results.add(tasks.remove().get());
			} catch (Exception e) {
				// If something goes wrong, log but ignore it. The caller will
				// have to sort it
				// out by comparing the number of returned results to the number
				// of requested.
				log.warn(e.getMessage());
				error = e;
			}

		if (!results.isEmpty()) {
			return results;
		} else {
			throw new AllocationException(
					"Unable to allocate any of the requested processes.", error);
		}

	}

	/**
	 * Deallocates the highest numbered process in this group. The process is
	 * terminated, but any attached storage is left intact, allowing it to be
	 * re-attached when the process is re-created.
	 */
	public final Process deallocateProcess() {

		// Pick a process to deallocate.
		Evictable slot = processes.evict();
		if (slot == null) {
			throw new IllegalStateException("No remaining processes.");
		}

		Process process = null;  //need access to process object in finally
		try {
			process = slot.clear();
			
			//lock for process change
			ProcessChangeLock.getInstance().generateLock(process.getGroup(), process.getPersistentDnsName());
			
			String fqdn = process.getPersistentDnsName();
			
			ProcessState state = provider.status(process);

			// only if the state is running, then call shutdown
			if (ProcessState.RUNNING.name().equals(state.name())) {
				// Shut down the applications running on the instance. Amazon
				// may not wait long
				// enough for the unix init.d scripts to complete. So the
				// shutdown needs to be
				// done outside the Amazon stop instance request.
				try {
					log.info("Stopping applications for process '" + fqdn + "'");
					long startTime = System.currentTimeMillis();
					shutdownRemoteProcesses(process.getPersistentDnsName(),
							process.getInternetAddress(),
							process.getAllocateInternetAddress());
					long totalTime = ((System.currentTimeMillis() - startTime) / 1000) * 60; // stop
																								// time
																								// in
																								// seconds
					log.debug(String
							.format("Time to finish stopping processes for %s took:  %d seconds.",
									fqdn, totalTime));
				} catch (Exception e) {
					// There's pretty much no way to recover from this; just let
					// Amazon kill it.
					log.warn(
							"Unable to gracefully stop applications for process '"
									+ fqdn + "'.", e);
				}

				log.info("Terminating process '" + fqdn + "'.");
				long startTime = System.currentTimeMillis();
				provider.terminate(process, true, false);
				long totalTime = ((System.currentTimeMillis() - startTime) / 1000) * 60; // stop
																							// time
																							// in
																							// seconds
				log.debug(String
						.format("Time to finish terminating instance for %s took:  %d seconds.",
								fqdn, totalTime));
				if (jmx != null) {
					jmx.release(process);
				}
				
				if (monitor != null) {
					if (monitor.isRunning()) {
						if (!monitor.isLocked())
							monitor.stop();
					}
				}
				
			} else {
				log.info(String
						.format("The process %s is not in a running state, skipping shutdown process.",
								fqdn));
			}

			return process;

		}catch(ServiceException e){
			log.error(e.toString(), e);
			return null;
		}
		finally {
			slot.release();
			//release lock for process change
			ProcessChangeLock.getInstance().releaseLock(process.getGroup(), process.getPersistentDnsName());
		}

	}

	/**
	 * Deallocated the given number of processes.
	 */
	public Collection<Process> deallocateProcesses(int count) {

		// Submit each process deallocation task for background execution.
		Queue<Future<Process>> tasks = new LinkedList<Future<Process>>();
		for (int i = 0; i < count; i++) {
			// Collect the "pending" results into a list.
			tasks.add(executor.submit(new DeallocateProcessInBackground()));
		}

		// Wait for each task to complete.
		LinkedList<Process> results = new LinkedList<Process>();
		while (!tasks.isEmpty())
			try {
				// Collect each deallocated process into a list.
				results.add(tasks.remove().get());
			} catch (Exception e) {
				// If something goes wrong, log but ignore it. The caller will
				// have to sort it
				// out by comparing the number of returned results to the number
				// of requested.
				log.warn(e.getMessage());
			}
		
		// If there are no more process instances to manage, shutdown thread pool with the assumption that
		// the system is shutting down
		if (getActiveProcessCount() == 0) {
			log.info("All processes have been terminated, shutting down thread pool.");
			executor.shutdown();
		}
			

		return results;

	}
	
	/**
	 * Locate the security group id given the vpc id and security group name.
	 */
	private String getVpcSecurityGroupId(String vpcId, String groupName) {
		
		for (Entry<String, FirewallGroup> entry : provider.listFirewallGroupsById().entrySet()) {
			if (entry.getValue().getVpcId() != null && vpcId.equals(entry.getValue().getVpcId()) && 
				entry.getValue().getName().equals(groupName)) {
				return entry.getKey();
			}
		}
		
		return null;
		
	}

	/**
	 * Uses the configured shutdown hook to terminate remote processes on the
	 * given host.
	 */
	private void shutdownRemoteProcesses(String fqdn, String publicDnsName,
			boolean hasInternetAddress) throws Exception {
		ShutdownHook hook = getProcessGroup().getShutdownHook();
		if (hook != null) {
			hook.shutdown(fqdn);
		}

		try{
			unbindRestCall(publicDnsName, fqdn, hasInternetAddress);
		}catch(Exception e){
			//expected to fail for tms master and auth, auth will shutdown before unbind 
			//can be called for itself and master
			log.warn(String.format("Failed to unbind %s, error:  %s",publicDnsName, e.toString()), e);
		}
	}

	/**
	 * Generate a DNS name for the next process to be allocated based on the
	 * pattern defined in the allocation policy; replaces any '?' characters in
	 * the pattern with a one-up number.
	 */
	private String generateNextDnsName(int number) {
		return policy.getFqdn().replaceAll("\\?", String.valueOf(number));
	}

	/**
	 * Builds a properties object to describe some common attributes of a
	 * process.
	 */
	protected static Properties buildAttributes(String fqdn, String group) {

		Matcher matcher = FQDN_PATTERN.matcher(fqdn);
		if (!matcher.matches()) {
			throw new IllegalArgumentException("Invalid domain name syntax '"
					+ fqdn + "'.");
		}

		String host = matcher.group(FQDN_GROUP_HOST);
		String domain = matcher.group(FQDN_GROUP_DOMAIN);

		Properties attributes = new Properties();
		attributes.setProperty("Host", host);
		attributes.setProperty("Domain", domain);
		attributes.setProperty("Group", group);
		attributes.setProperty("SW_Version", UserDataProperties.getInstance().getString(UserDataProperties.RTWS_SW_VERSION,"unknown"));
		// setting "Name" allows easy identification through various ec2 client guis
		attributes.setProperty("Name", domain + "." + host);

		return attributes;

	}

	/**
	 * Inner class used to create processes in a background thread.
	 */
	private class AllocateProcessInBackground implements Callable<Process> {
		private Process process;

		public AllocateProcessInBackground() {
			this.process = null;
		}

		public AllocateProcessInBackground(Process process) {
			this.process = process;
		}

		public Process call() throws Exception {
			if (process == null) {
				return allocateProcess();
			} else {
				allocateProcess(process);
				return process;
			}
		}
	}

	/**
	 * Inner class used to deallocate processes in a background thread.
	 */
	private class DeallocateProcessInBackground implements Callable<Process> {
		public Process call() throws Exception {
			return deallocateProcess();
		}
	}

	/**
	 * Determines if a group can assign an elastic IP address to a node. The
	 * rules are that there can be only one instance of the node and no other
	 * instances can be assigned. Therefore, in order to assign an elastic IP,
	 * the Process group has to have its max and min set to one and the auto
	 * allocation policy to zero. This will make sure there is only one node.
	 * 
	 * @return If the elastic IP address can be assigned.
	 */
	private boolean canHaveElasticIP() {
		// Test that minimum and maximum nodes is set to one.
		// Do not want to proliferate the number of elastic IPs.
		if ((policy.getMax() == 1) && (policy.getMin() == 1)
				&& (policy.getAutoAllocationLimit() == 0)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method to assign the Internet Address.
	 * 
	 * 
	 * @param fqdn
	 *            - Fully-qualified domain name
	 * @param address
	 *            - Actual IP address
	 * @param recordType
	 *            - Type of record, usually CNAME or A.
	 */

	private void assignInternetAddress(String fqdn, String publicAddress, String privateAddress) {
		try {
			//bind public dns entry for instance to local dns and public dns servers
			dns.bind(fqdn, privateAddress);
			DNSAnchorThreadListener dnsListener = new DNSAnchorThreadListener(publicAddress, fqdn, true);
			
			dnsServiceExecutor.execute(dnsListener);
		} catch (Exception e) {
			log.error(String.format("Unable to bind IP address %s to fqdn name %s:  %s", publicAddress, fqdn, e.getMessage()), e);
			
		}
	}

	@Override
	public Collection<Process> getProcesses() {
		Collection<Process> processList = new ArrayList<Process>();
		for (Process process : processes.list()) {
			processList.add(process);
		}
		return processList;
	}
	
	private void unbindRestCall(String dnsEntry, String fqdn, boolean hasInternetAddress) throws ServiceException{
		String dnsUrl = RtwsConfig.getInstance().getString("webapp.dnsapi.url.path");
		String domain = null;
		Matcher matcher = FQDN_PATTERN.matcher(fqdn);

		if(matcher.matches()) {
			domain = matcher.group(2);
		} else {
			throw new IllegalArgumentException("Invalid domain name '" + fqdn + "'.");
		}
		
		log.debug(String.format("Shutdown info:  fqdn:  %s, dnsEntry:  %s, domain:  %s, hasInternetAddress:  %s", fqdn, dnsEntry, domain, Boolean.toString(hasInternetAddress)));
		
		try{
			dns.unbind(domain, fqdn);
		}catch(DNSException e){
			log.error(e.toString(), e);
		}
		
		if(hasInternetAddress == true){
			if(dnsUrl != null){
				//replace process internetAddress template with fqdn number
				if(dnsEntry.contains("?") == true){
					Matcher numMatcher = nodeNumber.matcher(fqdn);
					if(numMatcher.find()){
						dnsEntry = dnsEntry.replace("?", numMatcher.group());
					}
				}
				
				WebResource resource = this.client.resource(String.format("%s/rest/dns/delete/dnsentry/%s/%s", dnsUrl, dnsEntry, domain));
				
				log.info(resource.getURI().toString());
				
				ClientResponse response = resource.delete(ClientResponse.class);
				log.info(response.getEntity(String.class));
			}
			else{
				throw new ServiceException("Unable to unbind public dns entry no dnsUrl in properties, webapp.dnsapi.url.path");
			}
		}
	}
	
	public void startMonitor() {
		if(monitor == null) {
			monitor = new BasicProcessControllerMonitor(this);
			if(jmx != null) {
				jmx.register(monitor);
			}
		}
		monitor.start();
	}

	public BasicProcessControllerMonitor getMonitor() {
		return monitor;
	}
	
	private void checkPoolBeforeAllocation() {
		
		if (executor == null) {
			throw new IllegalStateException("System shutdown is in progress, unable to use existing thread pool for new process group allocation.");
		}
	}
}
