/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.master.core;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.management.ObjectName;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;

import org.apache.commons.lang.exception.ExceptionUtils;
import org.apache.log4j.Logger;

import com.deleidos.rtws.commons.cloud.ProcessState;
import com.deleidos.rtws.commons.cloud.beans.Process;
import com.deleidos.rtws.commons.cloud.exception.StorageException;
import com.deleidos.rtws.commons.cloud.platform.ServiceInterface;
import com.deleidos.rtws.commons.cloud.platform.StorageInterface;
import com.deleidos.rtws.commons.cloud.util.InterfaceConfig;
import com.deleidos.rtws.commons.config.PropertiesUtils;
import com.deleidos.rtws.commons.config.RtwsConfig;
import com.deleidos.rtws.commons.config.UserDataProperties;
import com.deleidos.rtws.commons.net.dns.DnsClient;
import com.deleidos.rtws.commons.net.jmx.JmxConnectionFactory;
import com.deleidos.rtws.commons.net.jmx.JmxConnectionFactoryImpl;
import com.deleidos.rtws.commons.net.jmx.JmxMBeanServerConnection;
import com.deleidos.rtws.commons.util.env.SystemEnvUtil;
import com.deleidos.rtws.master.core.beans.ClusterDefinition;
import com.deleidos.rtws.master.core.beans.ClusterManagerProcess;
import com.deleidos.rtws.master.core.beans.ProcessGroup;
import com.deleidos.rtws.master.core.client.RestClientManager;
import com.deleidos.rtws.master.core.dao.ProcessDao;
import com.deleidos.rtws.master.core.management.ClusterManagerManagedBean;
import com.deleidos.rtws.master.core.management.ManagementContext;
import com.deleidos.rtws.master.core.net.dns.query.dao.DNSAddressThreadListener;
import com.deleidos.rtws.master.core.net.dns.query.dao.DNSAnchorThreadListener;
import com.deleidos.rtws.master.core.util.NatUtil;

public class ClusterManager implements Runnable {
	
	private static Logger log = Logger.getLogger(ClusterManager.class);

	private static int FIVE_MINUTE = 5 * 60 * 1000;
	
	/** The name of the process group to with the master process belongs. */
	protected static String MASTER_PROCESS_GROUP = "master";

	/**
	 * The name of the XML config file that defines the processes to be managed.
	 */
	protected String configFile;

	/**
	 * The name of the config file that declares the plug-in classes found in
	 * the XML config file.
	 */
	protected String bindingFile;

	/** The list of plug-in classes that are found in the XML config file. */
	private Class<?>[] configClasses;

	/** The application configuration parameters (as loaded from the XML file. */
	private ClusterDefinition config;

	/** The list of process groups being managed. */
	private Map<String, ControllerSet> processes = new LinkedHashMap<String, ControllerSet>();

	/**
	 * A time thread used to periodically poll metrics used to evaluate to
	 * scaling triggers.
	 */
	private Timer timer = new Timer("Auto-Scaling Monitor", true);

	private boolean firstRun = true;
	

	private File initialSyncCompleteFlag = new File("/tmp/.initial_repo_sync_complete");
	
	/**
	 * A single thread pool to handle public DNS entry additions.
	 */
	private ExecutorService dnsServiceExecutor = Executors.newFixedThreadPool(5);

	/**
	 * Perform initialization, watch for scaling triggers and wait for shutdown.
	 */
	public void run() {	

		// ///
		// Load Configuration
		//

		try {
			log.info("Loading service configuration.");
			loadBindingContext();
			loadConfiguration();
			validateConfiguration();
		} catch (Exception e) {
			log.fatal("Unable to load master node configuration.", e);
			System.exit(1);
		}

		File stateFile = config.getProcessStateFile();
		config.getProcessDaoFactory().setBeanClasses(configClasses);
		ServiceInterface service = config.getServiceInterface();
		StorageInterface storage = config.getStorageInterface();
		loadProcessFile(storage, stateFile);
		ManagementContext jmx = new ManagementContext("rtws.deleidos.com");
		ProcessDao dao = config.getProcessDaoFactory().getInstance(stateFile,
				storage);
		DnsClient dns = config.getDnsClient();

		String dnsUrl = RtwsConfig.getInstance().getString("webapp.dnsapi.url.path");

		String fqdn = config.getDomainName();

		boolean allocateInternetAddress = config.getAllocateInternetAddress();
		boolean allocatePersistentAddress = config
				.getAllocatePersistentAddress();
		long interval = config.getProcessReallocationInterval();

		// ///
		// Initialize self.
		//
		
		Process master = new Process();
		
		ClusterManagerProcess cmProcess = ClusterManagerProcess.newInstance(config.getDomainName());
		cmProcess.setToStarting();
		
		jmx.initialize();		
		jmx.register(new ClusterManagerManagedBean(cmProcess));

		if (firstRun && SystemEnvUtil.isTmsSystem() && InterfaceConfig.getInstance().isRunningInAws()) {
			firstRun = false;

			log.info("On TMS System, checking/creating required security groups and rules for TMS process group operations");
			
			// Run security group setup in another thread to avoid failures
			// breaking the main master startup.
			
			Thread securityGroupSetupThread = new Thread(new SecurityGroupSetupRunnable(config));
			securityGroupSetupThread.start();

			// Wait for the security groups to be created before we proceed. We will
			// at most five minutes.
			
			try {
				securityGroupSetupThread.join(FIVE_MINUTE);
			} catch (InterruptedException e) {
				log.error(e.getMessage(), e);
			}
		}

		if (!config.isTestMode())
			try {
				// Why doesn't this get opened in test mode?
				dao.open();
				Collection<Process> singleton = dao.findByGroup(MASTER_PROCESS_GROUP);
				if (singleton.isEmpty()) {
					log.info("Performing first time setup.");
					master = service.self();
					master.setGroup(MASTER_PROCESS_GROUP);
					master.setPersistentDnsName(fqdn);
					if (config.isTaggingEnabled()) {
						service.assignAttributes(master, BasicProcessController
								.buildAttributes(fqdn, MASTER_PROCESS_GROUP));
					}
					log.info("Saving processes state for '" + fqdn + "'.");
				} else {
					master = singleton.iterator().next();
					master = service.self(master);
				}
				if (config.getInternetAddress() != null) {
					master.setInternetAddress(config.getInternetAddress());
				} else {
					master.setInternetAddress(fqdn);
				}

				master.setAllocateInternetAddress(allocateInternetAddress);
				// Try catch block for persistent address and route 53.
				try {
					if (allocatePersistentAddress) {
						// Get the process from the Process and table and get
						// the previous IP address.
						Process process = dao.findById(master.getId());

						// case for current master id, not being in process.xml
						// file, terminated instance case
						if (process == null) {
							log.info("Could not find master process using current instance id, looking for it by group.");
							Collection<Process> masters = dao
									.findByGroup("master");
							// only one instance
							if (masters.size() == 1) {
								process = masters.iterator().next();
							}
							// more then one master instance found
							else if (masters.isEmpty() == false
									&& masters.size() > 1) {
								log.info("More then one master process found by using group, using first process in list.");
								process = masters.iterator().next();
							}
							// no master instance found
							else {
								log.info("Master process was not found using group name.");
							}
						}

						// Get the previously assigned persistent IP address
						String previousPersistentIpAddress = null;
						if(process != null){
							process.setId(master.getId());  //set instanceID for terminated instance, process has outdated ID
							process = service.self(process);    //describe if a master process was found, set new id
							previousPersistentIpAddress = process.getPersistentIpAddress();
						}
						// Get the IP address from the services.xml file.
						String templatePersistentIpAddress = config
								.getPersistentIpAddress();
						// Allocate persistent address
						String allocatedIpAddress = service.bind(master,
								previousPersistentIpAddress,
								templatePersistentIpAddress);
						// If the persistent address is different from the
						// master address
						// Start thread to update processes.xml file when it
						// changes.
						// This thread will also update the Internet address if
						// it is enabled.
						if (allocatedIpAddress != null) {
							log.info("Starting a DNS Listener Thread");
							DNSAddressThreadListener dnsAddressThreadListener = new DNSAddressThreadListener(
									service, dao, master);
							Thread dnsListener = new Thread(
									dnsAddressThreadListener);
							dnsListener.start();
						} else if ((allocateInternetAddress)
								&& (dnsUrl != null)) {
							// bind public dns entry for instance to local dns
							// and public dns servers
							DNSAnchorThreadListener dnsListener = new DNSAnchorThreadListener(
									master.getPublicIpAddress(), fqdn, true);
							
							dnsServiceExecutor.execute(dnsListener);
						}
						// Set the master to the persistent ip address
						master.setPersistentIpAddress(allocatedIpAddress);
					} else {
						// Set the binding record type to CNAME to associate a
						// name.
						if ((allocateInternetAddress) && (dnsUrl != null)) {
							// bind public dns entry for instance to local dns
							// and public dns servers
							DNSAnchorThreadListener dnsListener = new DNSAnchorThreadListener(
									master.getPublicIpAddress(),
									master.getInternetAddress(), true);
							
							dnsServiceExecutor.execute(dnsListener);
						}
					}
				} catch (Exception e) {
					log.error("Error allocating addresses: " + e.getMessage(),
							e);
					// Continue processing.
				}
				// Bind the master node private IP to its own DNS.
				dns.bind(master.getPersistentDnsName(),
						master.getPrivateIpAddress());
				// Bind the masternode private IP to it public DNS
				dns.bind(master.getInternetAddress(),
						master.getPrivateIpAddress());
				
				//if system is running with a configured NAT add IP table entries for external internet access through NAT
				if(SystemEnvUtil.isNatConfigured()){
					DNSAnchorThreadListener dnsUpdateThread = NatUtil.performProcessGroupOperations(master.getGroup(), master.getPrivateIpAddress(), 
																			master.getAllocateInternetAddress(), fqdn);
					if(dnsUpdateThread != null){
						dnsServiceExecutor.execute(dnsUpdateThread);
					}
					
					//allocate one time only public DNS entry for system, one DNS entry used for all nodes
					DNSAnchorThreadListener dnsListener = new DNSAnchorThreadListener(NatUtil.getNatIp(), UserDataProperties.getInstance().getString(UserDataProperties.RTWS_DOMAIN), true);
					dnsServiceExecutor.execute(dnsListener);
				}
			} catch (Exception e) {
				log.fatal(
						"Unable to bind DNS name while initializing master process '"
								+ fqdn + "'." + " Message: " + e.getMessage(),
						e);
				// System.exit(1);

			}
		else {
			// In test mode, the manager is run from outside cloud environment
			// (i.e. on a developer's local
			// workstation "for testing"). While it can still manage other
			// processes remotely in the cloud
			// environment, it cannot perform management operations on itself
			// (such as allocating an elastic
			// IP address) As such, the self initialization step is skipped and
			// some dummy values are filled
			// into the process object.
			master.setGroup(MASTER_PROCESS_GROUP);
			master.setPersistentDnsName(fqdn);
			master.setPersistentIpAddress("127.0.0.1");
		}

		try {
			// Want to store every time just in case information has changed
			dao.store(master);
		} catch (Exception ex) {
			log.warn("Unable to write master node info to processes.xml "
					+ ex.getMessage());
		}


		// ///
		// Startup other processes.
		//		

		// Allocate a controller to manage each process group.
		for (ProcessGroup group : config.getProcessGroups()) {
			BasicProcessController controller = new BasicProcessController();
			controller.setProcessGroup(group);
			controller.setProcessDao(dao);
			// controller.setDnsAddress(master.getPersistentIpAddress()); // TJC
			// Removed use of Elastic IP
			controller.setDnsAddress(master.getPrivateIpAddress()); // TJC And
																	// instead
																	// use the
																	// Private
																	// IP
			controller.setDnsClient(dns);
			controller.setDnsService(dnsServiceExecutor);
			controller.setServiceInterface(service);
			controller.setStorageInterface(storage);
			controller.setManagementContext(jmx);
			controller.setTaggingEnabled(config.isTaggingEnabled());
			controller.startMonitor();
			
			processes.put(group.getName(), new ControllerSet(controller));
		}
		
		if (!SystemEnvUtil.isTmsSystem()) {
			do {
				log.info("Waiting for this system's repo to successfully sync with TMS.");
				try {
					if (!initialSyncCompleteFlag.exists())
						Thread.sleep(300000);
				} catch (InterruptedException e) {
					log.fatal("Failed to wait for a successful repo sync.", e);
					System.exit(1);
				}
			} while (!initialSyncCompleteFlag.exists());
		}

		log.info("Starting initial processes.");
		boolean initialProcessesStartupSuccess = true;
		try {
			for (ControllerSet controller : processes.values()) {
				// Add to the management context.
				jmx.manage(controller.basic, controller.scaling);
				// Check whether some of the processes are already running.
				controller.basic.sync();
				// Allocate whatever processes this group needs.
				controller.lifecycle.allocateInitialProcesses();
				// Kick off the scaling monitor.
				controller.scaling.initialize(timer);
			}
		} catch (Exception e) {
			log.fatal("Unable to start a complete set of initial processes.", e);
			
			// Get the root cause and send that out to the Gateway to report back to MC
			String error = "The master process encountered an error during startup: " + ExceptionUtils.getRootCauseMessage(e);
			RestClientManager.getGatewayApiRestClient().setSystemError(SystemEnvUtil.getDomain(), error);
			initialProcessesStartupSuccess = false;
			
			cmProcess.setErrorMessage(e.getMessage());
		}

		// ///
		// Monitor processes.
		//

		// Let the system do it's thing (if no startup errors), and wait for a shutdown request.
		if (initialProcessesStartupSuccess) {
			try {
				long lastCheck = System.currentTimeMillis();
				File pid = File.createTempFile("pid", ".txt",
						stateFile.getParentFile());
				while (pid.exists()) {
					
					// Check whether we need to adjust the number of allocated
					// process.
					long now = System.currentTimeMillis();
					if (now - lastCheck > interval) {
						
						// Boolean used to control when to switch cmProcess from starting to running status
						boolean setCmProcessRunning = cmProcess.getStatus().toString().equalsIgnoreCase("Starting");
						
						for (ControllerSet controller : processes.values()) {
						
							try {
								
								/*
								 * Release JMX References for those instances who
								 * are not currently running
								 */
								Collection<Process> basic = controller.basic
										.getProcesses();
								for (Process proc : basic) {
									ProcessState state = service.status(proc);
									if (state == ProcessState.UNKNOWN) {
										jmx.release(proc);
									} else {
	
										if (!jmx.isPresent(proc))
											jmx.manage(controller.basic,
													controller.scaling);
										
										// While the ClusterManagerProcess is in a starting state, check if the
										// ProcessGroupMonitors are up and running for all Processes. If any are
										// not up yet, we are still in a starting state.
										if(setCmProcessRunning) {
											setCmProcessRunning = isProcessGroupMonitorRunning(proc);
										}
									}
								}

								controller.scaling.evaluate();
							} catch (Exception e) {
								log.error(
										"Unable to evaluate/adjust process allocation.",
										e);
							}
						}
						
						if(setCmProcessRunning) {
							// Set the cmProcess to a running state to report that startup is now completed.
							cmProcess.setToRunning();
							log.info("Startup complete.");
						}
						
						lastCheck = System.currentTimeMillis();
						
					}
	
					// Twiddle thumbs.
					Thread.sleep(1000);
	
				}
			} catch (IOException e) {
				// If the pid file can't be created, then there is no way to signal a
				// stop. Quit gracefully now.
			} catch (InterruptedException e) {
				// I guess that's a sign that we shouldn't be running anymore.
			}
		}
		else {
			cmProcess.setToStopping();
			log.info("Startup complete, but with errors.  Initiating the shutdown process.");
		}

		// ///
		// Shutdown.
		//

		// Shut the processes down in the reverse order of how they were
		// started.
		ArrayList<String> groups = new ArrayList<String>(processes.keySet());
		Collections.reverse(groups);

		log.info("Stopping all scaling monitors to avoid any new instances from being created during shutdown process.");
		for (String group : groups) {
			ControllerSet controller = processes.get(group);
			controller.scaling.dispose();
			jmx.release(controller.basic);
		}
		timer.cancel();
		timer.purge();

		log.info("Stopping processes.");
		ArrayList<Process> processList = new ArrayList<Process>();
		for (String group : groups) {
			ControllerSet controller = processes.get(group);
			processList.addAll(controller.basic.getProcesses());
			controller.lifecycle.shutDownProcesses();
		}

		// verify all processes have been shutdown
		service.monitorProcessStateChange(processList, false);
		
		dnsServiceExecutor.shutdown();
		cmProcess.setToStopped();
	
		log.info("Shutdown Complete.");
		System.exit(0);
	}

	/**
	 * Loads the specified binding context file. This file contains a list of
	 * classes that are needed to initialize a JAXB binding context capable of
	 * reading the XML configuration file.
	 */
	protected void loadBindingContext() throws IOException {

		InputStream stream = null;
		String line = null;
		BufferedReader reader = null;

		try {

			// Open the binding context file.
			stream = PropertiesUtils.loadResource(bindingFile);
			reader = new BufferedReader(new InputStreamReader(
					stream));
			LinkedList<Class<?>> list = new LinkedList<Class<?>>();

			// Read the list of class names.
			while ((line = reader.readLine()) != null) {
				if (!line.matches("\\s*")) {
					list.add(Class.forName(line));
				}
			}

			// Load the class objects.
			configClasses = list.toArray(new Class<?>[list.size()]);

		} catch (ClassNotFoundException e) {
			throw new IOException(e);
		} finally {
			try {
				reader.close();
			} catch (Exception ignore) {
			}
		}

	}

	/**
	 * Loads the specified XML configuration file which defines the processes
	 * that this manager is intended to handle and the resources it needs to do
	 * so.
	 */
	private void loadConfiguration() throws IOException {

		InputStream stream = null;

		try {

			// Configure an XML marshaller for the classes referenced in the
			// configuration file.
			JAXBContext context = JAXBContext.newInstance(configClasses);
			Unmarshaller marshaller = context.createUnmarshaller();

			// Create a stream to read the configuration file.
			stream = PropertiesUtils.loadResource(configFile);
			StreamSource source = new StreamSource(stream);

			// Load the configuration data.
			config = marshaller.unmarshal(source, ClusterDefinition.class)
					.getValue();

		} catch (JAXBException e) {
			throw new IOException(e);

		} finally {
			try {
				stream.close();
			} catch (Exception ignore) {
			}
		}

	}

	/**
	 * Load the shadow copy of the process state file or the local copy.
	 */
	private void loadProcessFile(StorageInterface storage, File stateFile) {

		if (!SystemEnvUtil.checkShadowCopyEnvExist()) {
			log.info("Shadow copy feature has been disabled.");

			return;
		}

		String domain = SystemEnvUtil.getDomain();
		String bucket = SystemEnvUtil.getShadowCopyBucket();
		String fileKey = SystemEnvUtil.buildProcessesFileKey(domain,
				stateFile.getName());

		boolean storageFileExists = false;
		try {
			storageFileExists = storage.fileExists(bucket, fileKey);
		} catch (StorageException ignoreUntilLater) {
		}

		if (storageFileExists) {

			// The shadow process file exit. We will pull it into the local
			// file system for the master to uses. Also, overwrite the process
			// file in the local file system if one exist.

			try {
				storage.getFileWithRetry(bucket, fileKey, stateFile, 3, 3000);
				log.info("Retrieved shadow copy of the " + stateFile.getName()
						+ " to " + stateFile.getParent() + '.');
			} catch (Exception ex) {
				log.error(
						"Unable to retrieve shadow copy of the process file from s3 ["
								+ bucket + "]", ex);
				System.exit(1);
			}
		} else {

			// The shadow copy of the process file doesn't exist but a local
			// copy exists, lets make this the shadow copy.

			if (stateFile.exists()) {
				try {
					storage.storeFileWithRetry(bucket, fileKey, stateFile, 3,
							3000);
					log.info("Stored the local copy of the "
							+ stateFile.getName() + " as the shadow copy.");
				} catch (Exception ex) {
					log.error("Unable to store process file to s3 [" + bucket
							+ "]", ex);
				}
			}
		}

	}

	/**
	 * Validates the the loaded configuration file to insure that all expected
	 * parameters are present.
	 * 
	 * @throws IllegalArgumentException
	 */
	private void validateConfiguration() throws IllegalArgumentException {
		config.validate();
	}
	
	/**
	 * Checks if communication is available to a ProcessGroupMonitor to determine if the Monitor
	 * is running.
	 */
	private boolean isProcessGroupMonitorRunning(Process process) {
		JmxMBeanServerConnection connection = null;
		
		try {
			// Look for ProcessGroupMonitor beans
			ObjectName pattern = ObjectName.getInstance("rtws.deleidos.com:type=ProcessGroupMonitor");
						
			// Connect to the process node's JMX management
			connection = establishJmxConnectionWithRetries(process.getPrivateIpAddress(), 1098, "jmxrmi");
			
			if(connection != null) {
				// Get all the beans available on the connection
				Set<ObjectName> availableMonitors = connection.queryNames(pattern, null);
				if(availableMonitors.size() == 0) {
					// No process group monitor is running yet
					return false;
				}
			}
			else {
				// Cannot establish a connection to the process, assume no process group monitor is running yet
				return false;
			}
		} catch (Exception e) {
			// Something is wrong, we have an error
			log.error("Failed to contact ProcessGroupMonitor.", e);
			return false;
		} finally {
			if(connection != null) try { connection.close(); } catch (Exception ignore) { }
		}
		
		return true;
	}
	
	private JmxMBeanServerConnection establishJmxConnectionWithRetries(String host, int port, String connector) {
		JmxConnectionFactory connectionFactory = new JmxConnectionFactoryImpl();
		
		int connectionRetryCount = 15;	// Try multiple times to establish a JMX connection
			
		while(connectionRetryCount > 0) {
			try {
				return connectionFactory.getConnection(host, port, connector);
			} catch (IOException ioe) {
				connectionRetryCount--;
			}
		}
		
		return null;
	}

	/**
	 * It ain't a test routine...
	 */
	public static void main(String[] args) throws Exception {
		
		//set some jvm properties to avoid defect D-02234, having to do with XML expansion
		System.setProperty("entityExpansionLimit", "0");
		System.setProperty("jdk.xml.entityExpansionLimit","0");
		
		
		if (args.length != 2) {
			System.err
					.println("Usage: java -cp jar com.deleidos.rtws.master.core.ClusterManager configFile bindingFile");
			System.exit(1);
		}

		String config = args[0];
		String binding = args[1];

		ClusterManager manager = new ClusterManager();
		manager.configFile = config;
		manager.bindingFile = binding;
		manager.run();

	}

	private static class ControllerSet {
		public BasicProcessController basic;
		public LifecycleController lifecycle = new LifecycleController();
		public ScalingController scaling = new ScalingController();

		public ControllerSet(BasicProcessController controller) {
			basic = controller;
			lifecycle.setController(basic);
			lifecycle.setProcessGroup(basic.getProcessGroup());
			scaling.setController(basic);
			scaling.setProcessGroup(basic.getProcessGroup());
		}
	}
}
