/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
/**
 * 
 */
package com.deleidos.rtws.webapp.dbapi.dao;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

import javax.sql.DataSource;

import net.sf.json.JSONArray;
import net.sf.json.JSONNull;
import net.sf.json.JSONObject;

import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.ConversionException;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.deleidos.rtws.commons.config.RtwsConfig;
import com.deleidos.rtws.commons.dao.exception.DataStorageException;
import com.deleidos.rtws.commons.dao.jdbc.DataAccessSession;
import com.deleidos.rtws.commons.dao.jdbc.DataAccessUtil;
import com.deleidos.rtws.commons.dao.jdbc.RecordBuilder;
import com.deleidos.rtws.webapp.dbapi.servlet.H2DBUtils;
import com.deleidos.rtws.webapp.dbapi.util.upload.UploadManager;
import com.deleidos.rtws.webapp.dbapi.util.upload.UploadManager.KeyFileHolder;

/**
 * 
 *
 */
public class AlterDao {

	private static final Logger logger = Logger.getLogger(AlterDao.class);

	protected static final String truncateTableSql = "TRUNCATE TABLE ?.?;";

	protected static final String dropTableSql = "DROP TABLE ?.?;";

	protected static final String dropColumnSql = "ALTER TABLE ?.? DROP COLUMN ?;";

	// SQL commands for IP-GEO uploads
	protected static final String dropIPGeoTables = "DROP TABLE IF EXISTS TEMP_IP_GEO_BLOCKS; DROP TABLE IF EXISTS TEMP_IP_GEO_LOCATIONS;";
	protected static final String createIPBlockTable = "CREATE TABLE \"DIMENSIONS\".\"TEMP_IP_GEO_BLOCKS\"("
			+ "STARTIPNUM BIGINT," + "ENDIPNUM BIGINT," + "LOCID INTEGER);";
	protected static final String createIPBlockTableIndex = "CREATE INDEX TEMP_IP_BLOCKS_INDEX ON \"DIMENSIONS\".\"TEMP_IP_GEO_BLOCKS\"(LOCID);";
	protected static final String createIPLocationTable = "CREATE TABLE \"DIMENSIONS\".\"TEMP_IP_GEO_LOCATIONS\"("
			+ "LOCID INTEGER, " + "COUNTRY varchar(8), " + "REGION varchar(64), " + "CITY varchar(128), "
			+ "POSTALCODE INTEGER, " + "LATITUDE double, " + "LONGITUDE double, " + "METROCODE INTEGER, "
			+ "AREACODE INTEGER);";
	protected static final String createIPLocationTableIndex = "CREATE INDEX TEMP_IP_LOCATION_INDEX ON \"DIMENSIONS\".\"TEMP_IP_GEO_LOCATIONS\"(LOCID);";
	protected static final String createIPGeoTable = "CREATE TABLE \"DIMENSIONS\".\"IP_GEO\"(" + "STARTIPNUM BIGINT, "
			+ "ENDIPNUM BIGINT, " + "COUNTRY varchar(8), " + "REGION varchar(64), " + "CITY varchar(128), "
			+ "POSTALCODE integer, " + "LATITUDE double, " + "LONGITUDE double, " + "METROCODE INTEGER, "
			+ "AREACODE INTEGER);";
	protected static final String joinIPGeoTables = "create TABLE DIMENSIONS.GEO_IP as ("
			+ "SELECT DIMENSIONS.TEMP_IP_GEO_BLOCKS.STARTIPNUM, " + "DIMENSIONS.TEMP_IP_GEO_BLOCKS.ENDIPNUM, "
			+ "TEMP_IP_GEO_LOCATIONS.COUNTRY, " + "TEMP_IP_GEO_LOCATIONS.REGION, " + "TEMP_IP_GEO_LOCATIONS.CITY, "
			+ "TEMP_IP_GEO_LOCATIONS.POSTALCODE, " + "TEMP_IP_GEO_LOCATIONS.LATITUDE, "
			+ "TEMP_IP_GEO_LOCATIONS.LONGITUDE, " + "TEMP_IP_GEO_LOCATIONS.METROCODE, "
			+ "TEMP_IP_GEO_LOCATIONS.AREACODE "
			+ "FROM DIMENSIONS.TEMP_IP_GEO_BLOCKS LEFT JOIN DIMENSIONS.TEMP_IP_GEO_LOCATIONS on "
			+ "DIMENSIONS.TEMP_IP_GEO_BLOCKS.LOCID=DIMENSIONS.TEMP_IP_GEO_LOCATIONS.LOCID);";
	// end IP GEO sql commands block

	// protected static final String insertCsvSql =
	// "INSERT into ?.? SELECT * from CSVREAD(?);";
	protected static final String CVSREAD = "SELECT * from CSVREAD(?);";

	protected static final String NEWLINE = System.getProperty("line.separator");

	private static final String DB_API_URL_PROP_NAME = "webapp.dbapi.internal.url.path";

	/** Data source through which SQL operations should be performed. */
	private DataSource dataSource;

	/** Utility instance used to manage connections. */
	private DataAccessSession session;

	private String uploadCallbackBasePath;

	/**
	 * Constructor.
	 */
	public AlterDao(String dbIP) {
		super();
		setDataSource(H2DBUtils.getDataSource(dbIP));

		String dbApiUrlPropValue = null;
		try {
			dbApiUrlPropValue = RtwsConfig.getInstance().getString(DB_API_URL_PROP_NAME, null);

			if (StringUtils.isNotBlank(dbApiUrlPropValue)) {
				URL dbApiUrl = new URL(dbApiUrlPropValue);
				String dbApiIpAddr = InetAddress.getLocalHost().getHostAddress();

				uploadCallbackBasePath = new URL(dbApiUrl.getProtocol(), dbApiIpAddr, dbApiUrl.getPort(),
						dbApiUrl.getFile()).toString();
			} else {
				uploadCallbackBasePath = null;
				logger.error("Property '" + DB_API_URL_PROP_NAME
						+ "' is missing or empty.  File Upload requests will fail!");
			}
		} catch (ConversionException conversionException) {
			uploadCallbackBasePath = null;
			logger.error("Failed to read DB API Path from property '" + DB_API_URL_PROP_NAME
					+ "' for use in file upload.  File Upload requests will fail!", conversionException);
		} catch (MalformedURLException malformedURLException) {
			uploadCallbackBasePath = null;
			logger.error("Failed to parse '" + dbApiUrlPropValue
					+ "' or build ip-based URL.  File Upload requests will fail!", malformedURLException);
		} catch (UnknownHostException unknownHostException) {
			uploadCallbackBasePath = null;
			logger.error(
					"Failed to determine the IP Address of the DBAPI for use in file upload.  File Upload requests will fail!",
					unknownHostException);
		}
	}

	/**
	 * Data source through which SQL operations should be performed.
	 */
	public DataSource getDataSource() {
		return dataSource;
	}

	/**
	 * Data source through which SQL operations should be performed.
	 */
	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
		this.session = DataAccessUtil.session(dataSource);
	}

	public int truncateTable(String type, String table) {
		String modifiedSql = truncateTableSql.replaceFirst("\\?", type).replaceFirst("\\?", table);

		return session.executeStatement(modifiedSql, null);
	}

	public int dropTable(String type, String table) {
		String modifiedSql = dropTableSql.replaceFirst("\\?", type).replaceFirst("\\?", table);
		return session.executeStatement(modifiedSql, null);
	}

	public int createTable(String type, String table, String jsonDef) {
		JSONObject def = JSONObject.fromObject(jsonDef);
		JSONArray cols = def.getJSONArray("columns");
		StringBuilder statement = new StringBuilder("CREATE TABLE ");
		statement.append(type).append('.').append(table).append("(");

		ArrayList<String> primaryKeyColumns = new ArrayList<String>();
		for (int i = 0; i < cols.size(); i++) {
			JSONObject col = cols.getJSONObject(i);
			if (i > 0) {
				statement.append(",");
			}

			statement.append(col.getString("column_name"));

			statement.append(" ").append(col.getString("type"));
			if (!col.optString("precision", "INVALID").equals("INVALID")) {
				statement.append("(").append(col.getString("precision")).append(")");
			}

			if (col.containsKey("default_value")) {
				// default value handling
				JSONObject defaultDef = col.getJSONObject("default_value");
				if (defaultDef != null && !defaultDef.isNullObject()) {// valid
																		// object
					String mode = defaultDef.getString("mode");
					statement.append(" DEFAULT ");
					if (mode.equalsIgnoreCase("null")) {
						statement.append("NULL");
					} else if (mode.equalsIgnoreCase("seq") || mode.equalsIgnoreCase("sequence")) {
						statement.append("nextval('" + defaultDef.getString("value") + "')");
					} else if (mode.equalsIgnoreCase("val") || mode.equalsIgnoreCase("value")) {
						Object o = defaultDef.get("value");
						if (o instanceof String) {
							statement.append("'").append(defaultDef.getString("value")).append("'");
						} else {
							statement.append(o.toString());
						}
					}
				}
			}

			if (col.optBoolean("primary_key", false)) {
				primaryKeyColumns.add(col.getString("column_name"));
			} else {
				if (col.optBoolean("nullable", true))
					statement.append(" NULL");
				else
					statement.append(" NOT NULL");
			}
		}

		if (primaryKeyColumns.size() > 0) {
			statement.append(", PRIMARY KEY (");
			String currColName = null;
			for (int pkColumnIndex = 0; pkColumnIndex < primaryKeyColumns.size(); pkColumnIndex++) {
				currColName = primaryKeyColumns.get(pkColumnIndex);
				if (pkColumnIndex > 0) {
					statement.append(", ");
				}
				statement.append(currColName);
			}
			statement.append(")");
		}
		statement.append(");");
		return session.executeStatement(statement.toString(), null);
	}

	public int grantTablePermissions(String type, String table, String grantee, Set<String> permissionsToGrant)
			throws SQLException {
		H2DBUtils.validateIdentifier(type);
		H2DBUtils.validateIdentifier(table);
		H2DBUtils.validateIdentifier(grantee);
		if (permissionsToGrant == null || permissionsToGrant.size() == 0) {
			throw new SQLException("No Permissions specified");
		}
		for (String permission : permissionsToGrant) {
			if (H2DBUtils.isValidTablePermission(permission) == false) {
				throw new SQLException("Invalid Table Permission");
			}
		}

		StringBuilder statement = new StringBuilder("GRANT ");
		statement.append(StringUtils.join(permissionsToGrant, ", "));
		statement.append(" ON ");
		if (StringUtils.isNotBlank(type)) {
			statement.append(type).append(".");
		}
		statement.append(table);
		statement.append(" TO ").append(grantee);
		statement.append(";");

		return session.executeStatement(statement.toString(), null);
	}

	public int revokeTablePermissions(String type, String table, String revokeSubject, Set<String> permissionsToRevoke)
			throws SQLException {
		H2DBUtils.validateIdentifier(type);
		H2DBUtils.validateIdentifier(table);
		H2DBUtils.validateIdentifier(revokeSubject);
		if (permissionsToRevoke == null || permissionsToRevoke.size() == 0) {
			throw new SQLException("No Permissions specified");
		}
		for (String permission : permissionsToRevoke) {
			if (H2DBUtils.isValidTablePermission(permission) == false) {
				throw new SQLException("Invalid Table Permission");
			}
		}

		StringBuilder statement = new StringBuilder("REVOKE ");
		statement.append(StringUtils.join(permissionsToRevoke, ", "));
		statement.append(" ON ");
		if (StringUtils.isNotBlank(type)) {
			statement.append(type).append(".");
		}
		statement.append(table);
		statement.append(" FROM ").append(revokeSubject);
		statement.append(";");

		return session.executeStatement(statement.toString(), null);
	}

	public int dropColumn(String type, String table, String column) {
		String modifiedSql = dropColumnSql.replaceFirst("\\?", type).replaceFirst("\\?", table)
				.replaceFirst("\\?", column);
		return session.executeStatement(modifiedSql, null);
	}

	public int addColumn(String type, String table, String jsonColDef) throws SQLException {
		JSONObject colDef = JSONObject.fromObject(jsonColDef);
		// note that you cannot add a primary key - so any columns with primary
		// keys should be removed
		if (colDef.optBoolean("primary_key", false))
			return 0;

		StringBuilder cmd = new StringBuilder("ALTER TABLE ");
		cmd.append(type).append(".").append(table);
		cmd.append(" ADD ");
		cmd.append(colDef.getString("column_name")).append(" ").append(colDef.getString("type"));
		if (colDef.containsKey("precision"))
			cmd.append("(").append(colDef.getString("precision")).append(")");
		if (colDef.containsKey("default_value")) {
			JSONObject defaultVal = colDef.getJSONObject("default_value");
			if (defaultVal != null && !defaultVal.isNullObject() && !defaultVal.equals(JSONNull.getInstance())) {
				cmd.append(" DEFAULT ");
				if (!defaultVal.containsKey("mode"))
					throw new SQLException("No mode present in default value argument");
				String mode = defaultVal.getString("mode");
				if (mode.equalsIgnoreCase("null"))
					cmd.append(" NULL");
				else if (mode.equalsIgnoreCase("value") || mode.equalsIgnoreCase("val")) {
					Object o = defaultVal.get("value");
					if (o instanceof String) {
						cmd.append("'").append(defaultVal.getString("value")).append("'");
					} else {
						cmd.append(o.toString());
					}
				} else if (mode.equalsIgnoreCase("seq") || mode.equalsIgnoreCase("sequence")) {
					cmd.append("nextval('").append(defaultVal.getString("value")).append("')");
				}

			}// else no default
		}
		if (colDef.getBoolean("nullable"))
			cmd.append(" NULL");
		else
			cmd.append(" NOT NULL");
		cmd.append(";");
		return session.executeStatement(cmd.toString(), null);
	}

	public void CreateIPGeoDatabaseTables() {
		/*
		 * get this zip:
		 * http://geolite.maxmind.com/download/geoip/database/GeoLiteCity_CSV
		 * /GeoLiteCity-latest.zip unzip it, create two tables, read it in, then
		 * do a join. That joined table is the IP_GEO table that is the output
		 */
		try {
			File zipFile = File.createTempFile("GEOIP", "zip");
			URL website = new URL(
					"http://geolite.maxmind.com/download/geoip/database/GeoLiteCity_CSV/GeoLiteCity-latest.zip");
			ReadableByteChannel rbc = Channels.newChannel(website.openStream());
			FileOutputStream fos = new FileOutputStream(zipFile);
			ByteBuffer buf = ByteBuffer.allocate(2048);
			int read = rbc.read(buf);
			while (read > 0) {
				fos.write(buf.array(), 0, read);
				buf.rewind();
				read = rbc.read(buf);
			}
			fos.flush();
			fos.close();
			rbc.close();

			ZipFile zFile = new ZipFile(zipFile);
			ZipEntry zipEntry;
			Enumeration<? extends ZipEntry> enumeration = zFile.entries();
			while (enumeration.hasMoreElements()) {
				zipEntry = enumeration.nextElement();
				System.out.println(zipEntry.getName());
				if (zipEntry.getName().endsWith("GeoLiteCity-Blocks.csv")) {
					// handle blocks part

				}
				if (zipEntry.getName().endsWith("GeoLiteCity-Location.csv")) {
					// handle location part
				}
			}

		} catch (Exception e) {
			// TODO: handle exception
		}
	}

	public static void main(String[] args) {
		AlterDao dao = new AlterDao("");
		dao.CreateIPGeoDatabaseTables();
	}

	public void insertCSV(String streamFromServiceLocation, String type, String table, KeyFileHolder keyFile, String nullString, String defaultString)
			throws ConfigurationException, DataStorageException {
		if (StringUtils.isBlank(uploadCallbackBasePath)) {
			throw new ConfigurationException("Missing or Invalid Upload Callback Property");
		}

		try {
			//String addr = uploadCallbackBasePath + "/rest/alter/getCsvStream/" + key;//switch out for new, context-based version
			String addr = streamFromServiceLocation+"/rest/alter/getCsvStream/" + keyFile.key;

			String cvsReadSql = CVSREAD.replaceFirst("\\?", "'" + addr + "'");
			// Use the specific local location of the CSV file in the SQL
			// command
			// String modifiedSql = insertCsvSql.replaceFirst("\\?", type)
			// .replaceFirst("\\?", table)
			// .replaceFirst("\\?", "'" + addr + "'");
			session.executeMultiRowQuery(cvsReadSql, null, new CSVRowBuilder(type, table, nullString, defaultString));

			// session.executeStatement(modifiedSql, null);
		} catch (DataStorageException storeException) {
			// Only clear the upload on failure ... It will clear itself on
			// success
			UploadManager.INSTANCE.unregisterUpload(keyFile.key);
			throw storeException;
		}
	}

	public int alterColumn(String type, String table, String column, String jsonDef) throws SQLException {
		int alteredRows = 0;
		JSONObject colDef = JSONObject.fromObject(jsonDef);
		StringBuilder cmd = new StringBuilder("ALTER TABLE ");
		cmd.append(type).append(".").append(table);
		cmd.append(" ALTER COLUMN ").append(column);

		// at this point we have to make multiple calls based on which entries
		// are available.
		String start = cmd.toString();

		if (colDef.containsKey("set_type")) {
			cmd = new StringBuilder(start);
			cmd.append(" ").append(colDef.getString("set_type"));
			if (colDef.containsKey("set_precision"))
				cmd.append("(").append(colDef.getString("set_precision")).append(")");
			cmd.append(";");
			alteredRows += session.executeStatement(cmd.toString(), null);
		}
		if (colDef.containsKey("set_nullable")) {
			cmd = new StringBuilder(start);
			if (colDef.getBoolean("set_nullable")) {
				cmd.append(" SET NULL");
			} else {
				cmd.append(" SET NOT NULL");
			}
			cmd.append(";");
			alteredRows += session.executeStatement(cmd.toString(), null);
		}
		if (colDef.containsKey("set_default_value")) {
			JSONObject defaultDef = colDef.getJSONObject("set_default_value");
			if (!(defaultDef == null) && !defaultDef.isNullObject() && !(defaultDef.equals(JSONNull.getInstance()))) {
				String mode = defaultDef.getString("mode");
				cmd = new StringBuilder(start);
				cmd.append(" SET DEFAULT ");
				if (mode.equalsIgnoreCase("null")) {
					cmd.append("NULL");
				} else if (mode.equalsIgnoreCase("seq") || mode.equalsIgnoreCase("sequence")) {
					cmd.append("nextval('" + defaultDef.getString("value") + "');");
				} else if (mode.equalsIgnoreCase("val") || mode.equalsIgnoreCase("value")) {
					Object o = defaultDef.get("value");
					if (o instanceof String)
						cmd.append("'").append(defaultDef.getString("value")).append("'");
					else {
						cmd.append(o.toString());
					}
					// string or int?
					/*
					 * if(defaultDef.getString("type").equalsIgnoreCase("number")
					 * ) cmd.append(defaultDef.getInt("value")); else
					 * cmd.append(
					 * "'").append(defaultDef.getString("value")).append("'");
					 */
					cmd.append(";");
				}

				alteredRows += session.executeStatement(cmd.toString(), null);

			} else {
				// remove default value
				// this REQUIRES a reset of type and nullability, due to the way
				// H2 handles it's alter calls.

				String defaultType;
				boolean nullable;

				cmd = new StringBuilder(start);
				if (colDef.containsKey("set_type")) {

					defaultType = colDef.getString("set_type");
					if (colDef.containsKey("set_precision"))
						defaultType += "(" + colDef.getString("set_precision") + ")";
				} else {
					throw new SQLException("Attempted to remove default value without type parameter");
				}
				if (colDef.containsKey("set_nullable")) {
					nullable = colDef.getBoolean("set_nullable");
				} else
					throw new SQLException("Attempted to remove default value without nullable parameter");

				// nullable and default type are set, we can now create the
				// default we wanted (none)
				cmd.append(" ").append(defaultType);
				if (!nullable)
					cmd.append(" ").append("NOT");
				cmd.append(" ").append("NULL");
				alteredRows += session.executeStatement(cmd.toString(), null);
			}
		}

		// rename last, so the other calls do not fail for lack of column
		if (colDef.containsKey("rename")) {
			cmd = new StringBuilder(start);
			cmd.append(" RENAME TO ").append(colDef.getString("rename"));
			cmd.append(";");
			alteredRows += session.executeStatement(cmd.toString(), null);
		}

		return alteredRows;
	}

	private class CSVRowBuilder implements RecordBuilder<JSONObject> {
		String csvInsertSQL;
		String tableName;
		String tableSchema;
		String nullString;
		String defaultString;

		public CSVRowBuilder(String tblSchema, String tblName, String nullString, String defaultString) {
			tableName = tblName;
			tableSchema = tblSchema;
			this.nullString = nullString;
			this.defaultString = defaultString;
		}

		public JSONObject buildRecord(ResultSet arg0) {
			String cols = "";
			String sep = "";
			try {
				for (int i = 1; i <= arg0.getMetaData().getColumnCount(); i++) {
					cols = cols + sep;
					cols = cols + arg0.getMetaData().getColumnName(i);
					sep = ",";
				}
				csvInsertSQL = "insert into " + tableSchema + "." + tableName + "(" + cols + ") values (";
				sep = "";
				for (int i = 0; i < arg0.getMetaData().getColumnCount(); i++) {
					csvInsertSQL = csvInsertSQL + sep + "?";
					sep = ",";
				}
				csvInsertSQL = csvInsertSQL + ");";
				// prepare info

				PreparedStatement stmt = dataSource.getConnection().prepareStatement(csvInsertSQL);
				int rowCount = 0;
				do {//do () while to account for call to resultSet.next in calling class.  
					for (int i = 1; i <= arg0.getMetaData().getColumnCount(); i++) {
						stmt.setObject(i, arg0.getObject(i));
						/*
						 * Object o = arg0.getObject(i); if(o instanceof String)
						 * { String s = (String)o; if(s.equals(defaultString)
						 * 
						 * //default handling... } stmt.setObject(i, o);
						 */

					}

					stmt.addBatch();
					rowCount++;
					if (rowCount == 500) {
						rowCount = 0;
						stmt.executeBatch();
					}
				}while (arg0.next());
				if (rowCount != 0)// catch any leftovers
					stmt.executeBatch();

				// TODO Auto-generated method stub
				return null;
			} catch (Exception e) {
				// D-01763: instead of logging the error and continuing, throw the exception to abort the process
				throw new DataStorageException("error inserting csv: " + e.getMessage(), e);
			}
		}

	}

}
