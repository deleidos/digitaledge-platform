/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.core.framework.translator;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.script.Invocable;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.FileFilterUtils;
import org.apache.log4j.Logger;

import com.deleidos.rtws.commons.exception.InitializationException;
import com.deleidos.rtws.commons.util.BugCheckException;
import com.deleidos.rtws.commons.util.DataModelBasedNames;
import com.deleidos.rtws.commons.util.Initializable;
import com.deleidos.rtws.commons.util.repository.AbstractSystemRepository;
import com.deleidos.rtws.commons.util.repository.DataModelZipFile;
import com.deleidos.rtws.commons.util.scripting.ScriptEngineFactory;
import com.deleidos.rtws.commons.util.scripting.ScriptFile;
import com.deleidos.rtws.core.exception.ValidationException;
import com.deleidos.rtws.core.framework.parser.CanonicalFormat;
import com.deleidos.rtws.core.framework.parser.CanonicalFormat.DataTypes;
import com.deleidos.rtws.core.util.DataModelRepositoryRetrieve;
import com.deleidos.rtws.core.util.StandardHeader;

/**
 * Accepts a JSON configuration file, called a translation directive file, that
 * specifies how parsed input fields are mapped from an input set of fields to
 * the canonical format.
 */
public abstract class AbstractConfigurableTranslator implements Initializable {

	private static final Logger log = Logger.getLogger(AbstractConfigurableTranslator.class);
	private static final String headerSeperator = "\\s*\\+\\s*";

	private JSONObject translationDirectiveJson;
	private CanonicalFormat canonicalFormat;
	private FieldHandlingErrorPolicy fieldHandlingErrorPolicy;
	private DataModelBasedNames dataModelNaming;
	// private AbstractFileSetResource dataModelResource;
	private ScriptEngineFactory scriptEngineFactory;
	/** This variable is used to call a script for the translation process */
	private Invocable invocable;
	private String modelName;
	private String inputFormatName;
	private String modelVersionString;
	private StandardHeader header;
	private List<String> expectedHeaders;
	private List<String> missingHeaders;
	
	private Matcher nestedArrayMatcher;
	private String nestedArrayRegex=".*\\[.*\\[";

	private String DEFAULT_SCRIPTS_LOCATION = "/usr/local/rtws/ingest/scripts";

	/**
	 * Defines policy for handling errors when processing data fields
	 */
	public enum FieldHandlingErrorPolicy {
		DISCARD_AND_LOG, // Discard the field and log the error (default)
		DISCARD_AND_IGNORE // Discard the field silently
	};

	/**
	 * Defines the translation operations that are performed to create a JSON
	 * object.
	 */
	private enum Operations {
		Error, NoOperation, NestObject, NestArray, Unnest, CopyLiteral, GetField, GetArray, Convert, Custom, Script
	};

	/**
	 * Class defines a translation action, which when processed in sequence
	 * creates a translated JSON output object. Built from the translation
	 * directives.
	 */
	class TranslationAction {

		static final String LITERAL_INDICATOR = "=";
		static final String GET_FIELD_KEYWORD = "get";
		static final String CONVERT_FIELD_KEYWORD = "convert";
		static final String CUSTOM_KEYWORD = "custom";
		static final String SCRIPT_FIELD_KEYWORD = "script";
		static final String NO_OPERATION = "none";
		static final String GET_ARRAY_KEYWORD = "arrget";

		String key;
		String path;
		Operations operation;
		Object parameters[];
		DataTypes dataType;
		String format;
		String errorMsg;
		String scriptOperation;

		/**
		 * Returns the argument part of a directive string
		 * 
		 * @param directive
		 *            a string of the form <keyword>(<argument>)
		 * @param keyword
		 *            string that starts the directive
		 * @return the argument string between the parens - white spaces before
		 *         and after are removed
		 */
		String getArgumentString(String directive, String keyword) {
			return directive.replaceAll(keyword + "\\s*\\(\\s*", "").replaceAll("\\s*\\)\\s*$", "");
		}

		String[] getConvertArgumentString(String directive, String keyword) {
			String argumentString = getArgumentString(directive,keyword);
			return argumentString.split("\\s*(?<!\\\\),\\s*");
			//negative lookbehind - does not match "\,", does not capture preceeding characters in split.
		}

		/**
		 * Check if the given string is a valid JSON number.
		 */
		void checkNumber(String value) {
			if (!CanonicalFormat.isNumberString(value)) {
				this.operation = Operations.Error;
				this.errorMsg = "Not a valid number: " + value;
			} else {
				this.operation = Operations.CopyLiteral;
			}
		}

		/**
		 * Check if the given string is a valid date format string.
		 */
		void checkDateTime(String path, String format, String value) {
			if (format == null) {
				this.operation = Operations.Error;
				this.errorMsg = "Cannot find datetime format string for path:" + path;
			} else if (!CanonicalFormat.isDateTimeString(format, value)) {
				this.operation = Operations.Error;
				this.errorMsg = "Date/time string '" + value + "' does not conform to format '" + format + "'";
			} else {
				this.operation = Operations.CopyLiteral;
			}
		}

		/**
		 * Create a translation action for a key using a directive and data type
		 * 
		 * @param key
		 *            the simple unqualified name of the field
		 * @param path
		 *            the full path of the field
		 * @param directive
		 *            specifier in the translator directive file
		 */
		TranslationAction(String key, String path, String directive) {

			this.key = key;
			this.path = path;
			this.operation = null;
			this.parameters = null;
			this.errorMsg = null;
			this.format = null;
			this.scriptOperation = null;

			directive = directive.trim();

			this.dataType = canonicalFormat.getDataType(path);
			if (this.dataType == DataTypes.datestring) {
				this.format = canonicalFormat.getParameterString(path);
			}

			if (this.dataType == null) {
				this.operation = Operations.Error;
				this.errorMsg = "Lookup of json path failed: " + path;
			} else if (directive.startsWith(LITERAL_INDICATOR)) {

				String value = directive.substring(LITERAL_INDICATOR.length());

				switch (dataType) {
				case number:
					checkNumber(value);
					break;
				case datestring:
					checkDateTime(path, format, value);
					break;
				default:
					this.operation = Operations.CopyLiteral;
					break;
				}

				this.parameters = new Object[1];
				this.parameters[0] = AbstractConfigurableTranslator.convertString(dataType, format, value);
			} else if (directive.startsWith(GET_FIELD_KEYWORD)) {
				// Extract comma separated list of parameters
				parameters = new String[2];
				String parsed[] = getConvertArgumentString(directive, GET_FIELD_KEYWORD);
				if (parsed.length > 2) {
					this.operation = Operations.Error;
					errorMsg = "No more than two parameters supported with 'get' directive";
				} else {
					for (int i = 0; i < parsed.length; i++) {
						parameters[i] = parsed[i];
					}
					this.operation = Operations.GetField;
				}
			} else if (directive.startsWith(GET_ARRAY_KEYWORD)) {
				//
				parameters = new String[2];
				String parsed[] = getConvertArgumentString(directive, GET_ARRAY_KEYWORD);
				if (parsed.length > 1) {
					this.operation = Operations.Error;
					errorMsg = "No more than one parameter supported with '" + GET_ARRAY_KEYWORD + "' directive";
				} else {
					parameters[0] = parsed[0];
					if (!parsed[0].endsWith("[*]")) {
						this.operation = Operations.Error;
						errorMsg = "Directive does not contain valid array indexing expression.  Should end with [*]";
					} else {
						this.operation = Operations.GetArray;
					}
				}
			} else if (directive.startsWith(CONVERT_FIELD_KEYWORD)) {
				parameters = getConvertArgumentString(directive, CONVERT_FIELD_KEYWORD);
				this.operation = Operations.Convert;
			} else if (directive.equals("custom")) {
				this.operation = Operations.Custom;
			} else if (directive.startsWith("script")) {
				String[] scriptCall = getConvertArgumentString(directive, SCRIPT_FIELD_KEYWORD);
				int scriptCallLength = scriptCall.length;

				if (scriptCallLength > 0) {
					this.scriptOperation = scriptCall[0];
				}

				parameters = Arrays.copyOfRange(scriptCall, 1, scriptCallLength);
				this.operation = Operations.Script;
			} else if (directive.equals(NO_OPERATION)) {
				this.operation = Operations.NoOperation;
			} else {
				this.operation = Operations.Error;
				errorMsg = "Invalid directive: " + directive;
			}
		}

		TranslationAction(String key, String path, Operations operation) {
			this.key = key;
			this.path = path;
			this.operation = operation;
			this.parameters = null;
			this.dataType = null;
			this.errorMsg = null;
			this.format = null;
		}
	}

	/**
	 * List of translation actions created from the translation directives
	 */
	private ArrayList<TranslationAction> translationActionList;

	/**
	 * Recursively process a json object to add translation actions to the
	 * translationActionList.
	 * 
	 * @param key
	 *            the simple unqualified name of the current field
	 * @param path
	 *            string path syntax for the json value/object/array
	 * @param value
	 *            the value/object/array to examine
	 * @param errorCount
	 *            current error count
	 * @return current error count
	 */
	private int recursiveAddTranslationActions(String key, String path, Object value, int errorCount) {

		if (value instanceof JSONArray) {
			// Process an array by iterating through all declared values
			translationActionList.add(new TranslationAction(key, path, Operations.NestArray));
			JSONArray jsonArray = (JSONArray) value;
			int index = 0;
			for (Object obj : jsonArray) {
				String childPath = path + '[' + index + ']';
				errorCount = recursiveAddTranslationActions(String.valueOf(index), childPath, obj, errorCount);
				index++;
			}
			translationActionList.add(new TranslationAction(key, path, Operations.Unnest));
		} else if (value instanceof JSONObject) {
			// Process an object by iterating through each key in the object
			translationActionList.add(new TranslationAction(key, path, Operations.NestObject));
			JSONObject jsonObject = (JSONObject) value;
			for (Object field : jsonObject.keySet()) {
				String childKey = (String) field.toString();
				String childPath = (path.length() == 0) ? childKey : path + '.' + childKey;
				errorCount = recursiveAddTranslationActions(childKey, childPath, jsonObject.get(childKey), errorCount);
			}
			translationActionList.add(new TranslationAction(key, path, Operations.Unnest));
		} else {
			// All other value types - get the target data type and add the
			// appropriate action
			TranslationAction action = new TranslationAction(key, path, (String) value);
			translationActionList.add(action);
			if (action.operation == Operations.Error) {
				errorCount++;
			}
		}

		return errorCount;
	}

	public void setFieldHandlingErrorPolicy(FieldHandlingErrorPolicy policyCode) {
		this.fieldHandlingErrorPolicy = policyCode;
	}

	public void setFieldHandlingErrorPolicy(String policy) {
		try {
			this.fieldHandlingErrorPolicy = FieldHandlingErrorPolicy.valueOf(policy);
		} catch (IllegalArgumentException e) {
			this.fieldHandlingErrorPolicy = FieldHandlingErrorPolicy.DISCARD_AND_LOG;
			log.error("Invalid type conversion policy: " + policy + ", using default of "
					+ this.fieldHandlingErrorPolicy.toString());
		}
	}

	private void addDefaultScripts() {
		/*
		 * Add default script entries for every script found under
		 * DEFAULT_SCRIPTS_LOCATION
		 */
		List<ScriptFile> defaultScriptFiles = new ArrayList<ScriptFile>(5);
		Collection<File> availableScripts = FileUtils.listFiles(new File(DEFAULT_SCRIPTS_LOCATION),
				FileFilterUtils.fileFileFilter(), null);

		for (File file : availableScripts) {
			if (file.getName().endsWith("groovy")) {
				log.info("Adding default script: " + file.getAbsolutePath());
				ScriptFile sf = new ScriptFile();
				sf.setScriptDirectory(DEFAULT_SCRIPTS_LOCATION);
				sf.setScriptName(file.getName());
				defaultScriptFiles.add(sf);
			} else {
				log.info("Skipping default script (not groovy): " + file.getAbsolutePath());
			}
		}

		/*
		 * Re-add existing scripts except dummy template entry
		 */
		this.scriptEngineFactory.setScriptFiles(defaultScriptFiles.toArray(new ScriptFile[0]));
	}

	/**
	 * Set and get the Script Engine Factory. This is configured in the
	 * parsers.xml file.
	 */

	public void setScriptEngineFactory(ScriptEngineFactory scriptEngineFactory) {
		this.scriptEngineFactory = scriptEngineFactory;
	}

	public ScriptEngineFactory getScriptEngineFactory() {
		return scriptEngineFactory;
	}

	/**
	 * Set and get the data model name.
	 */
	public void setModelName(String value) {
		this.modelName = value;
	}

	public String getModelName() {
		return this.modelName;
	}

	/**
	 * Set and get a string representation of the data model version. Format is
	 * <major>.<minor>
	 */
	public void setModelVersion(String value) {
		this.modelVersionString = value;
	}

	public String getModelVersion() {
		return this.modelVersionString;
	}

	/**
	 * Set and get the input format name.
	 */
	public void setInputFormatName(String value) {
		this.inputFormatName = value;
	}

	public String getInputFormat() {
		return this.inputFormatName;
	}

	/**
	 * Set and get the data model resource where data model configuration can be
	 * obtained. This is primarily intended to be used for testing, under normal
	 * system operation the data model is pulled from the repository.
	 * 
	 * @param modelPath
	 *            source folder where the data model should reside
	 */
	public void loadDataModel(String modelPath) throws IOException {
		dataModelNaming = new DataModelBasedNames(modelName, modelVersionString);
		File modelFile = new File(modelPath, dataModelNaming.getFullModeZipFilename());
		DataModelZipFile zipFile = new DataModelZipFile(new FileInputStream(modelFile));
		canonicalFormat = new CanonicalFormat(zipFile.getCanonicalModel());
		String translationDirectives = AbstractSystemRepository.inputStream2String(zipFile
				.getTranslationMapping(inputFormatName));
		translationDirectiveJson = (JSONObject) JSONSerializer.toJSON(translationDirectives);

	}

	public List<String> getExpectedHeaderNames() {
		return expectedHeaders;
	}

	public List<String> getMissingHeaderNames() {
		return missingHeaders;
	}

	/**
	 * Constructor - use this class by creating an instance of it, calling the
	 * set methods to set the translation directive file and canonical format
	 * file (at a minimum), and then call initialize().
	 */
	public AbstractConfigurableTranslator() {
		fieldHandlingErrorPolicy = FieldHandlingErrorPolicy.DISCARD_AND_LOG;
	}

	private void checkRequiredProperty(String value, String name) {
		if (value == null) {
			throw new InitializationException("Missing required property:" + name);
		}
	}

	/**
	 * Initialize the object. Must be called before the object can be used.
	 */
	public void initialize() throws InitializationException {

		int errorCount = 0;

		checkRequiredProperty(modelName, "modelName");
		checkRequiredProperty(modelVersionString, "modelVersionString");
		checkRequiredProperty(inputFormatName, "inputName");
		
		Pattern nestedArrayPattern = Pattern.compile(nestedArrayRegex);
		nestedArrayMatcher = nestedArrayPattern.matcher("");

		try {
			/* Create the script engine if one is configured. */
			if (scriptEngineFactory != null) {
				scriptEngineFactory.initialize();
				addDefaultScripts();
				invocable = scriptEngineFactory.createInvocable();
			}

			dataModelNaming = new DataModelBasedNames(modelName, modelVersionString);

			// Get the canonical and translation files from the configured data
			// model resource
			/*
			 * dataModelResource.initialize(); FileSetId fileSetId = new
			 * FileSetId(modelName, modelVersionString); canonicalFormat = new
			 * CanonicalFormat(dataModelResource.retrieve(fileSetId,
			 * DataModelBasedNames.CANONICAL )); String translationDirectives =
			 * dataModelResource.inputStream2String(
			 * dataModelResource.retrieve(fileSetId,
			 * DataModelBasedNames.TRANSLATE, inputFormatName));
			 * translationDirectiveJson = (JSONObject) JSONSerializer.toJSON(
			 * translationDirectives );
			 */
			// Load the canonical format and translation directives if it hasn't
			// already been done
			if ((canonicalFormat == null) && (translationDirectiveJson == null)) {
				DataModelZipFile zipFile = DataModelRepositoryRetrieve.getDataModelFromRepository(dataModelNaming
						.getFullModeZipFilename());
				canonicalFormat = new CanonicalFormat(zipFile.getCanonicalModel());
				String translationDirectives = AbstractSystemRepository.inputStream2String(zipFile
						.getTranslationMapping(inputFormatName));
				translationDirectiveJson = (JSONObject) JSONSerializer.toJSON(translationDirectives);
			}

			// Create translation list and process translation directive JSON
			// object
			// to populate directives
			translationActionList = new ArrayList<TranslationAction>();
			errorCount = recursiveAddTranslationActions("", "", translationDirectiveJson, 0);

			// Verify first action is to nest an object
			TranslationAction firstAction = translationActionList.get(0);
			if (firstAction.operation != Operations.NestObject) {
				log.error("Root object of parser directive JSON is not a JSON object");
				errorCount++;
			}

			header = new StandardHeader();
			header.setModelName(dataModelNaming.getModelName());
			header.setModelVersion(dataModelNaming.getMajorVersion(), dataModelNaming.getMinorVersion());

			expectedHeaders = new ArrayList<String>();
			// Iterate and log all errors and add the expected fields
			for (TranslationAction action : translationActionList) {
				if (action.operation == Operations.Error) {
					log.error(action.errorMsg);
				} else if (action.operation == Operations.GetField) {
					addExpectedGetField((String) action.parameters[0]);
				} else if (action.operation == Operations.Convert) {
					addExpectedConvertFields((String) action.parameters[0]);
				}
			}
		} catch (Exception e) {
			throw new InitializationException("Initialization failed due to exception: " + e.getMessage(), e);
		}

		if (errorCount > 0) {
			throw new InitializationException(errorCount + " errors detected during translaction directive processing");
		}
	}

	public void dispose() {
		translationDirectiveJson = null;
		canonicalFormat = null;
		translationActionList = null;
	}

	/**
	 * Verify a string value conforms to the given target type, and return a
	 * value object appropriate for the string value, performing conversions if
	 * necessary.
	 * 
	 * @param dataType
	 *            base data type
	 * @param format
	 *            format specifier (only needed for certain types)
	 * @param value
	 *            value string
	 * @return an object appropriate for the string value, or null if the value
	 *         does not conform
	 */
	private static Object convertString(DataTypes dataType, String format, String value) {

		Object result = null;

		try {
			switch (dataType) {
			case string:
				result = value;
				break;
			case number:
				value = value.replaceAll(",", "");
				char chars[] = value.toCharArray();
				boolean onlyDigits = true;
				for (Character c : chars) {
					if (!Character.isDigit(c)) {
						onlyDigits = false;
						break;
					}
				}
				if (onlyDigits) {
					Long longObj = new Long(value);
					result = longObj;
				} else {
					Double doubleObj = new Double(value);
					result = doubleObj;
				}
				break;
			case datestring:
				if ((format != null) && (value != null)) {
					SimpleDateFormat dateFormat = new SimpleDateFormat(format);
					if (dateFormat.parse(value) != null) {
						result = value;
					}
				}
				break;
			default:
				throw new BugCheckException("dataType is invalid");
			}
		} catch (IllegalArgumentException e) {
			result = null;
		} catch (ParseException e) {
			result = null;
		}

		return result;
	}

	/**
	 * Adds a value object to a JSONObject or JSONArray.
	 * 
	 * @param json
	 *            JSONObject or JSONArray
	 * @param action
	 *            translation action
	 * @param value
	 *            value object
	 */
	private void addValue(Object json, TranslationAction action, Object value) {

		if (json instanceof JSONObject) {
			JSONObject jsonObj = (JSONObject) json;
			jsonObj.put(action.key, value);
		} else if (json instanceof JSONArray) {
			JSONArray jsonArray = (JSONArray) json;
			jsonArray.add(value);
		} else {
			throw new BugCheckException("json parameter is not a JSONObject or JSONArray");
		}
	}

	private void addArrayValue(Object json, TranslationAction action, List<Object> values) {
		JSONArray outArr = new JSONArray();
		for (Object o : values)
			outArr.add(o);
		if (json instanceof JSONObject) {
			JSONObject jsonObj = (JSONObject) json;
			jsonObj.put(action.key, outArr);
		} else if (json instanceof JSONArray) {
			JSONArray jsonArray = (JSONArray) json;
			jsonArray.add(outArr);
		} else {
			throw new BugCheckException("json parameter is not a JSONObject or JSONArray");
		}
	}

	/**
	 * Log an error based on the field error handling policy.
	 */
	private void fieldError(String message, Throwable e) {
		if (fieldHandlingErrorPolicy == FieldHandlingErrorPolicy.DISCARD_AND_LOG) {
			if (e == null)
				log.error(message);
			else
				log.error(message, e);
		}
	}

	/**
	 * Add a field to the json object, converting it from a string if needed.
	 */
	private void addField(Object json, TranslationAction action, String value) {

		Object valueObj = convertString(action.dataType, action.format, value);
		if (valueObj == null) {
			// Cannot convert value to the target type
			fieldError("Value '" + value + "' for canonical field " + action.path + " does not conform to the type "
					+ action.dataType.toString(), null);
		} else {
			addValue(json, action, valueObj);
		}
	}

	private void addArrayField(Object json, TranslationAction action, List<String> values) {
		List<Object> valueObjs = new ArrayList<Object>();
		for (String s : values) {
			valueObjs.add(convertString(action.dataType, action.format, s));
		}
		addArrayValue(json, action, valueObjs);
	}

	/**
	 * Perform a translation of the name/value pairs in the provided recordMap
	 * to the JSON output format specified in the translationDirectiveJson
	 * object.
	 * 
	 * The script command uses the following format in the translation JSOM
	 * file: script(<scriptName>, <scriptParameter>, ...). The script name is
	 * the name of a function in the script file that has been loaded. The
	 * script parameters are generally values which are stored in the recordMap.
	 * They can be accessed by using the key as a script parameter. Script
	 * parameters can also be a literal if it is prepended by an "="
	 * character.(e.g. =true). It is also possible to pass a null as a script
	 * parameter.
	 * 
	 * 
	 * @param recordMap
	 *            input fields mapped as string key/value pairs
	 * @param source
	 *            string describing the source of the record
	 * @param defaultAccessLabel
	 *            default string describing the access label for the record
	 * @return A JSON object ready for further processing
	 */
	public JSONObject recordTranslation(Map<String, String> recordMap, String source, String defaultAccessLabel) throws ParseException{

		Stack<Object> objectStack = new Stack<Object>();
		JSONObject rootObj = null;
		Object curObj = null;
		String value;
		String inputFormat;
		String timeZone;

		if (missingHeaders == null) { // Missing Headers is not being used,
										// replace with an empty list.
			missingHeaders = new ArrayList<String>();
		}
		
		for(String field : recordMap.keySet()){
			nestedArrayMatcher.reset(field);
			if(nestedArrayMatcher.find()){
				throw new ParseException("Arrays are not allowed to be nested.", 0);
			}
				
		}

		for (TranslationAction action : translationActionList) {

			// if (curObj != null) {
			// System.out.println(action.operation.toString() + "(" +
			// action.path + ")" + " : " + curObj.toString());
			// }

			switch (action.operation) {
			case Error:
				throw new BugCheckException("Translation list contains an error - translation is invalid");

			case NoOperation:
				break;

			case NestObject:
				objectStack.push(curObj);
				JSONObject nextObj = new JSONObject();
				if (curObj == null) {
					rootObj = (JSONObject) nextObj;
					header.updateUUID();
					String accessLabel = this.getAccessLabel(recordMap);
					header.setAccessLabel((accessLabel == null) ? defaultAccessLabel : accessLabel);
					header.setSource(source);
					rootObj.put(StandardHeader.HEADER_KEY, header.getJson());
				}
				curObj = nextObj;
				break;

			case NestArray:
				objectStack.push(curObj);
				JSONArray nextArray = new JSONArray();
				curObj = nextArray;
				break;

			case Unnest:
				Object prevObj = objectStack.pop();
				if (prevObj != null) {
					/*
					 * TJC - Moved the below to the NestObject operation so an
					 * record that has no subobjects works.
					 */
					/*
					 * if ((rootObj == null) && (prevObj.getClass() ==
					 * JSONObject.class) && (objectStack.size() == 1)) { rootObj
					 * = (JSONObject)prevObj; header.updateUUID(); String
					 * accessLabel = this.getAccessLabel(recordMap);
					 * header.setAccessLabel( (accessLabel == null) ?
					 * defaultAccessLabel : accessLabel );
					 * header.setSource(source);
					 * rootObj.put(StandardHeader.HEADER_KEY, header.getJson());
					 * }
					 */
					addValue(prevObj, action, curObj);
				}
				curObj = prevObj;
				break;

			case CopyLiteral:
				addValue(curObj, action, action.parameters[0]);
				break;

			case GetField:
				value = recordMap.get(action.parameters[0]);
				if (value == null) {
					value = (String) action.parameters[1]; // Can't find the
															// field - try using
															// default
					if ((value == null) && (!(missingHeaders.contains(action.parameters[0])))) {
						// Value could not be found and there is no default and
						// it is not part of the missing fields.
						fieldError("Input data did not contain the input field " + (String) action.parameters[0], null);
					}
				} else if (value.length() == 0) {
					value = (String) action.parameters[1]; // Null string - try
															// default
				}

				if (value != null) {
					addField(curObj, action, value);
				}
				break;
			case GetArray:
				String arrVal = (String) action.parameters[0];
				List<String> values = new ArrayList<String>();
				int index = 0;
				boolean foundVal = true;
				while (foundVal) {
					String thisIndex = arrVal.replace("[*]", "[" + index + "]");
					if (recordMap.containsKey(thisIndex)) {
						values.add(recordMap.get(thisIndex));
					} else {
						foundVal = false;
					}
					index++;
				}
				// If there is no array in the recordMap, then look for a single
				// value with a non-array key
				if (index == 1) {
					String thisIndex = arrVal.replace("[*]", "");
					if (recordMap.containsKey(thisIndex)) {
						values.add(recordMap.get(thisIndex));
					}
				}
				addArrayField(curObj, action, values);

				break;
			case Convert:

				String fields = (String) action.parameters[0];
				value = combineFields(recordMap, fields);

				if (action.parameters.length > 1) {
					inputFormat = (String) action.parameters[1];
				} else {
					inputFormat = null;
				}

				if (action.parameters.length > 2) {
					timeZone = (String) action.parameters[2];
				} else {
					timeZone = null;
				}

				if (value.isEmpty()) {
					// Cannot find the field in the input
					fieldError("Input Date String'" + value + "' for canonical field " + action.path
							+ " is not specified", null);
				} else if (inputFormat != null) {
					if (action.format == null) {
						fieldError("Canonical Date format for canonical field " + action.path + " is not specified",
								null);
					} else {
						value = convertDate(action, value, inputFormat, timeZone);
					}
					addField(curObj, action, value);
				}
				break;

			case Custom:
				try {
					value = customFieldTranslator(action.path, action.key, recordMap);

					if (value == null) {
						// Cannot find the field in the input
						fieldError("Null string returned from custom field translator for canonical field "
								+ action.path, null);
					} else {
						addField(curObj, action, value);
					}
				} catch (Exception e) {
					value = null;
					fieldError("Exception raised during custom field translator for canonical field " + action.path, e);
				}

				break;

			case Script:

				if (invocable == null) {
					fieldError("No Script Engine Configured " + action.path, null);
				} else {
					if (action.scriptOperation == null) {
						fieldError("No Script Operation has been specified " + action.path, null);
					}
					Object[] scriptParameters = loadScriptParameters(recordMap, action.parameters);
					try {
						value = (String) invocable.invokeFunction(action.scriptOperation, scriptParameters);
						if (value != null) {
							addField(curObj, action, value);
						}
					} catch (Exception ex) {
						fieldError("Error Running Script " + action.path, ex);
					}
				}

				break;

			}
		}

		return rootObj;
	}

	/**
	 * This method will load the script parameters from the script command. The
	 * parameters to a script are listed after the script command that will be
	 * called. Generally, the script parameters will taken from the recordMap
	 * using the parameter key supplied. However, if you it is necessary to send
	 * a literal to the script, it can be prepended with an "=" character. It is
	 * also possible to send a null as a parameter to a script. If there are no
	 * action parameters, then the method will retun a null and the script
	 * function will be called without parameters.
	 * 
	 * @param recordMap
	 *            input fields mapped as string key/value pairs.
	 * @param actionParameters
	 *            parameters to support the action command.
	 * @return An array of Objects containing the script parameters.
	 */
	private Object[] loadScriptParameters(Map<String, String> recordMap, Object[] actionParameters) {
		final String literalStringStartChar = "=";
		Object[] parameterValues = null;

		if ((actionParameters != null) && (actionParameters.length > 0)) {
			parameterValues = new Object[actionParameters.length];
			int position = 0;
			for (Object valueName : actionParameters) {
				if (valueName != null) {
					if (valueName.toString().startsWith(literalStringStartChar)) {
						// Parameter is a literal, need to strip off the
						// identifying literal character.
						parameterValues[position++] = valueName.toString().substring(1);
					} else {
						// Parameter is stored in the recordMap.
						parameterValues[position++] = recordMap.get(valueName);
					}
				} else {
					// Parameter value is a null.
					parameterValues[position++] = null;
				}

			}
		}

		return parameterValues;
	}

	private void addExpectedGetField(String headerName) {
		expectedHeaders.add(headerName);
	}

	private void addExpectedConvertFields(String headerNamesString) {
		String[] headerNames = headerNamesString.split(headerSeperator);
		for (String headerName : headerNames) {
			expectedHeaders.add(headerName);
		}
	}

	public void validateHeaders(String[] headerKeys, boolean stopOnMissingField) throws ValidationException {
		missingHeaders = new ArrayList<String>();
		List<String> actualHeaders = Arrays.asList(headerKeys);

		for (String expectedHeader : expectedHeaders) {
			if (!(actualHeaders.contains(expectedHeader))) {
				log.error("Header " + expectedHeader + " is missing");
				missingHeaders.add(expectedHeader);
			}
		}
		if ((missingHeaders.size() > 0) && (stopOnMissingField)) {
			throw new ValidationException(
					"Parsing stopped because of missing field(s) and StopOnMissingField Parameter is TRUE");
		}
	}

	private String convertDate(TranslationAction action, String inputDateString, String inputFormat, String timeZone) {
		String convertedDate = null;

		try {
			SimpleDateFormat inputDateFormat = new SimpleDateFormat(inputFormat);
			SimpleDateFormat canonicalDateFormat = new SimpleDateFormat(action.format);
			if (timeZone != null) {
				canonicalDateFormat.setTimeZone(TimeZone.getTimeZone(timeZone));
			}
			Date inputDate = inputDateFormat.parse(inputDateString);
			convertedDate = canonicalDateFormat.format(inputDate);
		} catch (Exception ex) {
			log.warn("Error converting date to specified format.  Returning original string.",ex);
			// Do not record, just return original string, since it cannot be
			// formatted.
			return inputDateString;
		}

		return convertedDate;
	}

	private String combineFields(Map<String, String> recordMap, String fields) {
		StringBuffer returnValue = new StringBuffer();
		String[] fieldsToCombine = fields.split(headerSeperator);

		for (String field : fieldsToCombine) {
			returnValue.append(recordMap.get(field));
			returnValue.append(" ");
		}

		return returnValue.toString().trim();
	}

	/**
	 * Returns the access label string from the input data. Must be overridden
	 * if needed.
	 * 
	 * @param recordMap
	 *            Record Map input data
	 * @return the access label string
	 */
	public String getAccessLabel(Map<String, String> recordMap) {
		return null;
	}

	/**
	 * Method called to perform a custom field translation.
	 * 
	 * @param outputFieldPath
	 *            path to the canonical output field being produced
	 * @param outputFieldKey
	 *            key name to the canonical output field being produced
	 * @param recordMap
	 *            map of input name/value pairs
	 * @return the custom string value to be added to the output
	 * @throws UnsupportedOperationException
	 */
	public abstract String customFieldTranslator(String outputFieldPath, String outputFieldKey,
			Map<String, String> recordMap);
}
