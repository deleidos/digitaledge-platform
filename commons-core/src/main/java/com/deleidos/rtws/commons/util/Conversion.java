/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.commons.util;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Calendar;
import java.util.SimpleTimeZone;

/**
 * This class provides utilities for converting between various units.  All
 * class methods are provided as public static final for high performance
 * utilization in application software.  Each of the conversions is highly
 * dependent on the constants provided by the caps.sac.math.Constant class.
 * All computations are done using primitive double variable types.
 */
public final class Conversion {
    /** 2 .*/
	private static final int INT_2   = 2;
    /** 3 .*/
	private static final int INT_3   = 3;
    /** 4 .*/
	private static final int INT_4   = 4;
    /** 5 .*/
	private static final int INT_5   = 5;
    /** 6 .*/
	private static final int INT_6  = 6;
    /** 7 .*/
	private static final int INT_7   = 7;
    /** 8 .*/
	//private static final int INT_8   = 8;
    /** 9 .*/
	private static final int INT_9   = 9;
    /** 10 .*/
	private static final int INT_10  = 10;
    /** 44 .*/
	private static final int INT_44  = 44;
    /** 45 .*/
	private static final int INT_45  = 45;
    /** 50 .*/
	private static final int INT_50  = 50;
    /** 60 .*/
	private static final int INT_60  = 60;
    /** 100 .*/
	private static final int INT_100 = 100;
	/** 128 .*/
	private static final int NUM_128 = 128;
    /** 1000 .*/
	private static final int INT_1000        = 1000;
	/** 3600 .*/
	private static final int INT_3600        = 3600;
    /** 10000 .*/
	private static final int INT_10000       = 10000;
    /** 100000 .*/
	private static final int INT_100000      = 100000;
    /** 1000000 .*/
	private static final int INT_1000000     = 1000000;
    /** 10000000 .*/
	private static final int INT_10000000    = 10000000;
    /** 100000000 .*/
	private static final int INT_100000000   = 100000000;
    /** 100000000 .*/
	private static final int INT_1000000000  = 1000000000;
	
	private static final SimpleDateFormat rfc2616DateFormat = new SimpleDateFormat("EEE, dd MMMM yyyy HH:mm:ss z");

	/** Constructor. */
    protected Conversion() { }

    /**
     * Converts from Meters to Feet.
     *
     * @param meters A distance (meters to be converted to feet.
     * @return The distance in feet equal to the input meters.
     */
    public static double metersToFeet(final double meters) {
        return meters * Constant.FEET_PER_METER;
    }

    /**
     * Converts from Meters to Nautical Miles.
     *
     * @param meters A distance (meters) to be converted to nautical miles.
     * @return The distance in nautical miles equal to the input meters.
     */
    public static double metersToNautMiles(final double meters) {
        return meters * Constant.NAUTMILES_PER_METER;
    }

    /**
     * Converts from Meters to Radians. NOTE: This is probably based on some
     * radius of the Earth.  Must discover what value is used in that
     * computation.
     *
     * @param meters A distance (meters) to be converted to radians
     * @return The distance in radians equal to the input meters.
     */
    public static double metersToRadians(final double meters) {
        return meters * Constant.RADIANS_PER_METER;
    }

    /**
     * Converts from Radians to Meters. NOTE: This is probably based on some
     * radius of the Earth.  Must discover what value is used in that
     * computation.
     *
     * @param radians A distance (radians) to be converted to meters
     * @return The distance in meters equal to the input radians.
     */
    public static double radiansToMeters(final double radians) {
        return radians * Constant.METERS_PER_RADIAN;
    }

    /**
     * Converts from Kilometers to Radians. NOTE: This is probably based on
     * some radius of the Earth.  Must discover what value is used in that
     * computation.
     *
     * @param kilometers A distance (kilometers) to be converted to radians
     * @return The distance in radians equal to the input kilometers.
     */
    public static double kilometersToRadians(final double kilometers) {
        return kilometers * Constant.RADIANS_PER_KILOMETER;
    }

    /**
     * Converts from Nautical Miles to Degrees. NOTE: This is probably based on
     * some radius of the Earth.  Must discover what value is used in that
     * computation.
     *
     * @param miles A distance (nautical miles) to be converted to degrees
     * @return The distance in degrees equal to the input nautical miles.
     */
    public static double nautMilesToDegrees(final double miles) {
        return miles * Constant.DEGREES_PER_NAUTMILE;
    }

    /**
     * Converts from Nautical Miles to Radians. NOTE: This is probably based on
     * some radius of the Earth.  Must discover what value is used in that
     * computation.
     *
     * @param miles A distance (nautical miles) to be converted to radians
     * @return The distance in radians equal to the input nautical miles.
     */
    public static double nautMilesToRadians(final double miles) {
        return miles * Constant.RADIANS_PER_NAUTMILE;
    }

    /**
     * Converts from Feet to Meters.
     *
     * @param feet A distance (feet) to be converted to meters.
     * @return The distance in meters equal to the input feet.
     */
    public static double feetToMeters(final double feet) {
        return feet * Constant.METERS_PER_FOOT;
    }

    /**
     * Converts from Nautical Miles to Meters.
     *
     * @param miles A distance (nautical miles) to be converted to meters.
     * @return The distance in meters equal to the input nautical miles.
     */
    public static double nautMilesToMeters(final double miles) {
        return miles * Constant.METERS_PER_NAUTMILE;
    }

    /**
     * Converts from Kilometers to Meters.
     *
     * @param kilometers A distance (kilometers) to be converted to meters
     * @return The distance in meters equal to the input kilometers.
     */
    public static double kilometersToMeters(final double kilometers) {
        return kilometers * Constant.METERS_PER_KILOMETER;
    }

    /**
     * Converts from Meters to Kilometers.
     *
     * @param meters A distance (meters) to be converted to kilometers
     * @return The distance in ilometers equal to the input meters.
     */
    public static double metersToKilometers(final double meters) {
        return meters * Constant.KILOMETERS_PER_METER;
    }

    /**
     * Converts from Kilometers to Nautical Miles.
     *
     * @param kilometers A distance (kilometers) to be converted to nautical
     *                   miles
     * @return The distance in nautical miles equal to the input kilometers.
     */
    public static double kilometersToNautMiles(final double kilometers) {
        return kilometers * Constant.NAUTMILES_PER_KILOMETER;
    }

    /**
     * Converts from Nautical Miles to Kilometers.
     *
     * @param miles A distance (nautical miles) to be converted to kilometers.
     * @return The distance in kilometers equal to the input nautical miles.
     */
    public static double nautMilesToKilometers(final double miles) {
        return miles * Constant.KILOMETERS_PER_NAUTMILE;
    }

    /**
     * Converts from Feet to Nautical Miles.
     *
     * @param feet A distance (feet) to be converted to nautical miles.
     * @return The distance in nautical miles equal to the input feet.
     */
    public static double feetToNautMiles(final double feet) {
        return feet * Constant.NAUTMILES_PER_FOOT;
    }

    /**
     * Converts from Nautical Miles to Feet.
     *
     * @param miles A distance (nautical miles) to be converted to feet.
     * @return The distance in feet equal to the input nautical miles.
     */
    public static double nautMilesToFeet(final double miles) {
        return miles * Constant.FEET_PER_NAUTMILE;
    }

    /**
     * Converts from Kilometers to Feet.
     *
     * @param kilometers A distance (kilometers) to be converted to feet.
     * @return The distance in feet equal to the input kilometers.
     */
    public static double kilometersToFeet(final double kilometers) {
        return kilometers * Constant.FEET_PER_KILOMETER;
    }

    /**
     * Converts from Feet to Kilometers.
     *
     * @param feet A distance (feet) to be converted to kilometers.
     * @return The distance in kilometers equal to the input feet.
     */
    public static double feetToKilometers(final double feet) {
        return feet * Constant.KILOMETERS_PER_FOOT;
    }

    /**
     * Converts from Radians to Degrees.
     *
     * @param radians An angle (radians) to be converted to degrees.
     * @return The angle in degrees equal to the input radians.
     */
    public static double radiansToDegrees(final double radians) {
        return radians * Constant.DEG_PER_RAD;
    }

    /**
     * Converts from Degrees to Radians.
     *
     * @param degrees An angle (degrees) to be converted to radians.
     * @return The angle in radians equal to the input degrees.
     */
    public static double degreesToRadians(final double degrees) {
        return degrees * Constant.RAD_PER_DEG;
    }

    /**
     * Converts from Knots to Kilometers/Hour.
     *
     * @param knots A speed (knots) to be converted to kilometers per hour.
     * @return The speed in kph equal to the input knots.
     */
    public static double knotsToKPH(final double knots) {
        return knots * Constant.KPH_PER_KNOT;
    }

    /**
     * Converts from Knots to Meters/Second.
     *
     * @param knots A speed (knots) to be converted to meters per second.
     * @return The speed in mps equal to the input knots.
     */
    public static double knotsToMPS(final double knots) {
        return knots * Constant.MPS_PER_KNOT;
    }

    /**
     * Converts from Kilometers/Hour to Knots.
     *
     * @param kph A speed (kilometers per hour) to be converted to knots.
     * @return The speed in knots equal to the input kph.
     */
    public static double kphToKnots(final double kph) {
        return kph * Constant.KNOTS_PER_KPH;
    }

    /**
     * Converts from Kilometers/Hour to Meters/Second.
     *
     * @param kph A speed (kilometers per hour) to be converted to meters per
     *            second.
     * @return The speed in mps equal to the input kph.
     */
    public static double kphToMPS(final double kph) {
        return kph * Constant.MPS_PER_KPH;
    }

    /**
     * Converts from Meters/Second to Knots.
     *
     * @param mps A speed (meters per second) to be converted to knots.
     * @return The speed in knots equal to the input mps.
     */
    public static double mpsToKnots(final double mps) {
        return mps * Constant.KNOTS_PER_MPS;
    }

    /**
     * Converts from Meters/Second to Kilometers/Hour.
     *
     * @param mps A speed (meters per second) to be converted to kilometers per
     *            hour.
     * @return The speed in kph equal to the input mps.
     */
    public static double mpsToKPH(final double mps) {
        return mps * Constant.KPH_PER_MPS;
    }

    /**
     * Converts from Feet/Second to Meters/Second.
     *
     * @param fps A speed (feet per second) to be converted to meters per
     *            second.
     * @return The speed in mps equal to the input fps.
     */
    public static double fpsToMPS(final double fps) {
        return fps * Constant.MPS_PER_FPS;
    }

    /**
     * Converts from NauticalMiles/Hour to Meters/Second.
     *
     * @param nmph A speed (nautical miles per hour) to be converted to meters
     *            per second.
     * @return The speed in mps equal to the input nautical miles per hour.
     */
    public static double nmphToMPS(final double nmph) {
        return nmph * Constant.MPS_PER_NMPH;
    }

    //////////////////////////////
    // String Conversions
    //////////////////////////////

    /**
     * This method takes a value of seconds and formats it to hh:mm:ss.
     *
     * @param time the value to convert in seconds
     * @return the formatted string for the time
     */
    public static String toHHMMSS(final long time) {
        if (time <= 0) {
            return "00:00:00";
        }
        
        long hours   = time / INT_3600;
        long hoursec = hours * INT_3600;
        long minutes = (time - hoursec) / INT_60;
        long seconds = time - hoursec - (minutes * INT_60);

        StringBuffer string =
                new StringBuffer(Conversion.toString(hours)).append("h ");
        if (minutes < INT_10) {
            string.append("0");
        }
        string.append(Conversion.toString(minutes)).append("m ");
        if (seconds < INT_10) {
            string.append("0");
        }
        string.append(Conversion.toString(seconds)).append("s");

        return string.toString();
    }

    /**
     * Convert char to string.
     * @param c Value of char
     * @return String value of char
     */
    public static String toString(final char c) {
        return String.valueOf(c);
    }

    /**
     * Convert long to string.
     * @param l Value of long
     * @return String value of long
     */
    public static String toString(final long l) {
        StringBuffer s = new StringBuffer();
        append(s, l);
        return s.toString();
    }

    /**
     * Convert int to string.
     * @param i Value of int
     * @return String value of int
     */
    public static String toString(final int i) {
//        StringBuffer s = new StringBuffer();
//        append(s, i);
//        return s.toString();
        return Integer.toString(i);
    }

    /**
     * Convert short to string.
     * @param n Value of short
     * @return String value of short
     */
    public static String toString(final short n) {
//        StringBuffer s = new StringBuffer();
//        append(s, n);
//        return s.toString();
        return Integer.toString((int) n);
    }

    /**
     * Convert byte to string.
     * @param b Value of byte
     * @return String value of byte
     */
    public static String toString(final byte b) {
        StringBuffer s = new StringBuffer();
        append(s, b);
        return s.toString();
    }

    /**
     * Convert float to string.
     * @param d Value of float
     * @return String value of float
     */
    public static String toString(final float d) {
        StringBuffer s = new StringBuffer();
        append(s, d);
        return s.toString();
    }

    /**
     * Convert double to string.
     * @param d Value of double
     * @return String value of double
     */
    public static String toString(final double d) {
        StringBuffer s = new StringBuffer();
        append(s, d);
        return s.toString();
    }

    /**
     * Returns a String that represents the value of RealValue.  The precision
     * parameter is used to indicate the maximum number of digits to display
     * behind the decimal point.
     *
     * @param val Double value to be converted to a String
     * @param precision An integer for the number of decimal places to show.
     * @return A String that represents the value of RealValue.
     */
    public static String toString(final double val, final int precision) {
        if (precision == 0) {   // Must show value as an integer
            return Conversion.toString((int) Math.round(val));
        } else {
            // If we get here, must show value as a real number
            double factor = Math.pow(INT_10, (double) precision);
            double result = (Math.rint(val * factor)) / factor;
            return Conversion.toString(result);
        }
    }
    
    /**
     * Convert double to string.
     * @param d Value of double
     * @return String value of double
     */
    public static String toString(final Double d) {
        return Conversion.toString(d.doubleValue());
    }

    /**
     * Convert boolean to string.
     * @param b Value of boolean
     * @return String value of boolean
     */
    public static String toString(final boolean b) {
        return (b) ? "true" : "false";
    }

    /*
     * The following methods and constants apply to optimized toString
     * conversions.  These methods were provided in in reference books as
     * mentioned in each method below.  This code comes from a third party and
     * is included here for functionality even though standard coding practices
     * may not be entirely followed.
     */

    /** String for byte. */
    protected static final String[] STRING_FOR_BYTE = {"-128", "-127", "-126",
        "-125", "-124", "-123", "-122", "-121", "-120", "-119", "-118", "-117",
        "-116", "-115", "-114", "-113", "-112", "-111", "-110", "-109", "-108",
        "-107", "-106", "-105", "-104", "-103", "-102", "-101", "-100", "-99",
        "-98", "-97", "-96", "-95", "-94", "-93", "-92", "-91", "-90", "-89",
        "-88", "-87", "-86", "-85", "-84", "-83", "-82", "-81", "-80", "-79",
        "-78", "-77", "-76", "-75", "-74", "-73", "-73", "-71", "-70", "-69",
        "-68", "-67", "-66", "-65", "-64", "-63", "-62", "-61", "-60", "-59",
        "-58", "-57", "-56", "-55", "-54", "-53", "-52", "-51", "-50", "-49",
        "-48", "-47", "-46", "-45", "-44", "-43", "-42", "-41", "-40", "-39",
        "-38", "-37", "-36", "-35", "-34", "-33", "-32", "-31", "-30", "-29",
        "-28", "-27", "-26", "-25", "-24", "-23", "-22", "-21", "-20", "-19",
        "-18", "-17", "-16", "-15", "-14", "-13", "-12", "-11", "-10", "-9",
        "-8", "-7", "-6", "-5", "-4", "-3", "-2", "-1", "0", "1", "2", "3", "4",
        "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17",
        "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
        "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
        "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53",
        "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65",
        "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77",
        "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
        "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100",
        "101", "102", "103", "104", "105", "106", "107", "108", "109", "110",
        "111", "112", "113", "114", "115", "116", "117", "118", "119", "120",
        "121", "122", "123", "124", "125", "126", "127"};

    /** Array of null string chars. */
    public static final char[] NULL = {'n', 'u', 'l', 'l'};

    /**
     * char array holding the characters for the string "-Infinity".
     */
    public static final char[] NEGATIVE_INFINITY = {'-', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'};

    /**
     * char array holding the characters for the string "Infinity".
     */
    public static final char[] POSITIVE_INFINITY = {'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'};

    /**
     * char array holding the characters for the string "NaN".
     */
    public static final char[] NaN = {'N', 'a', 'N'};

    /**
     * char array holding the characters for the string "0.0".
     */
    public static final char[] DOUBLE_ZERO = {'0', '.', '0'};

    /**
     * char array holding the characters for the string "0.00".
     */
    public static final char[] DOUBLE_ZERO2 = {'0', '.', '0', '0'};

    /**
     * char array holding the characters for the string "0.".
     */
    public static final char[] DOUBLE_ZERO0 = {'0', '.'};

    /**
     * char array holding the characters for the string ".0".
     */
    public static final char[] DOT_ZERO = {'.', '0'};

    /**
     * char array holding the characters for the string ", ".
     */
    public static final char[] COMMA_SPACE = {',', ' '};

    /** double sign mask. */
    protected static final long	DOUBLE_SIGN_MASK = 0x8000000000000000L;
    
    /** double exp mask. */
    protected static final long	DOUBLE_EXP_MASK  = 0x7ff0000000000000L;
    
    //private static final long	doubleFractMask= ~(doubleSignMask|doubleExpMask);
    
    /** double exp shift. */
    protected static final int	DOUBLE_EXP_SHIFT = 52;
    
    /** double exp bias. */
    protected static final int	DOUBLE_EXP_BIAS = 1023;
    
    /** float sign mask. */
    protected static final int	FLOAT_SIGN_MASK = 0x80000000;
    
    /** fload exp mask. */
    protected static final int	FLOAT_EXP_MASK  = 0x7f800000;
    
    //private static final int	floatFractMask= ~(floatSignMask|floatExpMask);
    
    /** float exp shift. */
    protected static final int	FLOAT_EXP_SHIFT = 23;
    
    /** float exp bias. */
    protected static final int	FLOAT_EXP_BIAS = 127;

    /** char for digit. */
    protected static final char[] CHAR_FOR_DIGIT = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    };

    /** float magnitudes. */
    protected static final float[] F_MAGNITUDES = {
        1e-44F, 1e-43F, 1e-42F, 1e-41F, 1e-40F,
        1e-39F, 1e-38F, 1e-37F, 1e-36F, 1e-35F, 1e-34F, 1e-33F, 1e-32F, 1e-31F,
        1e-30F, 1e-29F, 1e-28F, 1e-27F, 1e-26F, 1e-25F, 1e-24F, 1e-23F, 1e-22F,
        1e-21F, 1e-20F, 1e-19F, 1e-18F, 1e-17F, 1e-16F, 1e-15F, 1e-14F, 1e-13F,
        1e-12F, 1e-11F, 1e-10F, 1e-9F, 1e-8F, 1e-7F, 1e-6F, 1e-5F, 1e-4F, 1e-3F,
        1e-2F, 1e-1F, 1e0F, 1e1F, 1e2F, 1e3F, 1e4F, 1e5F, 1e6F, 1e7F, 1e8F,
        1e9F, 1e10F, 1e11F, 1e12F, 1e13F, 1e14F, 1e15F, 1e16F, 1e17F, 1e18F,
        1e19F, 1e20F, 1e21F, 1e22F, 1e23F, 1e24F, 1e25F, 1e26F, 1e27F, 1e28F,
        1e29F, 1e30F, 1e31F, 1e32F, 1e33F, 1e34F, 1e35F, 1e36F, 1e37F, 1e38F
    };

    /** double magnitudes. */
    protected static final double[] D_MAGNITUDES = {
        1e-323D, 1e-322D, 1e-321D, 1e-320D, 1e-319D, 1e-318D, 1e-317D, 1e-316D,
        1e-315D, 1e-314D, 1e-313D, 1e-312D, 1e-311D, 1e-310D, 1e-309D, 1e-308D,
        1e-307D, 1e-306D, 1e-305D, 1e-304D, 1e-303D, 1e-302D, 1e-301D, 1e-300D,
        1e-299D, 1e-298D, 1e-297D, 1e-296D, 1e-295D, 1e-294D, 1e-293D, 1e-292D,
        1e-291D, 1e-290D, 1e-289D, 1e-288D, 1e-287D, 1e-286D, 1e-285D, 1e-284D,
        1e-283D, 1e-282D, 1e-281D, 1e-280D, 1e-279D, 1e-278D, 1e-277D, 1e-276D,
        1e-275D, 1e-274D, 1e-273D, 1e-272D, 1e-271D, 1e-270D, 1e-269D, 1e-268D,
        1e-267D, 1e-266D, 1e-265D, 1e-264D, 1e-263D, 1e-262D, 1e-261D, 1e-260D,
        1e-259D, 1e-258D, 1e-257D, 1e-256D, 1e-255D, 1e-254D, 1e-253D, 1e-252D,
        1e-251D, 1e-250D, 1e-249D, 1e-248D, 1e-247D, 1e-246D, 1e-245D, 1e-244D,
        1e-243D, 1e-242D, 1e-241D, 1e-240D, 1e-239D, 1e-238D, 1e-237D, 1e-236D,
        1e-235D, 1e-234D, 1e-233D, 1e-232D, 1e-231D, 1e-230D, 1e-229D, 1e-228D,
        1e-227D, 1e-226D, 1e-225D, 1e-224D, 1e-223D, 1e-222D, 1e-221D, 1e-220D,
        1e-219D, 1e-218D, 1e-217D, 1e-216D, 1e-215D, 1e-214D, 1e-213D, 1e-212D,
        1e-211D, 1e-210D, 1e-209D, 1e-208D, 1e-207D, 1e-206D, 1e-205D, 1e-204D,
        1e-203D, 1e-202D, 1e-201D, 1e-200D, 1e-199D, 1e-198D, 1e-197D, 1e-196D,
        1e-195D, 1e-194D, 1e-193D, 1e-192D, 1e-191D, 1e-190D, 1e-189D, 1e-188D,
        1e-187D, 1e-186D, 1e-185D, 1e-184D, 1e-183D, 1e-182D, 1e-181D, 1e-180D,
        1e-179D, 1e-178D, 1e-177D, 1e-176D, 1e-175D, 1e-174D, 1e-173D, 1e-172D,
        1e-171D, 1e-170D, 1e-169D, 1e-168D, 1e-167D, 1e-166D, 1e-165D, 1e-164D,
        1e-163D, 1e-162D, 1e-161D, 1e-160D, 1e-159D, 1e-158D, 1e-157D, 1e-156D,
        1e-155D, 1e-154D, 1e-153D, 1e-152D, 1e-151D, 1e-150D, 1e-149D, 1e-148D,
        1e-147D, 1e-146D, 1e-145D, 1e-144D, 1e-143D, 1e-142D, 1e-141D, 1e-140D,
        1e-139D, 1e-138D, 1e-137D, 1e-136D, 1e-135D, 1e-134D, 1e-133D, 1e-132D,
        1e-131D, 1e-130D, 1e-129D, 1e-128D, 1e-127D, 1e-126D, 1e-125D, 1e-124D,
        1e-123D, 1e-122D, 1e-121D, 1e-120D, 1e-119D, 1e-118D, 1e-117D, 1e-116D,
        1e-115D, 1e-114D, 1e-113D, 1e-112D, 1e-111D, 1e-110D, 1e-109D, 1e-108D,
        1e-107D, 1e-106D, 1e-105D, 1e-104D, 1e-103D, 1e-102D, 1e-101D, 1e-100D,
        1e-99D, 1e-98D, 1e-97D, 1e-96D, 1e-95D, 1e-94D, 1e-93D, 1e-92D, 1e-91D,
        1e-90D, 1e-89D, 1e-88D, 1e-87D, 1e-86D, 1e-85D, 1e-84D, 1e-83D, 1e-82D,
        1e-81D, 1e-80D, 1e-79D, 1e-78D, 1e-77D, 1e-76D, 1e-75D, 1e-74D, 1e-73D,
        1e-72D, 1e-71D, 1e-70D, 1e-69D, 1e-68D, 1e-67D, 1e-66D, 1e-65D, 1e-64D,
        1e-63D, 1e-62D, 1e-61D, 1e-60D, 1e-59D, 1e-58D, 1e-57D, 1e-56D, 1e-55D,
        1e-54D, 1e-53D, 1e-52D, 1e-51D, 1e-50D, 1e-49D, 1e-48D, 1e-47D, 1e-46D,
        1e-45D, 1e-44D, 1e-43D, 1e-42D, 1e-41D, 1e-40D, 1e-39D, 1e-38D, 1e-37D,
        1e-36D, 1e-35D, 1e-34D, 1e-33D, 1e-32D, 1e-31D, 1e-30D, 1e-29D, 1e-28D,
        1e-27D, 1e-26D, 1e-25D, 1e-24D, 1e-23D, 1e-22D, 1e-21D, 1e-20D, 1e-19D,
        1e-18D, 1e-17D, 1e-16D, 1e-15D, 1e-14D, 1e-13D, 1e-12D, 1e-11D, 1e-10D,
        1e-9D, 1e-8D, 1e-7D, 1e-6D, 1e-5D, 1e-4D, 1e-3D, 1e-2D, 1e-1D, 1e0D,
        1e1D, 1e2D, 1e3D, 1e4D, 1e5D, 1e6D, 1e7D, 1e8D, 1e9D, 1e10D, 1e11D,
        1e12D, 1e13D, 1e14D, 1e15D, 1e16D, 1e17D, 1e18D, 1e19D, 1e20D, 1e21D,
        1e22D, 1e23D, 1e24D, 1e25D, 1e26D, 1e27D, 1e28D, 1e29D, 1e30D, 1e31D,
        1e32D, 1e33D, 1e34D, 1e35D, 1e36D, 1e37D, 1e38D, 1e39D, 1e40D, 1e41D,
        1e42D, 1e43D, 1e44D, 1e45D, 1e46D, 1e47D, 1e48D, 1e49D, 1e50D, 1e51D,
        1e52D, 1e53D, 1e54D, 1e55D, 1e56D, 1e57D, 1e58D, 1e59D, 1e60D, 1e61D,
        1e62D, 1e63D, 1e64D, 1e65D, 1e66D, 1e67D, 1e68D, 1e69D, 1e70D, 1e71D,
        1e72D, 1e73D, 1e74D, 1e75D, 1e76D, 1e77D, 1e78D, 1e79D, 1e80D, 1e81D,
        1e82D, 1e83D, 1e84D, 1e85D, 1e86D, 1e87D, 1e88D, 1e89D, 1e90D, 1e91D,
        1e92D, 1e93D, 1e94D, 1e95D, 1e96D, 1e97D, 1e98D, 1e99D, 1e100D, 1e101D,
        1e102D, 1e103D, 1e104D, 1e105D, 1e106D, 1e107D, 1e108D, 1e109D, 1e110D,
        1e111D, 1e112D, 1e113D, 1e114D, 1e115D, 1e116D, 1e117D, 1e118D, 1e119D,
        1e120D, 1e121D, 1e122D, 1e123D, 1e124D, 1e125D, 1e126D, 1e127D, 1e128D,
        1e129D, 1e130D, 1e131D, 1e132D, 1e133D, 1e134D, 1e135D, 1e136D, 1e137D,
        1e138D, 1e139D, 1e140D, 1e141D, 1e142D, 1e143D, 1e144D, 1e145D, 1e146D,
        1e147D, 1e148D, 1e149D, 1e150D, 1e151D, 1e152D, 1e153D, 1e154D, 1e155D,
        1e156D, 1e157D, 1e158D, 1e159D, 1e160D, 1e161D, 1e162D, 1e163D, 1e164D,
        1e165D, 1e166D, 1e167D, 1e168D, 1e169D, 1e170D, 1e171D, 1e172D, 1e173D,
        1e174D, 1e175D, 1e176D, 1e177D, 1e178D, 1e179D, 1e180D, 1e181D, 1e182D,
        1e183D, 1e184D, 1e185D, 1e186D, 1e187D, 1e188D, 1e189D, 1e190D, 1e191D,
        1e192D, 1e193D, 1e194D, 1e195D, 1e196D, 1e197D, 1e198D, 1e199D, 1e200D,
        1e201D, 1e202D, 1e203D, 1e204D, 1e205D, 1e206D, 1e207D, 1e208D, 1e209D,
        1e210D, 1e211D, 1e212D, 1e213D, 1e214D, 1e215D, 1e216D, 1e217D, 1e218D,
        1e219D, 1e220D, 1e221D, 1e222D, 1e223D, 1e224D, 1e225D, 1e226D, 1e227D,
        1e228D, 1e229D, 1e230D, 1e231D, 1e232D, 1e233D, 1e234D, 1e235D, 1e236D,
        1e237D, 1e238D, 1e239D, 1e240D, 1e241D, 1e242D, 1e243D, 1e244D, 1e245D,
        1e246D, 1e247D, 1e248D, 1e249D, 1e250D, 1e251D, 1e252D, 1e253D, 1e254D,
        1e255D, 1e256D, 1e257D, 1e258D, 1e259D, 1e260D, 1e261D, 1e262D, 1e263D,
        1e264D, 1e265D, 1e266D, 1e267D, 1e268D, 1e269D, 1e270D, 1e271D, 1e272D,
        1e273D, 1e274D, 1e275D, 1e276D, 1e277D, 1e278D, 1e279D, 1e280D, 1e281D,
        1e282D, 1e283D, 1e284D, 1e285D, 1e286D, 1e287D, 1e288D, 1e289D, 1e290D,
        1e291D, 1e292D, 1e293D, 1e294D, 1e295D, 1e296D, 1e297D, 1e298D, 1e299D,
        1e300D, 1e301D, 1e302D, 1e303D, 1e304D, 1e305D, 1e306D, 1e307D, 1e308D};

    /**
     * Appends the string representation of the
     * double argument to the string buffer.
     *
     * @param s the StringBuffer to append the object to.
     * @param num the double to be appended.
     * @see StringBuffer#append(double)
     */
    public static void append(final StringBuffer s, final double num) {
    	double d = num;
        if (d == Double.NEGATIVE_INFINITY) {
			s.append(NEGATIVE_INFINITY);
		} else if (d == Double.POSITIVE_INFINITY) {
			s.append(POSITIVE_INFINITY);
		} else if (d == 0.0) {
            if ((Double.doubleToLongBits(d) & DOUBLE_SIGN_MASK) != 0) {
				s.append('-');
			}
            s.append(DOUBLE_ZERO);
        } else {
            if (d < 0) {
                s.append('-');
                d = -d;
            }
            
            final int numNegative305 = -305; 
            final int num17  = 17;
            final int num323 = 323;
            final int num324 = 324;
            final double numPoint001  = 0.001;
            final double numPoint01   = 0.01;
            final double numPoint1    = 0.1;
            final double num1E11 = 1E11;
            final double num1E12 = 1E12;
            final double num1E13 = 1E13;
            final double num1E14 = 1E14;
            final double num1E15 = 1E15;
            final double num1E16 = 1E16;
            final double num1E17 = 1E17;
            final double num1E18 = 1E18;
            final double num1E19 = 1E19;
            final double num1E20 = 1E20;
            
            if (d >= numPoint001 && d < numPoint01) {
                long i = (long) (d * num1E20);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO2);
                appendFractDigits(s, i, -1);
            } else if (d >= numPoint01 && d < numPoint1) {
                long i = (long) (d * num1E19);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO);
                appendFractDigits(s, i, -1);
            } else if (d >= numPoint1 && d < 1) {
                long i = (long) (d * num1E18);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO0);
                appendFractDigits(s, i, -1);
            } else if (d >= 1 && d < INT_10) {
                long i = (long) (d * num1E17);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, 1);
            } else if (d >= INT_10 && d < INT_100) {
                long i = (long) (d * num1E16);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_2);
            } else if (d >= INT_100 && d < INT_1000) {
                long i = (long) (d * num1E15);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_3);
            } else if (d >= INT_1000 && d < INT_10000) {
                long i = (long) (d * num1E14);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_4);
            } else if (d >= INT_10000 && d < INT_100000) {
                long i = (long) (d * num1E13);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_5);
            } else if (d >= INT_100000 && d < INT_1000000) {
                long i = (long) (d * num1E12);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_6);
            } else if (d >= INT_1000000 && d < INT_10000000) {
                long i = (long) (d * num1E11);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_7);
            } else {
                int magnitude = magnitude(d);
                long i;
                if (magnitude < numNegative305) {
					i = (long) (d * num1E18 / D_MAGNITUDES[magnitude + num324]);
				} else {
					i = (long) (d / D_MAGNITUDES[magnitude + num323 - num17]);
				}
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, 1);
                s.append('E');
                append(s, magnitude);
            }
        }
    }
    /**
     * Appends the string representation of the
     * float argument to the string buffer.
     *
     * @param s the StringBuffer to append the object to.
     * @param num the float to be appended.
     * @see StringBuffer#append(float)
     */
    public static void append(final StringBuffer s, final float num) {
    	float d = num;
        if (d == Float.NEGATIVE_INFINITY) {
			s.append(NEGATIVE_INFINITY);
		} else if (d == Float.POSITIVE_INFINITY) {
			s.append(POSITIVE_INFINITY);
		} else if (d == 0.0) {
            if ((Float.floatToIntBits(d) & FLOAT_SIGN_MASK) != 0) {
				s.append('-');
			}
            s.append(DOUBLE_ZERO);
        } else {
            if (d < 0) {
                s.append('-');
                d = -d;
            }
            
            final int numNegative35 = -35;
            final float numPoint001F  = 0.001F;
            final float numPoint01F   = 0.01F;
            final float numPoint1F    = 0.1F;
            final float num1F         = 1F;
            final float num10F        = 10F;
            final float num100F       = 100F;
            final float num1000F      = 1000F;
            final float num10000F     = 10000F;
            final float num100000F    = 100000F;
            final float num1000000F   = 1000000F;
            final float num10000000F  = 10000000F;
            final float num1E3F  = 1E3F;
            final float num1E4F  = 1E4F;
            final float num1E5F  = 1E5F;
            final float num1E6F  = 1E6F;
            final float num1E7F  = 1E7F;
            final float num1E8F  = 1E8F;
            final float num1E9F  = 1E9F;
            final float num1E10F = 1E10F;
            final float num1E11F = 1E11F;
            final float num1E12F = 1E12F;
            
            if (d >= numPoint001F && d < numPoint01F) {
                long i = (long) (d * num1E12F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO2);
                appendFractDigits(s, i, -1);
            } else if (d >= numPoint01F && d < numPoint1F) {
                long i = (long) (d * num1E11F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO);
                appendFractDigits(s, i, -1);
            } else if (d >= numPoint1F && d < num1F) {
                long i = (long) (d * num1E10F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                s.append(DOUBLE_ZERO0);
                appendFractDigits(s, i, -1);
            } else if (d >= num1F && d < num10F) {
                long i = (long) (d * num1E9F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, 1);
            } else if (d >= num10F && d < num100F) {
                long i = (long) (d * num1E8F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_2);
            } else if (d >= num100F && d < num1000F) {
                long i = (long) (d * num1E7F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_3);
            } else if (d >= num1000F && d < num10000F) {
                long i = (long) (d * num1E6F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_4);
            } else if (d >= num10000F && d < num100000F) {
                long i = (long) (d * num1E5F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_5);
            } else if (d >= num100000F && d < num1000000F) {
                long i = (long) (d * num1E4F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_6);
            } else if (d >= num1000000F && d < num10000000F) {
                long i = (long) (d * num1E3F);
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, INT_7);
            } else {
                int magnitude = magnitude(d);
                long i;
                if (magnitude < numNegative35) {
					i = (long) (d * num1E10F / F_MAGNITUDES[magnitude + INT_45]);
				} else {
					i = (long) (d / F_MAGNITUDES[magnitude + INT_44 - INT_9]);
				}
                i = i % INT_100 >= INT_50 ? (i / INT_100) + 1 : i / INT_100;
                appendFractDigits(s, i, 1);
                s.append('E');
                append(s, magnitude);
            }
        }
    }
    /**
     * Appends the string representation of the
     * long argument to the string buffer.
     *
     * @param s the StringBuffer to append the object to.
     * @param l the long to be appended.
     * @see StringBuffer#append(long)
     */
    public static void append(final StringBuffer s, final long l) {
    	long i = l;
        if (i < 0) {
            if (i == Long.MIN_VALUE) {
                //cannot make this positive due to integer overflow
                s.append("-9223372036854775808");
                return;
            }
            s.append('-');
            i = -i;
        }
        long mag = magnitude(i);
        long c;
        while (mag > 1) {
            c = i / mag;
            s.append(CHAR_FOR_DIGIT[(int) c]);
            c *= mag;
            if (c <= i) {
				i -= c;
			}
            mag /= INT_10;
        }
        s.append(CHAR_FOR_DIGIT[(int) i]);
    }

    /**
     * Append StringBuffer with int.
     * @param s StringBuffer to append
     * @param num Int to append
     */
    public static void append(final StringBuffer s, final int num) {
    	int i = num;
        if (i < 0) {
            if (i == Integer.MIN_VALUE) {
                //cannot make this positive due to integer overflow
                s.append("-2147483648");
                return;
            }
            s.append('-');
            i = -i;
        }
        //int mag;
        int c;
        if (i < INT_10) {
            //one digit
            s.append(CHAR_FOR_DIGIT[i]);
            return;
        } else if (i < INT_100) {
            //two digits
            s.append(CHAR_FOR_DIGIT[i / INT_10]);
            s.append(CHAR_FOR_DIGIT[i % INT_10]);
            return;
        } else if (i < INT_1000) {
            //three digits
            s.append(CHAR_FOR_DIGIT[i / INT_100]);
            c = i % INT_100; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_10000) {
            //four digits
            s.append(CHAR_FOR_DIGIT[i / INT_1000]);
            c = i % INT_1000; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_100000) {
            //five digits
            s.append(CHAR_FOR_DIGIT[i / INT_10000]);
            c = i % INT_10000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_1000000) {
            //six digits
            s.append(CHAR_FOR_DIGIT[i / INT_100000]);
            c = i % INT_100000; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000]);
            c %= INT_10000; 
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_10000000) {
            //seven digits
            s.append(CHAR_FOR_DIGIT[i / INT_1000000]);
            c = i % INT_1000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100000]);
            c %= INT_100000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000]);
            c %= INT_10000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_100000000) {
            //eight digits
            s.append(CHAR_FOR_DIGIT[i / INT_10000000]);
            c = i % INT_10000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000000]);
            c %= INT_1000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100000]);
            c %= INT_100000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000]);
            c %= INT_10000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else if (i < INT_1000000000) {
            //nine digits
            s.append(CHAR_FOR_DIGIT[i / INT_100000000]);
            c = i % INT_100000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000000]);
            c %= INT_10000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000000]);
            c %= INT_1000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100000]);
            c %= INT_100000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000]);
            c %= INT_10000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        } else {
            //ten digits
            s.append(CHAR_FOR_DIGIT[i / INT_1000000000]);
            c = i % INT_1000000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100000000]);
            c %= INT_100000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000000]);
            c %= INT_10000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000000]);
            c %= INT_1000000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100000]);
            c %= INT_100000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10000]);
            c %= INT_10000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_1000]);
            c %= INT_1000;
            s.append(CHAR_FOR_DIGIT[(c) / INT_100]);
            c %= INT_100;
            s.append(CHAR_FOR_DIGIT[(c) / INT_10]);
            s.append(CHAR_FOR_DIGIT[c % INT_10]);
            return;
        }
    }

    /**
     * Append a StringBuffer with a byte.
     * @param s StringBuffer to append
     * @param b byte to append
     */
    private static void append(final StringBuffer s, final byte b) {
    	s.append(STRING_FOR_BYTE[(((int) b) + NUM_128)]);
    }

    //private static void append(StringBuffer s, char c) {
    //    s.append(c);
    //}

    //private static void append(StringBuffer s, char[] c) {
    //    s.append(c);
    //}

    //private static void append(StringBuffer s, String st) {
    //    s.append(st);
    //}

    //private static int magnitude_i(int i) {
    //    if (i < 10) return 1;
    //    else if (i < 100) return 10;
    //    else if (i < 1000) return 100;
    //    else if (i < 10000) return 1000;
    //    else if (i < 100000) return 10000;
    //    else if (i < 1000000) return 100000;
    //    else if (i < 10000000) return 1000000;
    //    else if (i < 100000000) return 10000000;
    //    else if (i < 1000000000) return 100000000;
    //    else return  1000000000;
    //}

    /** Multi-dimensional arrays of zeros.
     */
    public static final char[][] ZEROS = {
        {},
        {'0'},
        {'0', '0'},
        {'0', '0', '0'},
        {'0', '0', '0', '0'},
        {'0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
    };

    /**
     * Append fract digits.
     * @param s StringBuffer
     * @param l Long
     * @param offset Offset
     */
    private static void appendFractDigits(final StringBuffer s, final long l, final int offset) {
        long mag = magnitude(l);
        long c;
        long i = l;
        int decimalOffset = offset;
        
        while (i > 0) {
            c = i / mag;
            s.append(CHAR_FOR_DIGIT[(int) c]);
            decimalOffset--;
            if (decimalOffset == 0) {
				s.append('.');
			}
            c *= mag;
            if (c <= i) {
				i -= c;
			}
            mag = mag / INT_10;
        }
        if (i != 0) {
			s.append(CHAR_FOR_DIGIT[(int) i]);
		} else if (decimalOffset > 0) {
            s.append(ZEROS[decimalOffset]);
            decimalOffset = 1;
        }

        decimalOffset--;
        if (decimalOffset == 0) {
			s.append(DOT_ZERO);
		} else if (decimalOffset == -1) {
			s.append('0');
		}
    }

    /**
     * This method will convert an input to the RFC 2616 Section 3.3.1.  The date is a standard format for transmitting dates over
     * HTTP.  According to the specification the date must always be converted to GMT.  For a full explanation of the date format, see
     * RFC 2616.
     *  
     * @param date Input date to be converted.
     * @return String formatted according to RFC 2616
     */
    
    public static String convertToRFC2616Time(Date date) {
    	Calendar gmtCalendar = Calendar.getInstance(new SimpleTimeZone(0, "GMT"));
    	rfc2616DateFormat.setCalendar(gmtCalendar);
		return rfc2616DateFormat.format(date);
    }
    
    /**
     * Returns the magnitude in base 10.
     * @param d Positive double value whose magnitude is to be found
     * @return The magnitude of double value
     */
    protected static int magnitude(final double d) {
        return magnitude(d, Double.doubleToLongBits(d));
    }

    /**
     * Returns the magnitude in base 10.
     * @param d Positive double value whose magnitude is to be found
     * @param doubleToLongBits Double to Long bits
     * @return The magnitude of double value
     */
    protected static int magnitude(final double d, final long doubleToLongBits) {
    	
    	final double numPoint301029995663981 = 0.301029995663981;
    	
    	final int num308 = 308;
    	final int num309 = 309;
    	final int num323 = 323;
    	final int numNegative323 = -323;
    	final int numNegative324 = -324;
    	
        int magnitude =
                (int) ((((doubleToLongBits & DOUBLE_EXP_MASK) >> DOUBLE_EXP_SHIFT)
                        - DOUBLE_EXP_BIAS) * numPoint301029995663981);

        if (magnitude < -numNegative323) {
			magnitude = -numNegative323;
		} else if (magnitude > num308) {
			magnitude = num308;
		}

        if (d >= D_MAGNITUDES[magnitude + num323]) {
            while (magnitude < num309 && d >= D_MAGNITUDES[magnitude + num323]) {
				magnitude++;
			}
            magnitude--;
            return magnitude;
        } else {
            while (magnitude > numNegative324 && d < D_MAGNITUDES[magnitude + num323]) {
				magnitude--;
			}
            return magnitude;
        }
    }
    
    /**
     * Returns the magnitude in base 10.
     * @param d Positive float value whose magnitude is to be found
     * @return The magnitude of float value
     */
    protected static int magnitude(final float d) {
        return magnitude(d, Float.floatToIntBits(d));
    }

    /**
     * Returns the magnitude in base 10.
     * @param d Positive float value whose magnitude is to be found
     * @param floatToIntBits Float to Int bits
     * @return The magnitude of float value
     */
    protected static int magnitude(final float d, final int floatToIntBits) {
    	
    	final double numPoint301029995663981 = 0.301029995663981;
    	final int num38 = 38;
    	final int num39 = 39;
    	final int num44 = 44;
    	final int numNegative44 = -44;
    	final int numNegative45 = -45;
    	
        int magnitude =
                (int) ((((floatToIntBits & FLOAT_EXP_MASK) >> FLOAT_EXP_SHIFT)
                         - FLOAT_EXP_BIAS) * numPoint301029995663981);

        if (magnitude < numNegative44) {
			magnitude = numNegative44;
		} else if (magnitude > num38) {
			magnitude = num38;
		}

        if (d >= F_MAGNITUDES[magnitude + num44]) {
            while (magnitude < num39 && d >= F_MAGNITUDES[magnitude + num44]) {
				magnitude++;
			}
            magnitude--;
            return magnitude;
        } else {
            while (magnitude > numNegative45 && d < F_MAGNITUDES[magnitude + num44]) {
				magnitude--;
			}
            return magnitude;
        }
    }

    /**
     * Assumes i is positive. Returns the magnitude of i in base 10.
     *
     * @param i Positive long value whose magnitude is to be found
     * @return the magnitude of i
     */
    protected static long magnitude(final long i) {
    	final long num10L                  = 10L;
    	final long num100L                 = 100L;
    	final long num1000L                = 1000L;
    	final long num10000L               = 10000L;
    	final long num100000L              = 100000L;
    	final long num1000000L             = 1000000L;
    	final long num10000000L            = 10000000L;
    	final long num100000000L           = 100000000L;
    	final long num1000000000L          = 1000000000L;
    	final long num10000000000L         = 10000000000L;
    	final long num100000000000L        = 100000000000L;
    	final long num1000000000000L       = 1000000000000L;
    	final long num10000000000000L      = 10000000000000L;
    	final long num100000000000000L     = 100000000000000L;
    	final long num1000000000000000L    = 1000000000000000L;
    	final long num10000000000000000L   = 10000000000000000L;
    	final long num100000000000000000L  = 100000000000000000L;
    	final long num1000000000000000000L = 1000000000000000000L;
    	
        if (i < num10L) {
			return 1;
		} else if (i < num100L) {
			return num10L;
		} else if (i < num1000L) {
			return num100L;
		} else if (i < num10000L) {
			return num1000L;
		} else if (i < num100000L) {
			return num10000L;
		} else if (i < num1000000L) {
			return num100000L;
		} else if (i < num10000000L) {
			return num1000000L;
		} else if (i < num100000000L) {
			return num10000000L;
		} else if (i < num1000000000L) {
			return num100000000L;
		} else if (i < num10000000000L) {
			return num1000000000L;
		} else if (i < num100000000000L) {
			return num10000000000L;
		} else if (i < num1000000000000L) {
			return num100000000000L;
		} else if (i < num10000000000000L) {
			return num1000000000000L;
		} else if (i < num100000000000000L) {
			return num10000000000000L;
		} else if (i < num1000000000000000L) {
			return num100000000000000L;
		} else if (i < num10000000000000000L) {
			return num1000000000000000L;
		} else if (i < num100000000000000000L) {
			return num10000000000000000L;
		} else if (i < num1000000000000000000L) {
			return num100000000000000000L;
		} else {
			return  num1000000000000000000L;
		}
    }

    ///**
    // * Assumes i is positive. Returns the magnitude of i in base 16.
    // *
    // * @param i Positive long value whose magnitude is to be found
    // * @return the magnitude of i in base 16
    // */
    //private static long magnitude16(long i) {
    //    if (i < 16L) return 1;
    //    else if (i < 256L) return 16L;
    //    else if (i < 4096L) return 256L;
    //    else if (i < 65536L) return 4096L;
    //    else if (i < 1048576L) return 65536L;
    //    else if (i < 16777216L) return 1048576L;
    //    else if (i < 268435456L) return 16777216L;
    //    else if (i < 4294967296L) return 268435456L;
    //    else if (i < 68719476736L) return 4294967296L;
    //    else if (i < 1099511627776L) return 68719476736L;
    //    else if (i < 17592186044416L) return 1099511627776L;
    //    else if (i < 281474976710656L) return 17592186044416L;
    //    else if (i < 4503599627370496L) return 281474976710656L;
    //    else if (i < 72057594037927936L) return 4503599627370496L;
    //    else if (i < 1152921504606846976L) return 72057594037927936L;
    //    else return 1152921504606846976L;
    //}

//    /**
//     * Test cases. Worth running as
//     * <pre>
//     * java -verbosegc -ms4000000 jacks.basics.Appender
//     * </pre>
//     * to see the effects of object creation vs. optimized conversions.
//     * <p>
//     * If run this way, note that a garbage collection is run immediately before
//     * and after each test, so you see exactly which tests create how many
//     * objects. Garbage collections run during a test are due to the test itself
//     * creating so many objects that the vm has to reclaim space. Because each
//     * test starts with the default empty string buffer, each test will have a
//     * large amount of memory to be garbage collected from just a few objects -
//     * these are the char arrays inside the StringBuffers being copied over as
//     * they expand. What is interesting to note is the difference in objects and
//     * space reclaimed between the Appender test and the StringBuffer test.
//     *
//     * @param args java.lang.String[]
//     */
//    public static void main(String args[]) {
//        long time1, time2;
//        double[] ds = {Double.MAX_VALUE, -3.14e-200D, Double.NEGATIVE_INFINITY,
//            100, 567.89023D, 123e199D, -0.000456D, -1.234D, 1e55D, 99999};
//        float[] fs = {-3.14F, Float.POSITIVE_INFINITY, 99999, 100,
//            567.89023F, 123e33F, -0.000456F, -1.23456789e-2F, 1e-12F,
//            Float.MIN_VALUE};
//        long[] ls = {2283911683699007717L, -8007630872066909262L,
//            4536503365853551745L, 548519563869L, 45L, Long.MAX_VALUE, 1L,
//            -9999L, 7661314123L, 0L};
//        int[] is = {1147173962, 828789888, -337681747, 940436254, -20385232,
//            83, -1154302556, 1975989662, -515020324, Integer.MIN_VALUE};
//        char[] cs = {'a', '*', 12345, 9999, Character.MAX_VALUE};
//        short[] ss = {Short.MIN_VALUE, (short) 34567, (short) 23,
//                      (short) -5555, (short) 256};
//        byte[] bs = {Byte.MIN_VALUE, (byte) 99, (byte) 23, (byte) -100,
//                    (byte) -11};
//
//        int repeat = 1000;
//
//        for (int i=0;i<100;i++) {
//
//        main_adj(repeat*50,"ints",is,
//                 "1147173962, 828789888, -337681747, 940436254, -20385232,"+
//                 " 83, -1154302556, 1975989662, -515020324, Integer.MIN_VALUE");
//        main_adj(repeat*5,"floats",fs,
//                 "-3.14F, Float.POSITIVE_INFINITY, 567.89023F, 123e33F,"+
//                 "-0.000456F, -1.23456789e-2F, 1e-12F, Float.MIN_VALUE");
//        main_adj(repeat*5,"doubles",ds,
//                 "Double.MAX_VALUE, -3.14e-200D, Double.NEGATIVE_INFINITY,"+
//                 "	567.89023D, 123e199D, -0.000456D, -1.234D, 1e55D");
//        main_adj(repeat*5,"longs",ls,
//                 "2283911683699007717L, -8007630872066909262L, "+
//                 "4536503365853551745L, 548519563869L, 45L, Long.MAX_VALUE,"+
//                 " 1L, -9999L, 7661314123L, 0L");
//        main_adj(repeat*500,"chars",cs,
//                 "'a', '*', 12345, 9999, Character.MAX_VALUE");
//        main_adj(repeat*50,"shorts",ss,
//                 "Short.MIN_VALUE, 34567, 23, -5555, 256");
//        main_adj(repeat*50,"bytes",bs,
//                 "Byte.MIN_VALUE, 99, 23, -100, 245");
//        }
//
//    }

//    private static void main_adj(int repeat,String name,byte[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer "+
//                           "& Appender output of one iteration is "+
//                           "(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,char[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer"
//                           +" & Appender output of one iteration is "
//                           +"(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,double[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer "
//                           +"& Appender output of one iteration is "
//                           +"(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,float[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer "
//                           +"& Appender output of one iteration is "
//                           +"(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,int[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer "
//                           +"& Appender output of one iteration is "
//                           +"(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,long[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer & "
//                           +"Appender output of one iteration is "
//                           +"(respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
//
//    private static void main_adj(int repeat,String name,short[] arr,
//                                 String list) {
//        long time1, time2;
//        StringBuffer s;
//
//        System.out.println("The " + name);
//        System.out.println("    " + list);
//        System.out.println("are appended to a StringBuffer one by one "
//                           + repeat + " times.");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time1 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                append(s,arr[j]);
//        time1 = System.currentTimeMillis() - time1;
//        System.out.println("  The Appender     took " + time1
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("Starting test");
//        time2 = System.currentTimeMillis();
//        for (int i = repeat; i > 0; i--)
//            for (int j = arr.length-1; j >= 0; j--)
//                s.append(arr[j]);
//        time2 = System.currentTimeMillis() - time2;
//        System.out.println("  The StringBuffer took " + time2
//                           + " milliseconds");
//        s = new StringBuffer();
//        Runtime.getRuntime().gc();
//        System.out.println("    For checking purposes, the StringBuffer "
//                           +"& Appender output of one iteration is ("
//                           +"respectively):");
//        for (int j = 0; j < arr.length; j++)
//            s.append(arr[j]).append(", ");
//        System.out.println("    " + s);
//        s = new StringBuffer();
//        for (int j = 0; j < arr.length; j++) {
//            append(s,arr[j]);
//            append(s,", ");
//        }
//        System.out.println("    " + s);
//        System.out.println();
//    }
}
