/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.systemcfg.composer.impl;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.sql.DataSource;
import javax.xml.bind.MarshalException;

import net.sf.json.JSONArray;
import net.sf.json.JSONException;
import net.sf.json.JSONObject;

import org.apache.commons.io.IOUtils;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.deleidos.rtws.commons.config.RtwsConfig;
import com.deleidos.rtws.commons.dao.dimension.DimensionDao;
import com.deleidos.rtws.commons.dao.source.H2ConnectionPool;
import com.deleidos.rtws.commons.exception.DefaultConfigurationException;
import com.deleidos.rtws.commons.exception.InitializationException;
import com.deleidos.rtws.commons.jersey.config.JerseyClientConfig;
import com.deleidos.rtws.commons.model.dimension.DimensionColumn;
import com.deleidos.rtws.commons.model.dimension.DimensionTable;
import com.deleidos.rtws.commons.repository.tools.ConnectionConfig;
import com.deleidos.rtws.commons.util.repository.DataModelZipFile;
import com.deleidos.rtws.core.framework.parser.CanonicalFormat;
import com.deleidos.rtws.core.framework.parser.CanonicalFormat.DataTypes;
import com.deleidos.rtws.systemcfg.bean.ComposerStatus;
import com.deleidos.rtws.systemcfg.bean.DataSink;
import com.deleidos.rtws.systemcfg.bean.Pair;
import com.deleidos.rtws.systemcfg.bean.SystemContext;
import com.deleidos.rtws.systemcfg.bean.Transport;
import com.deleidos.rtws.systemcfg.composer.DefinitionComposer;
import com.deleidos.rtws.systemcfg.exception.ComposerException;
import com.deleidos.rtws.systemcfg.parser.XMLParser;
import com.deleidos.rtws.systemcfg.serialize.DefinitionSerializer;
import com.deleidos.rtws.systemcfg.userinput.bean.SystemConfig;
import com.deleidos.rtws.systemcfg.util.RtwsProperties;
import com.deleidos.rtws.systemcfg.util.SystemBuilderUtil;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;

public class DataModelDefinitionComposer implements DefinitionComposer{

	private static final Logger logger = LogManager.getLogger(DataModelDefinitionComposer.class);
	private RtwsProperties properties;
	/** The Jersey REST client */
	private Client client;
	private JSONArray parsersJson;
	private JSONArray processorsJson;
	private DefinitionSerializer serializer;
	private String outDir;
	private final String confDir = "/ingest/";
	private XMLParser parser;
	private ConnectionConfig connectionConfig;
	private String tenantId;
	private final String pipelineEnrichmentBeanType = "java:com.deleidos.rtws.core.beans.XMLInstantiationProxy";
	private String enrichmentFileNameTemplate = "pipeline.enrichment.?.xml";
	private String keyedDimensionFileNameTemplate = "dimension.?.xml";
	private String enrichmentProxyType = "com.deleidos.rtws.core.framework.ProcessingPipeline";
	private List<String> currentTables = null;
	private final String [] REPO_SEARCH_ORDER = {"private", "public", "common"};
	private CanonicalFormat canonicalFormat;
	private String tenantGWUrl = null;
	
	@Override
	public void initialize() throws InitializationException {
		
		this.client = Client.create(JerseyClientConfig.getInstance().getInternalConfig());
		
		this.serializer.initialize();
		
		String templateFile = null;
		String baseDir = (String) RtwsConfig.getInstance().getConfiguration().getProperty("sysbuilder.template.basedir");
		
		//initialize template file locations
		//template file property sets, for lookup in composer later
		templateFile = String.format("%s/%s", baseDir, "default.properties");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.service.default.properties", templateFile);
		
		templateFile = String.format("%s/%s", baseDir, "parsers-template.xml");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.parsers.template", templateFile);
		
		templateFile = String.format("%s/%s", baseDir, "script-engine-template.xml");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.script.engine.template", templateFile);
		
		templateFile = String.format("%s/%s", baseDir, "pipeline-enrichment-template.xml");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.pipeline.enrichment.template", templateFile);
		
		templateFile = String.format("%s/%s", baseDir, "pipeline-enrichment-model-template.xml");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.pipeline.enrichment.model.template", templateFile);
		
		templateFile = String.format("%s/%s", baseDir, "dimension-model-template.xml");
		RtwsConfig.getInstance().getConfiguration().setProperty("sysbuilder.keyed.dimension.template", templateFile);
	}

	@Override
	public void dispose() {
		//not implemented
	}

	@Override
	public void writeFile(String version, String fileName) {
		//not implemented
	}

	/**
	 * Load default configuration from Ingest API.
	 */
	@Override
	public void loadDefaults(String version, SystemConfig config, SystemContext systemContex, RtwsProperties properties) 
												throws MarshalException, DefaultConfigurationException {
		try{
			this.properties = properties;  //initialize properties
			this.outDir = config.getOutputConfDir() + confDir;
			SystemBuilderUtil.mkdir(this.outDir);  //create directory
			//load ingest api json information
			ingestApiParsers();
			ingestApiProcessors();
			
			//load repo connection config
			this.connectionConfig = new ConnectionConfig();
			this.connectionConfig.setPassword(RtwsConfig.getInstance().getString("webapp.repository.tenant.password"));
			this.connectionConfig.setRepositoryUrl(RtwsConfig.getInstance().getString("webapp.repository.url.path"));
			
			//generate tenant GW url
			tenantGWUrl = String.format("%s://%s:%s/dbapi", this.properties.getProperty("rtws.internal.webapp.scheme"), 
												this.properties.getProperty("tenant.gateway.host"),
												this.properties.getProperty("rtws.internal.webapp.port"));
		}
		catch(Exception e){
			logger.error(e.toString(), e);
			e.printStackTrace();
			throw new DefaultConfigurationException(e.toString(), e);
		}
	}

	/**
	 * Generate DataModel configuration.
	 */
	@Override
	public ComposerStatus compose(SystemConfig config, SystemContext systemContext) throws ComposerException {
		ComposerStatus status = ComposerStatus.done;
		
		if (config.getDataModels().size() < 1)
			return status;
		
		try{
			//generate enrichment files for each data model
			currentTables = new ArrayList<String>();  //keyed enrichment table names
			validateDataModelsVsTransport(config, systemContext);
			generateParsers(config);
			generateBaseEnrichment(config);
			generateModelEnrichment(config, systemContext);
			generateKeyedDimensionEnrichment(config);
			
			if (config.getApplianceEnabled()) {
				processModelsForApplianceUse(config);
			}
			currentTables = null;  //reset
		}
		catch(ComposerException ce){
			status = ComposerStatus.error;
			throw ce;
		}
		catch(Exception e){
			logger.error(e.toString(), e);
			e.printStackTrace();
			status = ComposerStatus.error;
			throw new ComposerException(e.toString(), e);
		}
		
		return status;
	}

	private void validateDataModelsVsTransport(SystemConfig config, SystemContext systemContext) throws ComposerException {

		List<String> dataSources = new ArrayList<String>();
		
		// check all data models
		for(String dmName : config.getDataModels()){

			try {
				InputStream isZip = getZipFileFromRepo(dmName);  //get zip file from repo
				if(isZip != null){
					DataModelZipFile zipFile = null;
					try{
						zipFile = new DataModelZipFile(isZip);
					}
					finally{
						try{
							isZip.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					InputStream isDS = null;
					JSONArray dsList = null;
					
					try {
						// get datasources from data model
						isDS = zipFile.getDataSourceParams();
						dsList = JSONArray.fromObject(IOUtils.toString(isDS));
					}
					finally {
						try {
							isDS.close();
						} catch (Exception e) {
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					Iterator<?> dsItr = dsList.iterator();
					
					// get all of the data model data sources
					while (dsItr.hasNext()) {						
						JSONObject dataSource = (JSONObject) dsItr.next();
						String dataSourceName = (String) dataSource.get("name");
						dataSources.add(dataSourceName);				
					}
				}
			} catch(Exception e){
				logger.error(e.toString(), e);
				e.printStackTrace();
				throw new ComposerException(e.toString(), e);
			}
			finally{
				
			}
		}
		
		List<Transport> transports = config.getTransports();
		
		for (Transport transport : transports) {
			
			List<Pair> pairs = transport.getParams();
			
			for (Pair pair : pairs) {
				if (pair.getName().contentEquals("input-format")) {
					String transportDataSource = pair.getValue();
					
					if (!dataSources.contains(transportDataSource)) {
						throw new ComposerException("Data Model does not contain the data source: " + transportDataSource);
					}
					break; // don't need to check the rest of xport values
				}
			}					
		}
	
	}

	/**
	 * Get generated properties.
	 */
	@Override
	public Properties getProperties() {
		return properties;
	}
	
	/**
	 * Set the Definition Serializer used for marshalling data.
	 * 
	 * @param serializer {@link DefinitionSerializer}
	 */
	public void setDefinitionSerializer(DefinitionSerializer serializer){
		this.serializer = serializer;
	}
	
	/**
	 * Sets the XML parser used by the composer.
	 * @param parser
	 */
	public void setXMLParser(XMLParser parser){
		this.parser = parser;
	}
	
	/**
	 * Set the tenant id.
	 * 
	 * @param tenantId String value
	 */
	public void setTenantId(String tenantId){
		this.tenantId = tenantId;
	}
	
	/**
	 * Get Parsers information from Ingest API.
	 * 
	 * @throws MalformedURLException
	 * @throws ComposerException 
	 */
	private void ingestApiParsers() throws MalformedURLException, ComposerException{
		String url = String.format("%s/json/service/parsers/%s", RtwsConfig.getInstance().getString("sys.builder.ingest.api"),
											this.tenantId);
		WebResource resource = this.client.resource(url);
		
		ClientResponse clientResponse = resource.get(ClientResponse.class);
		if(clientResponse.getStatus() == 503){
			throw new ComposerException("IngestAPI is currently syncing/updating its cache, try again later.");
		}
		
		String response = clientResponse.getEntity(String.class);
		
		logger.debug(resource.getURI().toURL().toString());
		this.parsersJson = JSONArray.fromObject(response);
	}
	
	/**
	 * Get Processors information from Ingest API.
	 * @throws ComposerException 
	 */
	private void ingestApiProcessors() throws ComposerException{
		String url = String.format("%s/json/service/processors/%s", RtwsConfig.getInstance().getString("sys.builder.ingest.api"),
										this.tenantId);
		WebResource resource = this.client.resource(url);
		
		ClientResponse clientResponse = resource.get(ClientResponse.class);
		if(clientResponse.getStatus() == 503){
			throw new ComposerException("IngestAPI is currently syncing/updating its cache, try again later.");
		}
		
		String response = clientResponse.getEntity(String.class);
		
		this.processorsJson = JSONArray.fromObject(response);
	}
	
	private void processModelsForApplianceUse(SystemConfig config) throws Exception {
		
		File modelsDir = new File(outDir + "/models");
		if (!modelsDir.exists()) {
			if (!modelsDir.mkdir())
				throw new Exception(modelsDir.getAbsolutePath() + " creation failed.");
		}

		//for each data model in user config, download them for use by appliance creation process
		for(String dmName : config.getDataModels()){
			InputStream isZip = getZipFileFromRepo(dmName);  //get zip file from repo
			if(isZip != null){
				FileOutputStream outFile = null;

				try{
					outFile = new FileOutputStream(modelsDir + "/" + dmName );
					IOUtils.copyLarge(isZip, outFile);
					logger.info(String.format("Wrote: {%s}",dmName));
				}
				finally{
					try{
						isZip.close();
						outFile.close();
					}
					catch(Exception e){
						logger.warn(e.toString(), e);
						throw new ComposerException(e.toString(), e);
					}
				}

			}
		}
	}
	
	/**
	 * Create parsers.xml file.
	 * 
	 * @param config {@link SystemConfig}
	 * @throws Exception
	 */
	private void generateParsers(SystemConfig config) throws Exception{
		String parsersTemplate = RtwsConfig.getInstance().getString("sysbuilder.parsers.template");  //get template file name
		
		this.parser.readXmlFile(parsersTemplate);  //parser root element from template file
		
		//for each data model in user config
		for(String dmName : config.getDataModels()){
			InputStream isZip = getZipFileFromRepo(dmName);  //get zip file from repo
				if(isZip != null){
					DataModelZipFile zipFile = null;
					
					try{
						zipFile = new DataModelZipFile(isZip);
					}
					finally{
						try{
							isZip.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					InputStream isDS = null;
					JSONArray dataSourceParams = null;
					try{
						//get parameters for parsers
						isDS = zipFile.getDataSourceParams();
						dataSourceParams = JSONArray.fromObject(IOUtils.toString(isDS));
					}
					finally{
						try{
							isDS.close();	
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					//for each parser in zip file, check if in user data model parser list
					Iterator<?> nodeit = dataSourceParams.iterator();
					while (nodeit.hasNext()) {
						JSONObject parser = (JSONObject) nodeit.next();
						
						JSONObject ingestParser = getParser((String) parser.get("parser"));
						//if parser in api and user model
						if(ingestParser != null){
							Element entry = this.parser.createElement("entries");  //element to add to root
							
							//set name
							Element name = this.parser.createElement("name");
							name.setTextContent(parser.getString("name"));
							entry.appendChild(name);
							
							//create bean
							Element bean = this.parser.createElement("bean");
							bean.setAttribute("xsi:type", "java:" + ingestParser.getString("fqn"));
							
							//add parameters
							JSONArray paramList = parser.getJSONArray("parserParams");
							
							for(int i = 0; i < paramList.size(); i++){
								JSONObject tmp = paramList.getJSONObject(i);
								
								Element element = this.parser.createElement(tmp.getString("name"));
								element.setTextContent(tmp.getString("value"));
								bean.appendChild(element);
							}
							
							//create translator
							Element translator = this.parser.createElement("translator");
							translator.setAttribute("xsi:type", "java:com.deleidos.rtws.ext.parser.SimpleConfigurableTranslator");
							
							//create modelName to add to translator
							Element modelName = this.parser.createElement("model-name");
							modelName.setTextContent(getModelName(dmName));
							translator.appendChild(modelName);
							
							//create modelVersion to add to translator
							Element modelVersion = this.parser.createElement("model-version");
							modelVersion.setTextContent(getModelVersion(dmName));
							translator.appendChild(modelVersion);
							
							//create inputFormatName to add to translator
							Element inputFormatName = this.parser.createElement("input-format-name");
							inputFormatName.setTextContent(parser.getString("name"));
							translator.appendChild(inputFormatName);
							
							
							translator = this.parser.importNode(addScriptEngine(), true, translator);  //import to template root
							
					
							bean.appendChild(translator);
							entry.appendChild(bean);
							
							this.parser.addElement("factory-definition", entry);  //add entry to root element	
						}
					}
				}//end if
				else{
					logger.info(String.format("Zip file %s not found in repository.", dmName));
					System.out.println(String.format("Zip File %s not found in repository.", dmName));
				}
			}
		
		this.parser.writeXmlFile(outDir + "parsers.xml");  //ouput generated file
		
	}
		
	/**
	 * Get model name from zip file name.
	 * 
	 * @param zipName String filename 
	 * @return String value
	 */
	private String getModelName(String zipName){
		//ex:  transportation_v1.0.zip, so model name is first char to _
		
		int index = zipName.lastIndexOf("_");
	    //match found
	    if(index != -1){
	    	return zipName.substring(0, index);
	    }
	    else{
	    	return "";
	    }
	}
	
	/**
	 * Get model version from zip file name.
	 * 
	 * @param zipName String filename
	 * @return String value
	 */
	private String getModelVersion(String zipName){
		//ex:  transportation_v1.0.zip, so model version is _ to .zip
		Pattern pattern = Pattern.compile("_v[0-9]+\\.[0-9]+\\.zip$"); 
		  
	    Matcher matcher = pattern.matcher(zipName);  
	   
	    if(matcher.find()){
		    int start = matcher.start();  
	        int end = matcher.end();  
	        return zipName.substring(start + 2, end - 4);  
	    }
	    else{
	    	return "";
	    }   	
	}
	
	/**
	 * Get parser JSONObject from JSONArray parsers list.
	 * 
	 * @param parserName String parserName
	 * @return {@link JSONObject}
	 */
	private JSONObject getParser(String parserName){
		JSONObject json = null;
		
		Iterator<?> nodeit = parsersJson.iterator();
		while (nodeit.hasNext()) {
			JSONObject tmp = (JSONObject) nodeit.next();
			
			if(((String) tmp.get("fqn")).contains(parserName)){
				json = tmp;
			}
		}
		
		return json;
	}
	
	/**
	 * Get nonkeyed-dimension processors from processors list.
	 * 
	 * @param name String value processors name
	 * @return {@link JSONObject} processor
	 */
	private JSONObject getProcessor(String name){
		JSONObject json = null;
		
		Iterator<?> nodeItr = processorsJson.iterator();
		while(nodeItr.hasNext()){
			JSONObject tmp = (JSONObject) nodeItr.next();
			
			String type = tmp.getJSONObject("enrichmentDefinition").getJSONArray("type").getString(0);
			
			//if(name.equals(type) && !name.equals("dimension_table") && !name.equals("dimension_table_with_update")){
			if(name.equals(type)){
				json = tmp;
			}
		}
		
		return json;
	}
	
	/**
	 * Create Script Engine document element from template.
	 * 
	 * @return {@link Element}
	 * @throws ComposerException 
	 * @throws Exception 
	 */
	private Element addScriptEngine() throws ComposerException{
		InputStream is = null;
		Element element = null;
		try{
			String template = RtwsConfig.getInstance().getString("sysbuilder.script.engine.template");
			
			//read in services template file
			BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(template)));
			StringBuilder sb = new StringBuilder("");  //services xml template
	
			String line = null;
			while((line = br.readLine()) != null){
				sb.append(line);
			}
			br.close();
			
			XMLParser tmpParser = new XMLParser(true);  //create parser
			
			//recursively replace properties in transport template
			is = new ByteArrayInputStream(properties.filterProperty(sb.toString()).getBytes());
			tmpParser.readXmlFileFromStream(is);  //parse template to document
			
			element = tmpParser.getElement("script-engine-factory");
		}
		catch(Exception e){
			logger.error(e.toString(), e);
			throw new ComposerException(e.toString(), e);
		}
		finally{
			try {
				is.close();
			} catch (IOException ioe) {
				logger.error(ioe.toString(), ioe);
			}
		}
		
		return element;
	}

	/**
	 * Download model zip file from repository to memory.
	 * 
	 * @param zipFile String filename
	 * @return {@link InputStream}
	 * @throws ComposerException 
	 * @throws Exception 
	 */
	private InputStream getZipFileFromRepo(String zipFile) throws ComposerException{
		InputStream is = null;
		
		for(int i = 0; i < REPO_SEARCH_ORDER.length; i++){
		
			WebResource resource = null;
			if(!REPO_SEARCH_ORDER[i].equals("common")){
				resource = this.client.resource(this.connectionConfig.getRetrieveContentUrl());
				resource = resource
						.path(zipFile)
						.path(REPO_SEARCH_ORDER[i])  //change to private later when models are added
						.path("models")
						.queryParam("userId", this.tenantId)
						.queryParam("password", this.connectionConfig.getPassword());
			}
			else{
				resource = this.client.resource(this.connectionConfig.getCommonContentUrl());
				resource = resource
						.path(zipFile)
						.path("models")
						.queryParam("userId", this.tenantId);
			}
			logger.debug(resource.getURI().toString());
			
			try {
			   	logger.info("Downloading file " + zipFile);
			   	
			   	//is = resource.get(InputStream.class);
			   	ClientResponse client = resource.get(ClientResponse.class);
			   	
			   	//no error condition on repository location lookup for DM, try next location
			   	if(client.getClientResponseStatus().getStatusCode() != 204 && client.getClientResponseStatus().getStatusCode() < 300){
			   		logger.info(String.format("DataModel %s retrieved from location:  %s" , zipFile, REPO_SEARCH_ORDER[i]));
			   		is = client.getEntityInputStream();
			   		break;
			   	}
			   	else{
			   		logger.debug("Response code returned from repository:  " + client.getClientResponseStatus().getStatusCode());
			   	}
			} catch (Exception ex) {
				logger.error(ex.toString(), ex);
				throw new ComposerException(ex.toString(), ex);
			}
		}
		
		return is;
	}
	
	/**
	 * Generate base enrichment configuration file.
	 * 
	 * @param config {@link SystemConfig}
	 * @throws ComposerException
	 */
	private void generateBaseEnrichment(SystemConfig config) throws ComposerException{
		InputStream is = null;
		try{
			this.parser = new XMLParser(true);
			
			String template = RtwsConfig.getInstance().getString("sysbuilder.pipeline.enrichment.template");
			
			//read in services template file
			BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(template)));
			StringBuilder sb = new StringBuilder("");  //services xml template
	
			String line = null;
			while((line = br.readLine()) != null){
				sb.append(line);
			}
			br.close();
			
			//recursively replace properties in pipeline enrichment tempalte
			is = new ByteArrayInputStream(properties.filterProperty(sb.toString()).getBytes());
			this.parser.readXmlFileFromStream(is);  //parse template to document
			
			//for each data model in user config
			for(String dmName : config.getDataModels()){
				
				//add entries element to factory-definition for each data model in the user configuration
				Element entry = this.parser.createElement("entries");  //element to add to root
				
				String modelName = getModelName(dmName);  //model name
				
				//set name
				Element name = this.parser.createElement("name");
				name.setTextContent(modelName);
				entry.appendChild(name);
				
				//create bean
				Element bean = this.parser.createElement("bean");
				bean.setAttribute("xsi:type", pipelineEnrichmentBeanType);
				
				Element definitionFile = this.parser.createElement("definition-file");
				definitionFile.setTextContent(enrichmentFileNameTemplate.replace("?", modelName));
				bean.appendChild(definitionFile);
				
				Element proxyType = this.parser.createElement("proxy-type");
				proxyType.setTextContent(enrichmentProxyType);
				bean.appendChild(proxyType);
				
				entry.appendChild(bean);
				
				this.parser.addElement("factory-definition", entry);
			}
			
			this.parser.writeXmlFile(outDir + "pipeline.enrichment.xml");
		}
		catch(Exception e){
			logger.error(e.toString(), e);
			e.printStackTrace();
			throw new ComposerException(e.toString(), e);
		}
		finally{
			try {
				is.close();
			} catch (IOException e) {
				logger.error(e.toString(), e);
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Generate DataModel configuration pipeline enrichment file.
	 * 
	 * @param config {@link SystemConfig}
	 * @throws ComposerException
	 */
	private void generateModelEnrichment(SystemConfig config, SystemContext systemContext) throws ComposerException{
		InputStream is = null;
		
		try{
			for(String dmName : config.getDataModels()){
				this.parser = new XMLParser(true);
				String modelName = getModelName(dmName);
				
				String template = RtwsConfig.getInstance().getString("sysbuilder.pipeline.enrichment.model.template");
				
				//read in services template file
				BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(template)));
				StringBuilder sb = new StringBuilder("");  //services xml template
		
				String line = null;
				while((line = br.readLine()) != null){
					line = line.replace("model_name", modelName);  //update keyed dimension template
					sb.append(line);
				}
				br.close();
				
				//recursively replace properties in pipeline enrichment model template
				is = new ByteArrayInputStream(properties.filterProperty(sb.toString()).getBytes());
				this.parser.readXmlFileFromStream(is);  //parse template to document
				is.close();  //clean up
				
				InputStream isZip = getZipFileFromRepo(dmName);  //get zip file from repo
				if(isZip != null){
					DataModelZipFile zipFile = null;
					try{
						zipFile = new DataModelZipFile(isZip);
					}
					finally{
						try{
							isZip.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					InputStream isDS = null;
					JSONArray enrichCfgList = null;
					try{
						//get parameters for parsers
						isDS = zipFile.getEnrichmentConfig();
						enrichCfgList = JSONArray.fromObject(IOUtils.toString(isDS));
					}
					finally{
						try{
							isDS.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					Iterator<?> cfgItr = enrichCfgList.iterator();
					while(cfgItr.hasNext()){
						JSONObject enrichCfg = (JSONObject) cfgItr.next();
						String enrichName = (String) enrichCfg.get("enrichName");
						
						JSONObject processor = getProcessor(enrichName);
						
						//if the enrichcfg type is found in the api processor list and not keyed dimension
						if(processor != null){
							String type = String.format("java:%s", processor.getString("fqn"));
							if("dimension_table".equals(enrichName) || "dimension_table_with_update".equals(enrichName) || "fuzzy_dimension_table".equals(enrichName)){
								NodeList list = this.parser.getElementList("processors");
								int dimFileIndex = list.getLength();
								boolean foundProcessor = false;
								
								//check if last processor in list is a dimension processor
								if(list.getLength() > 0){
									Node node = list.item(list.getLength()-1);
									//if it is a dimension processor then add the new dimension processor to the existing one,
									//collapses adjacent dimension processor into one processor
									String nodeType = ((Element) node).getAttribute("xsi:type");
									logger.debug("Found other processors.  last processor was of type "+nodeType);
									if(type.equals(nodeType)){
										logger.debug("Last processor is same type as this processor.  Collapsing processors.");
										foundProcessor = true;
										NodeList models = ((Element) node).getElementsByTagName("models");
										
										if(models.getLength() > 0){
											Element model = (Element) models.item(0);
											Element fields = createFieldsElement(enrichCfg, type, true);
											
											model.appendChild(fields);
										}
									}else if(nodeType.equalsIgnoreCase("java:com.deleidos.rtws.ext.processor.KeyedDimensionLookup")
											|| nodeType.equalsIgnoreCase("java:com.deleidos.rtws.ext.processor.FuzzyKeyedDimension")
											|| nodeType.equalsIgnoreCase("java:com.leidos.plugin.fuzzy.fuzzyKeyedDimension.FuzzyKeyedDimension")){
										//if the type is NOT the same, but still in the set of dimension enrichments, we want to 
										//decrement the number of the file that contains the dimension information so we get the right thing.
										dimFileIndex--;
										logger.debug("Las processor not same type as this processor, but still a dimension processor.  Reducing index of dimension file to "+dimFileIndex);
										
										while(dimFileIndex>0){
											//there might be another one before...
											//for example: dim,fuzzy,dim - the second dim would see the 
											//fuzzy and decrement once, even though the correct index is 0
											String previousType = ((Element)list.item(dimFileIndex-1)).getAttribute("xsi:type");
											logger.debug("found additional processors.  Next processor of type "+previousType);
											if(previousType.equalsIgnoreCase("java:com.deleidos.rtws.ext.processor.KeyedDimensionLookup")
													|| previousType.equalsIgnoreCase("java:com.deleidos.rtws.ext.processor.FuzzyKeyedDimension")
													|| previousType.equalsIgnoreCase("java:com.leidos.plugin.fuzzy.fuzzyKeyedDimension.FuzzyKeyedDimension")){
												dimFileIndex--;                  
												logger.debug("processor was of dimension type.  Reducing dim index to "+dimFileIndex);
											}else{
												logger.debug("last found processor not of dimension type.  Leaving dimensional processing loop with dim index of "+dimFileIndex);
												break;
											}
										}
									}
								}
								
								//create new processor for keyed enrichment
								if(foundProcessor == false){
									Element processors = this.parser.createElement("processors");
									processors.setAttribute("xsi:type", "java:" + processor.getString("fqn"));
									
									Element name = this.parser.createElement("name");
									name.setTextContent(enrichName);
									processors.appendChild(name);
									
									Element dimensionTableCache = this.parser.createElement("dimension-table-cache-factory");
									dimensionTableCache.setAttribute("xsi:type", "java:com.deleidos.rtws.core.cache.DimensionTableCacheFactory");
									
									Element definitionFile = this.parser.createElement("definition-file");
									definitionFile.setTextContent(keyedDimensionFileNameTemplate.replace("?", String.format("%s.%s", modelName, dimFileIndex)));
									dimensionTableCache.appendChild(definitionFile);
									processors.appendChild(dimensionTableCache);
									
									//add input parameters to processor
									JSONObject inputParams = processor.getJSONObject("inputParameters");
									createInputElement(inputParams, enrichCfg, processors, dmName, type);
									
									//add system parameters to processor
									JSONObject systemParams = processor.getJSONObject("systemParameters");
									createInputElement(systemParams, enrichCfg, processors, dmName, type);
									
									this.parser.addElement("pipeline-definition", processors);
								}
								
							}
							else{
								Element processors = this.parser.createElement("processors");
								processors.setAttribute("xsi:type", "java:" + processor.getString("fqn"));
								
								Element name = this.parser.createElement("name");
								name.setTextContent(enrichName);
								processors.appendChild(name);
								
								//add input parameters to processor
								JSONObject inputParams = processor.getJSONObject("inputParameters");
								createInputElement(inputParams, enrichCfg, processors, dmName, type);
								
								//add system parameters to processor
								JSONObject systemParams = processor.getJSONObject("systemParameters");
								createInputElement(systemParams, enrichCfg, processors, dmName, type);
								
								this.parser.addElement("pipeline-definition", processors);
							}
						}
						else{
							throw new ComposerException(String.format("DataModel %s has an enrichment processor defined that can not be found:  %s", dmName, enrichName));
						}
					}//end while
				}//end if
				
				Element sink = this.parser.getElement("sink");
				
				if (systemContext.getSystemSize() != null && systemContext.getSystemSize().getJmsInstanceCount() > 1) {
					// jms instance count > 1, configure all sinks to send to the router
					// the router is responsible for sending messages out to all the various queueus
					Element queue = this.parser.createElement("queues");
					queue.setTextContent(this.properties.getProperty("messaging.queue.router.name"));
					sink.appendChild(queue);
				} else {
					//add queues to JMS storage sink for each data model that requested it
					for(DataSink dataSink : config.getDataSinks()){
						List<String> dataSinkModels = dataSink.getDataModels();
						if (dataSinkModels == null || dataSinkModelsContainModel(dataSinkModels, modelName) ) {
							Element queue = this.parser.createElement("queues");
							queue.setTextContent(SystemBuilderUtil.generateDataModelQueueName(dataSink.getFqn()));
							
							sink.appendChild(queue);
						}
					}
				}
				
				this.parser.addElement("pipeline-definition", sink);  //readd the sink node
				
				this.parser.writeXmlFile(outDir + enrichmentFileNameTemplate.replace("?", modelName));
			}
		}
		catch(Exception e){
			e.printStackTrace();
			logger.error(e.toString(), e);
			throw new ComposerException(e.toString(), e);
		}
		finally{
			try {
				is.close();
			} catch (IOException e) {
				logger.error(e.toString(), e);
				e.printStackTrace();
			}
		}
	}
	
	private boolean dataSinkModelsContainModel(List<String> dataSinkModels, String modelName) {
		for(String dataSinkModel : dataSinkModels) {
			if(dataSinkModel.contains(modelName)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * 
	 * @param otherParams
	 * @param fields
	 * @return
	 */
	private Element addPropertiesToFields(String otherParams, Element fields){	
		String [] params = otherParams.split("(?<!\\\\),");  //split on nonescaped ,
			
		if(params != null){
			if(otherParams.length() > 0){
				for(int i = 0; i < params.length; i++){
					String param = params[i].replaceAll("\\\\,", ",");  //undo encoding of ,
					Element properties = this.parser.createElement("properties");
					
					//split string by getting substring around first occurrence of =, ex. [name]=[x=3*y;]
					Element name = this.parser.createElement("name");
					name.setTextContent(param.substring(0, param.indexOf("=")).trim());
					properties.appendChild(name);
					
					Element value = this.parser.createElement("value");
					value.setTextContent(param.substring(param.indexOf("=") + 1).trim());
					properties.appendChild(value);
					
					fields.appendChild(properties);
				}
			}
		}	
		
		return fields;
		
	}
	
	/**
	 * create input/system parameters Document element for pipeline enrichment configuration file.
	 * 
	 * @param parameters {@link JSONObject} parameters configuration
	 * @param enrichCfg {@link JSONObject} enrichment configuration
	 * @param processor {@Element} element to append parameters 
	 * @param dmName String data model name
	 */
	private void createInputElement(JSONObject parameters, JSONObject enrichCfg, Element processor, String dmName, String type){
		Iterator<?> itr = parameters.keys();
		while(itr.hasNext()){
			String key = (String) itr.next();
			JSONObject param = (JSONObject) parameters.getJSONObject(key);
			
			if(param.getString("type").contains("com") || param.getString("type").contains("javax")){
				if(key.equals("enrichments")){
					Element enrichment = this.parser.createElement("enrichments");
					enrichment.setAttribute("xsi:type", "java:" + param.getString("type"));
					
					//add model by default, fill with parameters from enrichcfg
					Element models = this.parser.createElement("models");
					models.setAttribute("xsi:type", "java:com.deleidos.rtws.core.framework.processor.EnrichmentFieldMappingCache");
					
					Element modelName = this.parser.createElement("model-name");
					modelName.setTextContent(getModelName(dmName));
					models.appendChild(modelName);
					
					Element modelVersion = this.parser.createElement("model-version");
					modelVersion.setTextContent(getModelVersion(dmName));
					models.appendChild(modelVersion);
					
					Element fields = null;
					if(type.toLowerCase().contains("keyed")){
						fields = createFieldsElement(enrichCfg, type, true);
					}
					else{
						fields = createFieldsElement(enrichCfg, type, false);
					}
					
					models.appendChild(fields);
					enrichment.appendChild(models);
					processor.appendChild(enrichment);
				}
				else if(key.equals("data-source")){
					Element dataSource = this.parser.createElement("data-source");
					dataSource.setAttribute("xsi:type", param.getString("default"));
					
					Element resourceName = this.parser.createElement("resource-name");
					resourceName.setTextContent("oracle.datasource");
					dataSource.appendChild(resourceName);
					
					processor.appendChild(dataSource);
				}
				else{
					//unknown
				}
			}
			else{
				Element tmp = this.parser.createElement(key);
				tmp.setTextContent(param.getString("default"));
				processor.appendChild(tmp);
			}
		}
	}
	
	/**
	 * Create commons field element for processors.
	 * 
	 * @param enrichCfg {@link JSONObject}
	 * @param processorType String value
	 * @return {@link Element} fields element contained in models element
	 */
	private Element createFieldsElement(JSONObject enrichCfg, String processorType, boolean keyedEnrich){
		Element fields = this.parser.createElement("fields");
		fields.setAttribute("xsi:type", "java:com.deleidos.rtws.core.framework.processor.EnrichmentAction");
		
		//add encrich cfg parameters to field
		Element type = this.parser.createElement("type");
		type.setTextContent(enrichCfg.getString("enrichName"));
		fields.appendChild(type);
		
		String inputFields = enrichCfg.getString("inputFields");
		
		if(inputFields.contains(",")){
			String [] params = inputFields.split(",");
			for(int i = 0; i < params.length; i++){
				Element parameters = this.parser.createElement("parameters");
				parameters.setTextContent(params[i].trim());
				fields.appendChild(parameters);
			}
		}
		else{
			Element parameters = this.parser.createElement("parameters");
			parameters.setTextContent(enrichCfg.getString("inputFields"));
			fields.appendChild(parameters);
		}
		
		Element field = this.parser.createElement("field");
		field.setTextContent(enrichCfg.getString("outputField"));
		fields.appendChild(field);
		
		//convert to boolean
		Element remove = this.parser.createElement("remove-parameters");
		remove.setTextContent(enrichCfg.getString("removeInput"));
		fields.appendChild(remove);
		
		//convert to boolean
		Element override = this.parser.createElement("override");
		override.setTextContent(enrichCfg.getString("override"));
		fields.appendChild(override);
		
		Element extract = this.parser.createElement("extract-field");
		extract.setTextContent(enrichCfg.getString("extractPath"));
		fields.appendChild(extract);
		
		//output other params as properties elements with name/value pair, to each enrichment
		fields = addPropertiesToFields(enrichCfg.getString("otherParams"), fields);
		
		return fields;
	}
	
	/**
	 * Generate keyed dimension configration.
	 * 
	 * @param config {@link SystemConfig}
	 * @throws ComposerException
	 */
	private void generateKeyedDimensionEnrichment(SystemConfig config) throws ComposerException{
		
		try{
			//for each data model in user configuration //TODO
			for(String dmName : config.getDataModels()){
				currentTables = null;  //reset the current list of dimension entry tables
				currentTables = new ArrayList<String>();
				boolean outputKeyedDimensionFile = false;
				
				//initialize dimension file
				String modelName = getModelName(dmName);
				initializeKeyedDimensionTemplate(dmName);
				
				List<Object> connection = getDimensionTableUrl(this.tenantId);  //how to set later, move to load defaults if it will not change
				//List<Object> connection = getDimensionTableUrl("aws-dev");  //how to set later, move to load defaults if it will not change
				
				DataSource ds = (DataSource) connection.get(0);
				Long connectionId = (Long) connection.get(1);
				String describePath = (String) connection.get(2);
				
				
				InputStream isZip = getZipFileFromRepo(dmName);  //get zip file from repo
				if(isZip != null){
					DataModelZipFile zipFile = null;
					try{
						zipFile = new DataModelZipFile(isZip);
					}
					finally{
						try{
							isZip.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					//get canonical format from datamodel
					this.canonicalFormat = new CanonicalFormat(zipFile.getCanonicalModel());
					
					InputStream isDS = null;
					JSONArray enrichCfgList = null;
					try{
						//get parameters for parsers
						isDS = zipFile.getEnrichmentConfig();
						enrichCfgList = JSONArray.fromObject(IOUtils.toString(isDS));
					}
					finally{
						try{
							isDS.close();
						}
						catch(Exception e){
							logger.warn(e.toString(), e);
							throw new ComposerException(e.toString(), e);
						}
					}
					
					Iterator<?> cfgItr = enrichCfgList.iterator();
					int processorOrder = -1;
					while(cfgItr.hasNext()){
						JSONObject enrichCfg = (JSONObject) cfgItr.next();
						String enrichName = (String) enrichCfg.get("enrichName");
						
						if("dimension_table".equals(enrichName) || "dimension_table_with_update".equals(enrichName) || "fuzzy_dimension_table".equals(enrichName)){
							if(outputKeyedDimensionFile == false){
								processorOrder++;  //update processor order count if not first processor
							}
							outputKeyedDimensionFile = true;
							generateKeyedDimensionEnrichment(enrichName, ds, connectionId, enrichCfg, describePath);
						}
						else{
							//output only if a processor is of type dimension_table
							if(outputKeyedDimensionFile == true){
								outputKeyedDimensionFile = false;
								this.parser.writeXmlFile(outDir + keyedDimensionFileNameTemplate.replace("?", String.format("%s.%s", modelName, processorOrder)));  //write dimension xml file
								initializeKeyedDimensionTemplate(dmName);  //initialize new dimension xml file
							}
							processorOrder++;  //update processor order count 
						}
					}
					
					//output only if a processor is of type dimension_table
					if(outputKeyedDimensionFile == true){
						this.parser.writeXmlFile(outDir + keyedDimensionFileNameTemplate.replace("?", String.format("%s.%s", modelName, processorOrder)));
					}
				}
			}
		}
		catch(Exception e){
			logger.error(e.toString(), e);
			e.printStackTrace();
			throw new ComposerException(e.toString(), e);
		}
		finally{
			
		}
	}
	
	/**
	 * Get dimension table information from Tenant API.  Builds URL to Dimension table in database.  Creates dimension table
	 * datasource.
	 * 
	 * @param tenantId String value
	 * @return List<Object> 
	 * @throws MalformedURLException
	 */
	private List<Object> getDimensionTableUrl(String tenantId) throws MalformedURLException{
		String url = String.format("%s%s%s", RtwsConfig.getInstance().getString("webapp.tenantapi.url.path"),
				"/json/dimensions/connections?tenantId=", tenantId);
		WebResource resource = this.client.resource(url);
		String response = resource.get(String.class);
		
		logger.debug(resource.getURI().toURL().toString());
		
		JSONArray connections = JSONArray.fromObject(response);  //possible to have more then on connection to DB source
		JSONObject dimension = connections.getJSONObject(0);  //only one connection in list as of current
		
		//jdbc:h2:tcp://ec2-23-21-178-223.compute-1.amazonaws.com:8161/commondb;SCHEMA_SEARCH_PATH=APPLICATION
		String dbURL = RtwsConfig.getInstance().getString("h2.app.connection.url");
		
		logger.debug("Created DB URL from dimension connection table:  " + dbURL);
		
		H2ConnectionPool h2Ds = new H2ConnectionPool();
		h2Ds.setURL(dbURL);
		h2Ds.setUser(RtwsConfig.getInstance().getConfiguration().getString("h2.app.connection.user"));
		h2Ds.setPassword(RtwsConfig.getInstance().getConfiguration().getString("h2.app.connection.password"));
		
		List<Object> results = new ArrayList<Object>();
		results.add(h2Ds);
		results.add(new Long(dimension.getLong("id")));
		results.add(String.format("%s:%s/DIMENSIONS/", dimension.getString("host"), dimension.getString("port")));
		
		return results;
	}	
	
	/**
	 * Generate keyed dimension enrichment configuration mapping between Dimension Table columns and JSON object.
	 * 
	 * @param enrichName String enrichment name
	 * @param ds DataSource for Dimension Tables
	 * @param connectionId a long connection id to reference tenant id
	 * @param enrichCfg {@link JSONObject} enrichment configuration
	 * @param describePath String DB API for the describe table URL
	 * @throws ComposerException
	 * @throws MalformedURLException
	 */
	private void generateKeyedDimensionEnrichment(String enrichName, DataSource ds, Long connectionId, JSONObject enrichCfg, 
														String describePath) throws ComposerException, MalformedURLException{
		String otherParams = enrichCfg.getString("otherParams");
		
		String tableName = getTableName(otherParams);
		
		//only allow one enrichment table per table name, no identical entries for dimension tables
		if(currentTables.contains(tableName) == false){
			String inputFields = enrichCfg.getString("inputFields");  //used for enrichment parameter order
			
			DimensionDao dimensionDAO = new DimensionDao();
			dimensionDAO.setDataSource(ds);
			
			List<String> tmpList = new ArrayList<String>();
			tmpList.add(String.format("DIMENSIONS.%s", tableName));
				
			Collection<DimensionTable> dimensions = dimensionDAO.getConnectionDimensionTables(connectionId, tmpList);
			
			describePath = String.format("%s%s", describePath, tableName);
			
			//JSONArray describedTable = dbAPIDescribe(describePath);
			
			//for each dimensions table, add enrichment config
			for(DimensionTable dimension : dimensions){
				Element entries = this.parser.createElement("entries");
				
				Element name = this.parser.createElement("name");
				name.setTextContent(tableName);
				entries.appendChild(name);
				
				Element bean = this.parser.createElement("bean");
				bean.setAttribute("xsi:type", "java:com.deleidos.rtws.core.cache.DimensionTableCache");
				
				name = this.parser.createElement("name");
				name.setTextContent(tableName);
				bean.appendChild(name);
				
				Element size = this.parser.createElement("size");
				size.setTextContent(Long.toString(dimension.getDefaultCacheMaxRecords()));
				bean.appendChild(size);
				
				Element cacheLoader = this.parser.createElement("cache-loader");
				
				Element initPolicy = this.parser.createElement("init-policy");
				initPolicy.setTextContent(dimension.getDefaultCacheInitPolicy().name());
				cacheLoader.appendChild(initPolicy);
				
				Element missPolicy = this.parser.createElement("miss-policy");
				missPolicy.setTextContent(dimension.getMissPolicy().name());
				cacheLoader.appendChild(missPolicy);
				
				Element dao = this.parser.createElement("dao");
				dao.setAttribute("xsi:type", "java:com.deleidos.rtws.core.dao.sql.JsonDimensionTableDao");
				
				Element table = this.parser.createElement("table");
				table.setTextContent(tableName);
				dao.appendChild(table);
				
				if(dimension.getSurrogateKeySeqName() != null){
					Element sequence = this.parser.createElement("sequence");
					sequence.setTextContent(dimension.getSurrogateKeySeqName());
					dao.appendChild(sequence);
				}
				
				//add enrichment dimension parameters based on enrichcfg
				dao = generateEnrichmentParameters(inputFields, otherParams, describePath, dimension, dao);
				
				cacheLoader.appendChild(dao);
				bean.appendChild(cacheLoader);
				entries.appendChild(bean);
				this.parser.addElement("factory-definition", entries);
			}//end for
			
			currentTables.add(tableName);
		}
		else{
			currentTables.add(tableName);
		}
	}
	
	/**
	 * DB API call to describe service for database tables.
	 * 
	 * @param pathParameters {
	 * @return
	 * @throws MalformedURLException
	 */
	private JSONArray dbAPIDescribe(String pathParameters) throws ComposerException {
		try {
			String url = String.format("%s%s%s", tenantGWUrl,
					"/json/select/describeTable/", pathParameters);
			WebResource resource = this.client.resource(url);
			String response = resource.get(String.class);

			logger.debug(resource.getURI().toURL().toString());

			JSONObject columns = JSONObject.fromObject(response);


			return columns.getJSONArray("columns");
		}
		catch (MalformedURLException e) {
			throw new ComposerException("Cannot access tenant database", e);
		}
		catch (JSONException e) {
			throw new ComposerException("Unable to retrieve columns from table with path: " + pathParameters + " in tenant database", e);
		}
	}
	
	/**
	 * Get column data type.
	 * 
	 * @param tableDescribe {@link JSONArray} table column description
	 * @param column String column name
	 * @return String column name
	 */
	private String getColumnType(JSONArray tableDescribe, String column){
		String columnType = "";  //empty type value
		
		for(int i = 0; i < tableDescribe.size(); i++){
			//if row column name equals column name
			JSONObject columnDesc = tableDescribe.getJSONObject(i);
			if(columnDesc != null){
				if(column.equals(columnDesc.getString("COLUMN_NAME"))){
					columnType = columnDesc.getString("TYPE_NAME");
					break;
				}
			}
		}
		
		return columnType;
	}
	
	/**
	 * Get the table name from the enriched configuration other parameters list.
	 * 
	 * @param otherParams String value
	 * @return String table name
	 * @throws ComposerException
	 */
	private String getTableName(String otherParams) throws ComposerException{
		String tableName = null;
		
		String [] params = otherParams.split(",");
		
		for(int i = 0; i < params.length; i++){
			String [] values = params[i].trim().split("=");
			
			if("table".equals(values[0])){
				tableName = values[1];
			}
		}
		
		if(tableName == null){
			throw new ComposerException("A table name is not listed in the other parameters value, the enrichment configuration is incorrect");
		}
		
		return tableName;
	}
	
	/**
	 * Creates input parameter list from inputFields and otherFields using enrichment configuration, then creates the enrichment parameters.
	 * 
	 * @param inputFields String enrichment input values
	 * @param otherParams String other params values
	 * @param describePath String url for table describe
	 * @param dimension {@link DimensionTable}
	 * @param dao {@link Element} dao
	 * @return {@link Element} dao element for enrichment
	 * @throws MalformedURLException
	 * @throws ComposerException
	 */
	private Element generateEnrichmentParameters(String inputFields, String otherParams, String describePath, DimensionTable dimension, Element dao) throws MalformedURLException, ComposerException{
		ArrayList<String> inputParamPath = new ArrayList<String>();
		
		//add input fields/natural keys to possible values
		String [] tmp = inputFields.split(",");
		ArrayList<String> inputParamsList = new ArrayList<String>();
		for(int i = 0; i < tmp.length; i++){
			inputParamPath.add(tmp[i].trim());
			String [] tmpList  =tmp[i].trim().split("\\.");
			if(tmpList.length > 0){
				inputParamsList.add(tmpList[tmpList.length-1].trim());
			}
			else{
				inputParamsList.add(tmp[i].trim());
			}
		}
		
		//add any other value then table name
		ArrayList<String> otherParamsList = new ArrayList<String>();
		tmp = otherParams.split(",");
		String tableName = getTableName(otherParams);
		for(int i = 0; i < tmp.length; i++){
			String [] param = tmp[i].trim().split("=");
			if(param.length == 2){
				if(!param[1].trim().equals(tableName)){
					otherParamsList.add(param[1]);
				}
			}
		}
		
		//output enrichment parameters in specific order (ORDER DEPENDENT) enrichment will fail, if order does not match
		//data model zip enrich config parameter order, so enrich cfg JSON and dimension.DATAMODEL.xml parameter order must match for each 
		//keyed dimension, hopefully this is removed later on and the original iterate parameter and output is added back
		
		//add surrogate key, only one not listed in enrich cfg
		for(DimensionColumn column : dimension.getColumns()){
			if(column.getRole() != null){
				if("SURROGATE_KEY".equals(column.getRole().name())){
					dao = generateEnrichmentParameterElement(column.getMappingFieldName(), dimension, dao, describePath, null);
				}
			}
		}
		
		/*for(DimensionColumn column : dimension.getColumns()){
			if(column.getRole() != null){
				if("NATURAL_KEY".equals(column.getRole().name())){
					dao = generateEnrichmentParameterElement(column.getMappingFieldName(), dimension, dao, describePath);
				}
			}
		}*/
		
		List<String> otherFieldsAdded = new ArrayList<String>(inputParamsList.size() + otherParamsList.size());
		Iterator<String> pathItr = inputParamPath.iterator();
		//add input/NATURAL_KEY fields to enrichment 
		for(String paramName : inputParamsList){
			String path = null;
			if(pathItr.hasNext()){
				path = pathItr.next();
			}
			
			if(inputParamsList.size() == 1){
				for(DimensionColumn tmpColumn : dimension.getColumns()){
					if(tmpColumn.getRole() != null){
						if("NATURAL_KEY".equals(tmpColumn.getRole().name())){
							dao = generateEnrichmentParameterElement(tmpColumn.getMappingFieldName(), dimension, dao, describePath, path);
							otherFieldsAdded.add(tmpColumn.getMappingFieldName());
						}
					}
				}
			}
			else{
				dao = generateEnrichmentParameterElement(paramName, dimension, dao, describePath, path);
				otherFieldsAdded.add(paramName);
			}
		}
		/*
		//add other fields to enrichment 
		for(String paramName : otherParamsList){
			dao = generateEnrichmentParameterElement(paramName, dimension, dao, describePath, null);
			otherFieldsAdded.add(paramName);
		}
		*/
		//add surrogate key, only one not listed in enrich cfg
		for(DimensionColumn column : dimension.getColumns()){
			if(column.getRole() != null){
				if("DATA".equals(column.getRole().name()) && !otherFieldsAdded.contains(column.getMappingFieldName())){
					dao = generateEnrichmentParameterElement(column.getMappingFieldName(), dimension, dao, describePath, null);
				}
			}
		}
		
		return dao;
	}
	
	/**
	 * Add column parameter to enrichment for the given paramName value, only add if the enrichment config is the same name as the dimension JSON name, using
	 * equals ignore case to compare the name value.
	 * 
	 * @param paramName String enrichment field name
	 * @param dimension {@link DimensionTable}
	 * @param dao {@link Element} dao
	 * @param describePath String url for table describe
	 * @param inputPath canonical path for input field
	 * @return {@link Element} dao element for enrichment
	 * 
	 * @throws MalformedURLException
	 * @throws ComposerException
	 */
	public Element generateEnrichmentParameterElement(String paramName, DimensionTable dimension, Element dao, String describePath, String inputPath) throws MalformedURLException, ComposerException{
		boolean throwError = true;
		JSONArray describedTable = dbAPIDescribe(describePath);
		
		//for each enrichment field add mapping from table to json
		for(DimensionColumn column : dimension.getColumns()){
		
			if(column.getMappingFieldName().equalsIgnoreCase(paramName)){
				throwError = false;
				Element element = null;
				
				//null value not allowed currently possible in future
				if(column.getRole() == null){
					throw new ComposerException("Dimension column role type is null:  " + column.getName());
				}
				//data field or other
				else if("DATA".equals(column.getRole().name())){
					element = this.parser.createElement("other-fields");
				}
				else if("SURROGATE_KEY".equals(column.getRole().name())){
					element = this.parser.createElement("surrogate-key-field");
				}
				else if("NATURAL_KEY".equals(column.getRole().name())){
					element = this.parser.createElement("natural-key-fields");
				}
				//catch all for anything else
				else{
					throw new ComposerException("Unknown keyed enrichment column role type:  " + column.getRole());
				}
				
				//add column to field mapping
				Element nativeField = this.parser.createElement("native-field-name");
				nativeField.setTextContent(column.getMappingFieldName());
				element.appendChild(nativeField);
				
				Element nativeFieldType = this.parser.createElement("native-field-type");
				nativeFieldType.setTextContent(column.getMappingFieldType());
				element.appendChild(nativeFieldType);
				
				Element storedFieldName = this.parser.createElement("stored-field-name");
				storedFieldName.setTextContent(column.getName());
				element.appendChild(storedFieldName);
				
				Element storedFieldType = this.parser.createElement("stored-field-type");
				storedFieldType.setTextContent(getColumnType(describedTable, column.getName()));
				element.appendChild(storedFieldType);
				
				if(column.getDefaultValue() != null){
					Element defaultValue = this.parser.createElement("default-value");
					defaultValue.setTextContent(column.getDefaultValue());
					element.appendChild(defaultValue);
				}
				
				if(column.getFormatMask() != null){
					Element formatMask = this.parser.createElement("format-mask");
					formatMask.setTextContent(column.getFormatMask());
					element.appendChild(formatMask);
				}
				
				if(inputPath != null){
					String format = checkDateFormat(inputPath);
					if(format != null){
						Element inputFormatMask = this.parser.createElement("input-format-mask");
						inputFormatMask.setTextContent(format);
						element.appendChild(inputFormatMask);
					}
				}
			
				dao.appendChild(element);
				break;  //once found move on
			}
		}//end for
		
		//throw only if not found in dimension columns
		if(throwError == true){
			throw new ComposerException("Enrichment configuration inputField name does not match any dimension column names:  " + paramName);
		}
		
		return dao;
	}
	
	private String checkDateFormat(String inputPath){
		String format = null;
		
		DataTypes dataType = this.canonicalFormat.getDataType(inputPath);
		
		if(dataType == DataTypes.datestring){
			format = this.canonicalFormat.getParameterString(inputPath);
			return format;
		}
		else{
			return format;
		}
		
	}
	
	/**
	 * Initializes dimension xml file.
	 * 
	 * @param modelName
	 * @throws IOException
	 */
	private void initializeKeyedDimensionTemplate(String modelName) throws IOException{
		InputStream is = null;
		try{
			this.parser = new XMLParser(true);
		
			String template = RtwsConfig.getInstance().getString("sysbuilder.keyed.dimension.template");
			
			//read in services template file
			BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(template)));
			StringBuilder sb = new StringBuilder("");  //services xml template
	
			String line = null;
			while((line = br.readLine()) != null){
				sb.append(line);
			}
			br.close();
			
			//recursively replace properties in pipeline enrichment tempalte
			is = new ByteArrayInputStream(properties.filterProperty(sb.toString()).getBytes());
			this.parser.readXmlFileFromStream(is);  //parse template to document
		}finally{
			try {
				is.close();
			} catch (IOException e) {
				logger.warn(e.toString(), e);
			}
		}
	}
}
