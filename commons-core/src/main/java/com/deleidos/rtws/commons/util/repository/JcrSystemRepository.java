/**
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "{}"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright {yyyy} {name of copyright owner}
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.deleidos.rtws.commons.util.repository;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.jcr.Binary;
import javax.jcr.Node;
import javax.jcr.NodeIterator;
import javax.jcr.Repository;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.ValueFactory;
import javax.jcr.nodetype.NodeType;
import javax.jcr.security.AccessControlManager;
import javax.jcr.security.AccessControlPolicyIterator;
import javax.jcr.security.Privilege;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.apache.commons.lang.StringUtils;
import org.apache.jackrabbit.api.JackrabbitSession;
import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;
import org.apache.jackrabbit.api.security.user.Authorizable;
import org.apache.jackrabbit.api.security.user.User;
import org.apache.jackrabbit.api.security.user.UserManager;
import org.apache.jackrabbit.core.security.principal.EveryonePrincipal;

public class JcrSystemRepository extends AbstractSystemRepository {
	
	/**
	 * Stores the access control entry. The entry contains the
	 * principal (user/group), the privileges, and a flag
	 * indicating if the privileges are to be allowed or denied.
	 */
	public static class ACLEntry {
		
		public Principal principal;
		public String [] privileges;
		public boolean isAllow;

		public ACLEntry(Principal principal, String [] privileges, boolean isAllow) {
			this.principal = principal;
			this.privileges = privileges;
			this.isAllow = isAllow;
		}
		
	}
	
	private RepositoryCredentials credentials = null;
	private String username = null;
	private String password = null;

	/**
	 * Set the repository URL.
	 * @param url
	 */
	public void setRepositoryUrl(String url) {
		JcrSessionCache.get().setRepositoryURL(url);
	}
	
	/**
	 * Set the repository.
	 * @param repository
	 */
	public void setRepository(Repository repository) {
		JcrSessionCache.get().setRepository(repository);
	}

	/** Set username */
	public void setUsername(String username) {
		this.username = username;
	}
	
	/** Set password */
	public void setPassword(String password) {
		this.password = password;
	}

	/**
	 * Initialize access to the repository.
	 */
	public void initialize() {
		// If username and password are set, override the credentials
		if ((username != null) && (password != null)) {
			this.credentials = new RepositoryCredentials(username, password);
		}
		JcrSessionCache.get().initialize();
	}
	
	public void dispose() {
		// Nothing to do
	}

	/**
	 * Set the current access credentials.
	 */
	@Override
	public void setCredentials(RepositoryCredentials credentials) {
		
		this.credentials = credentials;
	}

	public boolean commonExists() {
		try {
			Node commonNode = getCommonNode();

			return (commonNode != null);
		}
		catch (RepositoryException e) {
			// fall through and return false;
		}

		return false;
	}

	public Node getCommonNode()
			throws RepositoryException {
		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {

			Node root = session.getRootNode(); // JCR root

			String commonPath = Common;
			Node commonNode = root.getNode(commonPath);
			if (commonNode == null) {
				throw new RepositoryException("Common content data path does not exist");
			}

			return commonNode;
		}
	}

	/**
	 * Creates the common content area.
	 */
	public void createCommonStructure(RepositoryCredentials credentials)
	{
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {

				Node root = session.getRootNode(); // JCR root

				// Ensure the common node is there
				if (!root.hasNode(Common)) {
					root.addNode(Common);
					session.save();
				}

				this.credentials = credentials;
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("createCommonStructure failed", e);
		}
	}

	/**
	 * Creates the user structures for a given user specified by the passed credentials.
	 */
	public void createUserStructures(RepositoryCredentials credentials, String userName)
	{
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				
				Node root = session.getRootNode(); // JCR root
				
				// Add user to each visibility node
				for (Visibility v : Visibility.values()) {
					// Ensure the visibility node is there first
					Node visNode = null;
					String visName = v.toString().toLowerCase();
					if (root.hasNode(visName)) {
						visNode = root.getNode(visName);
					}
					else {
						visNode = root.addNode(visName);
				        session.save();
					}					
					
					// Now add a user node under the visibility node

					if (!visNode.hasNode(userName)) {
						visNode.addNode(userName);
				        session.save();
					}
				}
						        
				this.credentials = credentials;
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("createUserStructures failed", e);
		}				
	}

	/**
	 * Creates the systems structures for a given domain specified by the passed credentials.
	 */
	public void createSystemDomainStructures(RepositoryCredentials credentials, String domainName)
	{
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {

				Node root = session.getRootNode(); // JCR root

				// Ensure the systems node is there first
				Node sysNode = null;
				if (root.hasNode(Systems)) {
					sysNode = root.getNode(Systems);
				}
				else {
					sysNode = root.addNode(Systems);
					session.save();

					// set ACL on the Systems node
					String [] allPrivilege = { Privilege.JCR_ALL };
					List<ACLEntry> aclEntries = new ArrayList<ACLEntry>();
					aclEntries.add(new ACLEntry(EveryonePrincipal.getInstance(), allPrivilege, true));
					setAccessControlPolicy(sysNode, aclEntries);
				}

				// Now add a domain node under the systems node
				if (!sysNode.hasNode(domainName)) {
					sysNode.addNode(domainName);
					session.save();
				}

				this.credentials = credentials;
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("createSystemDomainStructures failed", e);
		}
	}

	/**
	 * Removes all user data from the repository.
	 */
	public void deleteUserStructures(RepositoryCredentials credentials, String userName)
	{
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				
				Node root = session.getRootNode(); // JCR root
				
				// Delete user from each visibility node
				for (Visibility v : Visibility.values()) {
					String visName = v.toString().toLowerCase();
					if (root.hasNode(visName)) {
						Node visNode = root.getNode(visName);
						if (visNode.hasNode(userName)) {
							Node userNode = visNode.getNode(userName);
							userNode.remove();
						}
					}
				}
				
		        session.save();
		        
		        this.credentials = null;
			}
		}
		catch (RepositoryException e) {
			this.credentials = null;
			throw new SystemRepositoryException("deleteUserStructures failed", e);
		}		
	}
	
	/**
	 * Removes all system data from the repository for one domain.  If path is not null, then just remove
	 * the path node and all of its children.
	 */
	public void deleteSystemDomainStructures(RepositoryCredentials credentials, String domainName, String path)
	{
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {

				Node root = session.getRootNode(); // JCR root

				// Delete domain from systems node
				if (root.hasNode(Systems)) {
					Node sysNode = root.getNode(Systems);
					if (sysNode.hasNode(domainName)) {
						Node domainNode = sysNode.getNode(domainName);
						Node pathNode = domainNode;
						if (StringUtils.isNotBlank(path)) {
							pathNode = domainNode.getNode(path);
						}
						
						pathNode.remove();
					}
				}

				session.save();

		        credentials = null;
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("deleteSystemDomainStructures failed", e);
		}
	}
	
	public List<String> listElasticAddresses(RepositoryCredentials credentials, String domainName, String path) {
		ArrayList<String> persistentIpAddresses = new ArrayList<String>();

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {

				Node root = session.getRootNode(); // JCR root

				// Find the domain in the systems node
				if (root.hasNode(Systems)) {
					Node sysNode = root.getNode(Systems);
					if (sysNode.hasNode(domainName)) {
						Node domainNode = sysNode.getNode(domainName);
						Node pathNode = domainNode;
						if (StringUtils.isNotBlank(path)) {
							pathNode = domainNode.getNode(path);
						}
						
						persistentIpAddresses.addAll(listElasticAddresses(pathNode));
					}
				}
				
				session.save();

		        credentials = null;
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("retrieveElasticAddresses failed", e);
		}
		
		return persistentIpAddresses;
	}
	
	public List<String> listElasticAddresses(Node pathNode) {
		ArrayList<String> persistentIpAddresses = new ArrayList<String>();
		
		try {
			if(pathNode.getPath().endsWith("/userConfig.json")) {
				// Retrieve the config file
				InputStream is = retrieve(pathNode);
				
				// Parse the file contents for persistentIpAddresses
				if (is != null) {
					
					try {
						String userConfigJsonText = inputStream2String(is);
						JSONObject userConfig = JSONObject.fromObject(userConfigJsonText);
						
						JSONArray processGroups = userConfig.optJSONArray("processGroups");
						if(processGroups != null) {
							for(int i = 0; i < processGroups.size(); i++) {
								JSONObject processGroup = (JSONObject)processGroups.get(i);
								String persistentIPAddress = processGroup.getString("persistentIPAddress");
								if(!persistentIPAddress.equals("none")) {
									persistentIpAddresses.add(persistentIPAddress);
								}
							}
						}
					} catch (IOException doNothing) {
						// Failed to read contents of the InputStream into a String, there is nothing
						// to be done about this, carry on
					}
				}
			}
			else {
				if(pathNode.hasNodes()) {
					// This node has child nodes, inspect them
					try {
						NodeIterator nodeIt = pathNode.getNodes();
						
						while(nodeIt.hasNext()) {
							Node child = (Node)nodeIt.next();
							
							persistentIpAddresses.addAll(listElasticAddresses(child));
						}
						
					} catch (RepositoryException doNothing) {
						// Failed to get the node's children, there is nothing
						// to be done about this, carry on
					}
				}
			}
		}
		catch (RepositoryException e) {
			credentials = null;
			throw new SystemRepositoryException("retrieveElasticAddresses failed", e);
		}
		
		return persistentIpAddresses;
	}
	
	public boolean systemDomainExists(String domainName)
	{
		try {
			Node domainNode = getSystemDomainNode(domainName);

			return (domainNode != null);
		}
		catch (RepositoryException e) {
			// fall through and return false;
		}

		return false;
	}

	public Node getSystemDomainNode(String domainName) throws RepositoryException
	{
		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {

			Node root = session.getRootNode(); // JCR root

			String domainPath = Systems + "/" + domainName;
			Node domainNode = root.getNode(domainPath);
			if (domainNode == null) {
				throw new RepositoryException("System Domain data path " + domainName + " does not exist");
			}

			return domainNode;
		}
	}

	/**
	 * Returns an array of the JCR nodes for the current user, one for each level of visibility
	 * as defined in the enumeration Visibility
	 * @return an array of JCR nodes
	 */
	public Node[] getUsersNodes() {
		
		return getUsersNodes(credentials.getUsername());
		
	}
	
	/**
	 * Returns an array of the JCR nodes for the given user, one for each level of visibility
	 * as defined in the enumeration Visibility
	 * @return an array of JCR nodes
	 */
	public Node[] getUsersNodes(String userName) {
		
		Node[] result = null;
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				
				Node root = session.getRootNode(); // JCR root
		
				Visibility visibilities[] = Visibility.values();
				result = new Node[visibilities.length];
				for (Visibility v : visibilities) {
					String visName = v.toString().toLowerCase();
					String path = visName + "/" + userName;
					result[v.ordinal()] = root.getNode(path);
				}
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("getUsersNodes failed", e);
		}
		
		return result;
		
	}
	
	/**
	 * Set an access policy for a given node.
	 * 
	 * @param node The node to set the policy upon
	 * @param entries A list of access control entries to apply to a node
	 */
	public void setAccessControlPolicy(Node node, List<ACLEntry> entries) { 
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
	
			synchronized(session) {
				AccessControlManager acm = session.getAccessControlManager();
				AccessControlPolicyIterator it = acm.getApplicablePolicies(node.getPath());
			
				JackrabbitAccessControlList acl = null;
				while (it.hasNext() && acl == null) {
					acl = (JackrabbitAccessControlList) it.nextAccessControlPolicy();
				}
			
				for (ACLEntry entry : entries) {
					Privilege [] privileges = new Privilege[entry.privileges.length];
					
					for (int i = 0; i < entry.privileges.length; i++) {
						privileges[i] = acm.privilegeFromName(entry.privileges[i]);
					}
					
					acl.addEntry(entry.principal, privileges, entry.isAllow);
				}
	
				acm.setPolicy(node.getPath(), acl);
			
				session.save();
			}
		}
		catch (Exception e) {
			throw new SystemRepositoryException("setAccessControlPolicy failed", e);
		}
		
	}

	/**
	 * Creates a named path under the specified node.
	 * Path can have multiple nodes separated by a '/'
	 * ACLs are inherited from the parent node.
	 */
	public void createPath(Node node, String path) {
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				// File Set root - add it if it does not exist
				String [] directories = path.split("/");
				Node current = node;
				for (String dir : directories) {
					if (!current.hasNode(dir)) {
						current.addNode(dir);
					}
					current = current.getNode(dir);
				}
		        session.save();
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("createPath failed", e);
		}
	}

	/**
	 * Creates an named path for the user within the specified visibility zone.
	 */
	@Override
	public void createPath(Visibility visibility, String path) {
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node userNode = getUserNode(session, visibility);
				createPath(userNode, path);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("createPath failed", e);
		}
		
	}
	
	public void createCommonPath(String path) {

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node commonNode = getCommonNode();
				createPath(commonNode, path);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("createPath failed", e);
		}
	}

	@Override
	public void deletePath(Visibility visibility, String path) {
		
		if (path == null || path.trim().length() == 0) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				
				Node userNode = getUserNode(session, visibility);

				String [] directories = path.split("/");
				Node current = userNode;
				for (String dir : directories) {
					if (! current.hasNode(dir)) {
						throw new SystemRepositoryException("Path '" + path + "' does not exist.");
					}
					
					current = current.getNode(dir);
				}
				
				current.remove();
				
		        session.save();
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("deletePath failed", e);
		}

	}

	/*
	 * Core function to store data into a JCR Node
	 */
	public void store(Node node, String filename, InputStream data)
			throws RepositoryException {

		if (node == null) {
			throw new SystemRepositoryException("Cannot save a file to a repository Node that doesn't exist.");
		}
		if (StringUtils.isBlank(filename)) {
			throw new SystemRepositoryException("Must specify a filename to store data in the repository.");
		}

		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {
			if (node.hasNode(filename)) {
				node.getNode(filename).remove();
			}

			Node fileNode = node.addNode(filename, "nt:file");
			Node contentNode = fileNode.addNode("jcr:content", "nt:resource");

			ValueFactory valueFactory = session.getValueFactory();
			Binary contents = valueFactory.createBinary(data);
			contentNode.setProperty("jcr:data", contents);

			Calendar lastModified = Calendar.getInstance();
			lastModified.setTimeInMillis(System.currentTimeMillis());
			contentNode.setProperty("jcr:lastModified", lastModified);

			session.save();
		}
	}

	@Override
	public void store(Visibility visibility, String path, String filename, InputStream data) {
		
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node userNode = getUserNode(session, visibility);
				createPath(userNode, path);
				Node pathNode = userNode.getNode(path);
				store(pathNode, filename, data);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("store failed", e);
		}
		
	}

	public void storeInCommon(String path, String filename, InputStream data) {

		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node commonNode = getCommonNode();
				createPath(commonNode, path);
				Node pathNode = commonNode.getNode(path);
				store(pathNode, filename, data);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("common area store failed", e);
		}
	}

	public void storeInSystemDomain(String domainName, String path, String filename, InputStream data) {

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {
				Node domainNode = getSystemDomainNode(domainName);
				Node pathNode = domainNode;
				if (StringUtils.isNotBlank(path)) {
					createPath(domainNode, path);
					pathNode = domainNode.getNode(path);
				}
				store(pathNode, filename, data);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("system domain store failed", e);
		}
	}

	/*
	 * Core function to retrieve data described by a JCR Node
	 */
	public InputStream retrieve(Node node)
			throws RepositoryException {

		if (node == null) {
			throw new SystemRepositoryException("Cannot retrieve a file from a repository Node that doesn't exist.");
		}

		InputStream result = null;

		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {
			Node contentNode = node.getNode("jcr:content");
	        javax.jcr.Property prop = contentNode.getProperty("jcr:data");
	        Binary contents = prop.getBinary();
	        result = contents.getStream();
		}

		return result;
	}
	
	/*
	 * Core function to retrieve data size of a JCR Node
	 */
	private long retrieveNodeSize(Node node)
			throws RepositoryException {

		if (node == null) {
			throw new SystemRepositoryException("Cannot retrieve a file from a repository Node that doesn't exist.");
		}

		long result = 0;

		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {
			Node contentNode = node.getNode("jcr:content");
			result = contentNode.getProperty("jcr:data").getLength();
		}

		return result;
	}

	public long retrieveNodeSize(Visibility visibility, String path, String filename, String userName) {
		
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		long result = 0;
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			synchronized (session) {
				Node node;
				if (visibility != null) {
					node = getUserNode(session, visibility, userName);
				}
				else{
					node = getCommonNode();
				}
				Node pathNode = node.getNode(path);				
				Node fileNode = pathNode.getNode(filename);
				result = retrieveNodeSize(fileNode);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("retrieve failed", e);
	
		}
		
		return result;
	}

	@Override
	public InputStream retrieve(Visibility visibility, String path, String filename, String userName) {
		
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		InputStream result = null;
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			synchronized (session) {
				Node userNode = getUserNode(session, visibility, userName);
				Node pathNode = userNode.getNode(path);				
				Node fileNode = pathNode.getNode(filename);
				result = retrieve(fileNode);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("retrieve failed", e);
	
		}
		
		return result;
	}

	public InputStream retrieveFromCommon(String path, String filename) {

		InputStream result = null;

		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {
				Node commonNode = getCommonNode();
				Node pathNode = commonNode.getNode(path);
				Node fileNode = pathNode.getNode(filename);
				result = retrieve(fileNode);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("common area retrieve failed", e);
		}

		return result;
	}

	public InputStream retrieveFromSystemDomain(String domainName, String path, String filename) {

		InputStream result = null;

		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {
				Node domainNode = getSystemDomainNode(domainName);
				Node pathNode = domainNode;
				if (StringUtils.isNotBlank(path)) {
					pathNode = domainNode.getNode(path);
				}
				Node fileNode = pathNode.getNode(filename);
				result = retrieve(fileNode);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("system domain retrieve failed", e);
		}

		return result;
	}

	/*
	 * Core function to delete data described by a JCR Node
	 */
	public void delete(Node node)
			throws RepositoryException {

		if (node == null) {
			throw new SystemRepositoryException("Cannot retrieve a file from a repository Node that doesn't exist.");
		}

		Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

		synchronized (session) {
			node.remove();
			session.save();
		}
	}

	@Override
	public void delete(Visibility visibility, String path, String filename) {
		
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {			
				Node userNode = getUserNode(session, visibility);
				Node pathNode = userNode.getNode(path);
				if (pathNode.hasNode(filename)) {
					Node fileNode = pathNode.getNode(filename);
					delete(fileNode);
				}
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("delete failed", e);
		}
		
	}

	public void deleteFromCommon(String path, String filename) {

		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node commonNode = getCommonNode();
				Node pathNode = commonNode.getNode(path);
				if (pathNode.hasNode(filename)) {
					Node fileNode = pathNode.getNode(filename);
					delete(fileNode);
				}
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("common area delete failed", e);
		}
	}

	public void deleteFromSystemDomain(String domainName, String path, String filename) {
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node domainNode = getSystemDomainNode(domainName);
				Node pathNode = domainNode;
				if (StringUtils.isNotBlank(path)) {
					pathNode = domainNode.getNode(path);
				}
				if (pathNode.hasNode(filename)) {
					Node fileNode = pathNode.getNode(filename);
					delete(fileNode);
				}
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("system domain delete failed", e);
		}
	}

	/*
	 * Core function to list described by a JCR Node
	 */
	public List<RepoFile> listFiles(Node node, String filterPattern) {

		if (node == null) {
			throw new SystemRepositoryException("Cannot list files in a repository Node that doesn't exist.");
		}

		List<RepoFile> result = new ArrayList<RepoFile>();

		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				NodeIterator ni = node.getNodes();
				while (ni.hasNext()) {
					Node n = ni.nextNode();
					String name = n.getName();
					
					// Don't return version node because they don't
					// have the jcr:description property
					// also skip built-in nodes like rep:policy
					if ( !name.startsWith("jcr:") && !name.startsWith("rep:") &&
							((filterPattern == null) || (name.contains(filterPattern))) ) {
						
						RepoFile currRepoFile = new RepoFile();
						currRepoFile.setName(name);
						currRepoFile.setDirectory((n.getPrimaryNodeType() != null && !n.getPrimaryNodeType().isNodeType(NodeType.NT_FILE)));
						result.add(currRepoFile);
					}
				}
				Collections.sort(result, new RepoFileComparator());
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("listFiles failed", e);
		}
		
		return result;
	}

	@Override
	public List<RepoFile> listFiles(Visibility visibility, String path, String filterPattern, String userName) {
		
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}
		
		List<RepoFile> result = null;
		List<RepoFile> tempResult = new ArrayList<RepoFile>();
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node userNode = getUserNode(session, visibility, userName);
				Node pathNode = userNode.getNode(path);
				
				// TODO move this to another method call. 
/*				if (path.contains("services")) {
					// These are all the processes (I.E. transports, datasinks, etc)
					NodeIterator ni = pathNode.getNodes();
					while (ni.hasNext()) {
						Node n = ni.nextNode();
						tempResult.addAll(listFiles(n, filterPattern));
					}
				} */
					
				result = listFiles(pathNode, filterPattern);
				//result.addAll(tempResult);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("listFiles failed", e);
		}
		
		return result;
		
	}
	
	public List<RepoFile> listFilesInCommon(String path, String filterPattern) {
		if (StringUtils.isBlank(path)) {
			throw new SystemRepositoryException("Parameter 'path' cannot be null or a empty string.");
		}

		List<RepoFile> result = null;

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {
				Node commonNode = getCommonNode();
				Node pathNode = commonNode.getNode(path);
				result = listFiles(pathNode, filterPattern);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("common area listFiles failed", e);
		}

		return result;
	}
	
	public List<RepoFile> listFilesInSystemDomain(String domainName, String path, String filterPattern) {
		List<RepoFile> result = null;

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());

			synchronized (session) {
				Node domainNode = getSystemDomainNode(domainName);

				Node startNode = null;
				if (StringUtils.isNotBlank(path)) {
					startNode = domainNode.getNode(path);
				}
				else {
					startNode = domainNode;
				}

				result = listFiles(startNode, filterPattern);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("system domain listFiles failed", e);
		}

		return result;
	}

	public List<String> greedyListFilesWithPath(Visibility visibility, String path, String filterPattern, String userName) {
				
		ArrayList<String> result = new ArrayList<String>();
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node userNode = getUserNode(session, visibility, userName);
				
				Node startNode = null;
				if (path != null) {
					startNode = userNode.getNode(path);
				}
				else {
					startNode = userNode;
				}
				
				result.addAll(findNode(startNode, filterPattern));
				
				Collections.sort(result);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("greedyListFilesWithPath failed", e);
		}
		
		return result;
		
	}
	
	public List<String> greedyListFilesInCommon(String path, String filterPattern) {
		ArrayList<String> result = new ArrayList<String>();
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node commonNode = this.getCommonNode();
				
				Node startNode = null;
				if (path != null) {
					startNode = commonNode.getNode(path);
				}
				else {
					startNode = commonNode;
				}
				
				result.addAll(findNode(startNode, filterPattern));
				
				Collections.sort(result);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("greedyListFilesInCommon failed", e);
		}
		
		return result;
	}

	public List<String> greedyListFilesInSystemDomain(String domainName, String path, String filterPattern) {
		ArrayList<String> result = new ArrayList<String>();
		
		try {		
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
			
			synchronized (session) {
				Node domainNode = getSystemDomainNode(domainName);
				
				Node startNode = null;
				if (StringUtils.isNotBlank(path)) {
					startNode = domainNode.getNode(path);
				}
				else {
					startNode = domainNode;
				}

				result.addAll(findNode(startNode, filterPattern));
				
				Collections.sort(result);
			}
		}
		catch (RepositoryException e) {
			throw new SystemRepositoryException("greedyListFilesInSystemDomain failed", e);
		}
		
		return result;		
	}
	
	// ----- Start User Management functionality -----
	
	public User createUser(String userId, String password) {
	
		User user = null;
	
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
	
			synchronized(session) {
				JackrabbitSession js = (JackrabbitSession) session;
	
				UserManager um = js.getUserManager();
	
				Authorizable authorizable = um.getAuthorizable(userId);
	
				if (authorizable != null) {
					throw new SystemRepositoryException(userId + " already exist in the repository");
				}
	
				user = um.createUser(userId, password);
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("createUser failed", e);
		}
		
		return user;
	}
	
	public User findUser(String userId) {
		
		User user = null;
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
		
			synchronized(session) {
				JackrabbitSession js = (JackrabbitSession) session;
		
				UserManager um = js.getUserManager();
		
				Authorizable authorizable = um.getAuthorizable(userId);
		
				if (authorizable != null) {
					if (! (authorizable instanceof User)) {
						throw new SystemRepositoryException(userId + " is not a valid user");
					} 
			
					user = (User) authorizable;
				}
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("findUser failed", e);
		}
		
		return user;
		
	}
	
	public void deleteUser(String userId) {
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
		
			synchronized(session) {
				User user = findUser(userId);
				user.remove();
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("findUser failed", e);
		}

	}
	
	public void changeUserPassword(String userId, String password) {
		
		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
		
			synchronized(session) {
				User user = findUser(userId);
				user.changePassword(password);
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("changeUserPassword failed", e);
		}
		
	}
	
	public List<String> retrieveAllUserIds() {
		
		List<String> userIds = new ArrayList<String>();

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
		
			synchronized(session) {
				JackrabbitSession js = (JackrabbitSession) session;
		
				UserManager um = js.getUserManager();
    
				Iterator<Authorizable> auths = um.findAuthorizables("rep:principalName", null, UserManager.SEARCH_TYPE_USER);
	        
				while (auths.hasNext()) {
					User user = (User) auths.next();
					userIds.add(user.getID());
				}
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("retrieveAllUserIds failed", e);
		}

	    return userIds;
	    
	}
	
	public List<User> retrieveAllUsers() {
		
		List<User> users = new ArrayList<User>();

		try {
			Session session = JcrSessionCache.get().getSession(credentials.getJcrCredentials());
		
			synchronized(session) {
				JackrabbitSession js = (JackrabbitSession) session;
		
				UserManager um = js.getUserManager();
    
				Iterator<Authorizable> auths = um.findAuthorizables("rep:principalName", null, UserManager.SEARCH_TYPE_USER);
	        
				while (auths.hasNext()) {
					User user = (User) auths.next();
					users.add(user);
				}
			}
		} catch(Exception e) {
			throw new SystemRepositoryException("retrieveAllUsers failed", e);
		}

	    return users;
	    
	}
	
	// ----- End User Management functionality -----
	
	// ----- Start Private Methods -----
	
	private Node getUserNode(Session session, Visibility visibility) throws RepositoryException {
		return getUserNode(session, visibility, null);
	}
	
	private Node getUserNode(Session session, Visibility visibility, String userName) throws RepositoryException 
	{
		if (userName == null) {
			userName = credentials.getUsername();
		}
		
		Node root = session.getRootNode(); // JCR root
		String visibilityName = visibility.toString().toLowerCase();
		String userPath = visibilityName + "/" + userName;
		Node userNode = root.getNode(userPath);
		if (userNode == null) {
			throw new RepositoryException("User data path " + userPath + " does not exist");
		}
		return userNode;
	}
	
	/**
	 * Recursively iterate down the given node tree structure looking for
	 * a particular node type and return a list of absolute path of the
	 * node that matches.
	 */
	private List<String> findNode(Node node, String filterPattern) throws RepositoryException {
		
		List<String> paths = new ArrayList<String>();
		
		findNodeHelper(node, filterPattern, paths);
		
		return paths;
	}
	
	/**
	 * The helper method for the findNode method.
	 */
	private void findNodeHelper(Node node, String filterPattern, List<String> paths) throws RepositoryException {
		
		NodeIterator it = node.getNodes();
		
		while (it.hasNext()) {
			Node curr = it.nextNode();
			
			if (filterPattern == null || curr.getName().contains(filterPattern)) {
				paths.add(curr.getPath());
			}
			
			findNodeHelper(curr, filterPattern, paths);
		}
		
	}
	
	// ----- End Private Methods -----
	
	public static void main(String args[]) {
 		
		if (args.length != 3) {
			System.out.println("Parameters: <url> <userId> <password>");
			System.exit(1);
		}
		
		String url = args[0];
		String userId = args[1];
		String password = args[2];
		
		RepositoryCredentials credentials = new RepositoryCredentials(userId, password);
		try {
			final String testSales1 = "testsales_v1.0";
			final String testSales2 = "testsales_v2.0";
			
			JcrSystemRepository jcr = new JcrSystemRepository();
			jcr.setRepositoryUrl(url);
			jcr.setCredentials(credentials);
			jcr.initialize();
			
			System.out.println("Create user structures for " + userId);
			jcr.createUserStructures(credentials, userId);
			
			System.out.println("Create models folder...");
			jcr.createPath(Visibility.Public, "models");
			
			System.out.println("Delete file sets if they exist");
			jcr.delete(Visibility.Public, "models", testSales1);
			jcr.delete(Visibility.Public, "models", testSales2);
			
			System.out.println("Retrieve non-existant file set");
			try {
				@SuppressWarnings("unused")
				InputStream is = jcr.retrieve(Visibility.Public, "models", testSales1, null);
			}
			catch (SystemRepositoryException e) {
				System.out.println(e);
				System.out.println("Exception correctly raised.");
			}
			
			System.out.println("Create files...");
			ByteArrayInputStream is1 = new ByteArrayInputStream("Test Sales 1.0".getBytes());
			jcr.store(Visibility.Public, "models", testSales1, is1);
			
			ByteArrayInputStream is2 = new ByteArrayInputStream("Test Sales 2.0".getBytes());
			jcr.store(Visibility.Public, "models", testSales2, is2);			
			
			System.out.println("Test listFileSets(null):");
			List<RepoFile> repoFiles = jcr.listFiles(Visibility.Public, "models", null, null);
			for (RepoFile currRepoFile : repoFiles) {
				System.out.println(currRepoFile.getName() + " [" + (currRepoFile.isDirectory() ? "Directory" : "File") + "]");
			}
			
			System.out.println("Test listFileSets(null):");
			repoFiles = jcr.listFiles(Visibility.Private, "services", null, "leidos");
			for (RepoFile currRepoFile : repoFiles) {
				System.out.println(currRepoFile.getName() + " [" + (currRepoFile.isDirectory() ? "Directory" : "File") + "]");
			}
			
			System.out.println("Retrieving files...");
			InputStream is = jcr.retrieve(Visibility.Public, "models", testSales1, null);
			System.out.println(JcrSystemRepository.inputStream2String(is));
			
			is = jcr.retrieve(Visibility.Public, "models", testSales2, null);
			System.out.println(JcrSystemRepository.inputStream2String(is));
			
			System.out.println("Delete files...");
			jcr.delete(Visibility.Public, "models", testSales1);
			jcr.delete(Visibility.Public, "models", testSales2);
			
			System.out.println("Delete models folder...");
			jcr.deletePath(Visibility.Public, "models");
		}
		catch (Exception e) {
			e.printStackTrace();
		} 		
	}
}
